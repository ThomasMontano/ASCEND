# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_runtime_swig', [dirname(__file__)])
        except ImportError:
            import _runtime_swig
            return _runtime_swig
        if fp is not None:
            try:
                _mod = imp.load_module('_runtime_swig', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _runtime_swig = swig_import_helper()
    del swig_import_helper
else:
    import _runtime_swig
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr


try:
    import weakref
    weakref_proxy = weakref.proxy
except:
    weakref_proxy = lambda x: x


class SwigPyIterator(object):
    """Proxy of C++ swig::SwigPyIterator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_SwigPyIterator
    __del__ = lambda self : None;
    def value(self):
        """value(SwigPyIterator self) -> PyObject *"""
        return _runtime_swig.SwigPyIterator_value(self)

    def incr(self, n=1):
        """incr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        """decr(SwigPyIterator self, size_t n=1) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator_decr(self, n)

    def distance(self, *args, **kwargs):
        """distance(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t"""
        return _runtime_swig.SwigPyIterator_distance(self, *args, **kwargs)

    def equal(self, *args, **kwargs):
        """
        equal(SwigPyIterator self, SwigPyIterator x) -> bool

        pmt::equal recursively compares the contents of pairs and vectors, applying pmt::eqv on other objects such as numbers and symbols. pmt::equal may fail to terminate if its arguments are circular data structures.
        """
        return _runtime_swig.SwigPyIterator_equal(self, *args, **kwargs)

    def copy(self):
        """copy(SwigPyIterator self) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator_copy(self)

    def next(self):
        """next(SwigPyIterator self) -> PyObject *"""
        return _runtime_swig.SwigPyIterator_next(self)

    def __next__(self):
        """__next__(SwigPyIterator self) -> PyObject *"""
        return _runtime_swig.SwigPyIterator___next__(self)

    def previous(self):
        """previous(SwigPyIterator self) -> PyObject *"""
        return _runtime_swig.SwigPyIterator_previous(self)

    def advance(self, *args, **kwargs):
        """advance(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator_advance(self, *args, **kwargs)

    def __eq__(self, *args, **kwargs):
        """__eq__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _runtime_swig.SwigPyIterator___eq__(self, *args, **kwargs)

    def __ne__(self, *args, **kwargs):
        """__ne__(SwigPyIterator self, SwigPyIterator x) -> bool"""
        return _runtime_swig.SwigPyIterator___ne__(self, *args, **kwargs)

    def __iadd__(self, *args, **kwargs):
        """__iadd__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator___iadd__(self, *args, **kwargs)

    def __isub__(self, *args, **kwargs):
        """__isub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator___isub__(self, *args, **kwargs)

    def __add__(self, *args, **kwargs):
        """__add__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator"""
        return _runtime_swig.SwigPyIterator___add__(self, *args, **kwargs)

    def __sub__(self, *args):
        """
        __sub__(SwigPyIterator self, ptrdiff_t n) -> SwigPyIterator
        __sub__(SwigPyIterator self, SwigPyIterator x) -> ptrdiff_t
        """
        return _runtime_swig.SwigPyIterator___sub__(self, *args)

    def __iter__(self): return self
SwigPyIterator_swigregister = _runtime_swig.SwigPyIterator_swigregister
SwigPyIterator_swigregister(SwigPyIterator)

class gr_vsize_t(object):
    """Proxy of C++ std::vector<(size_t)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(gr_vsize_t self) -> SwigPyIterator"""
        return _runtime_swig.gr_vsize_t_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(gr_vsize_t self) -> bool"""
        return _runtime_swig.gr_vsize_t___nonzero__(self)

    def __bool__(self):
        """__bool__(gr_vsize_t self) -> bool"""
        return _runtime_swig.gr_vsize_t___bool__(self)

    def __len__(self):
        """__len__(gr_vsize_t self) -> std::vector< size_t >::size_type"""
        return _runtime_swig.gr_vsize_t___len__(self)

    def pop(self):
        """pop(gr_vsize_t self) -> std::vector< size_t >::value_type"""
        return _runtime_swig.gr_vsize_t_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(gr_vsize_t self, std::vector< size_t >::difference_type i, std::vector< size_t >::difference_type j) -> gr_vsize_t"""
        return _runtime_swig.gr_vsize_t___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """
        __setslice__(gr_vsize_t self, std::vector< size_t >::difference_type i, std::vector< size_t >::difference_type j, 
            gr_vsize_t v=std::vector< size_t,std::allocator< size_t > >())
        """
        return _runtime_swig.gr_vsize_t___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(gr_vsize_t self, std::vector< size_t >::difference_type i, std::vector< size_t >::difference_type j)"""
        return _runtime_swig.gr_vsize_t___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(gr_vsize_t self, std::vector< size_t >::difference_type i)
        __delitem__(gr_vsize_t self, PySliceObject * slice)
        """
        return _runtime_swig.gr_vsize_t___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(gr_vsize_t self, PySliceObject * slice) -> gr_vsize_t
        __getitem__(gr_vsize_t self, std::vector< size_t >::difference_type i) -> std::vector< size_t >::value_type const &
        """
        return _runtime_swig.gr_vsize_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(gr_vsize_t self, PySliceObject * slice, gr_vsize_t v)
        __setitem__(gr_vsize_t self, PySliceObject * slice)
        __setitem__(gr_vsize_t self, std::vector< size_t >::difference_type i, std::vector< size_t >::value_type const & x)
        """
        return _runtime_swig.gr_vsize_t___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(gr_vsize_t self, std::vector< size_t >::value_type const & x)"""
        return _runtime_swig.gr_vsize_t_append(self, *args, **kwargs)

    def empty(self):
        """empty(gr_vsize_t self) -> bool"""
        return _runtime_swig.gr_vsize_t_empty(self)

    def size(self):
        """size(gr_vsize_t self) -> std::vector< size_t >::size_type"""
        return _runtime_swig.gr_vsize_t_size(self)

    def clear(self):
        """clear(gr_vsize_t self)"""
        return _runtime_swig.gr_vsize_t_clear(self)

    def swap(self, *args, **kwargs):
        """swap(gr_vsize_t self, gr_vsize_t v)"""
        return _runtime_swig.gr_vsize_t_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(gr_vsize_t self) -> std::vector< size_t >::allocator_type"""
        return _runtime_swig.gr_vsize_t_get_allocator(self)

    def begin(self):
        """begin(gr_vsize_t self) -> std::vector< size_t >::iterator"""
        return _runtime_swig.gr_vsize_t_begin(self)

    def end(self):
        """end(gr_vsize_t self) -> std::vector< size_t >::iterator"""
        return _runtime_swig.gr_vsize_t_end(self)

    def rbegin(self):
        """rbegin(gr_vsize_t self) -> std::vector< size_t >::reverse_iterator"""
        return _runtime_swig.gr_vsize_t_rbegin(self)

    def rend(self):
        """rend(gr_vsize_t self) -> std::vector< size_t >::reverse_iterator"""
        return _runtime_swig.gr_vsize_t_rend(self)

    def pop_back(self):
        """pop_back(gr_vsize_t self)"""
        return _runtime_swig.gr_vsize_t_pop_back(self)

    def erase(self, *args):
        """
        erase(gr_vsize_t self, std::vector< size_t >::iterator pos) -> std::vector< size_t >::iterator
        erase(gr_vsize_t self, std::vector< size_t >::iterator first, std::vector< size_t >::iterator last) -> std::vector< size_t >::iterator
        """
        return _runtime_swig.gr_vsize_t_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(size_t)> self) -> gr_vsize_t
        __init__(std::vector<(size_t)> self, gr_vsize_t arg2) -> gr_vsize_t
        __init__(std::vector<(size_t)> self, std::vector< size_t >::size_type size) -> gr_vsize_t
        __init__(std::vector<(size_t)> self, std::vector< size_t >::size_type size, std::vector< size_t >::value_type const & value) -> gr_vsize_t
        """
        this = _runtime_swig.new_gr_vsize_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(gr_vsize_t self, std::vector< size_t >::value_type const & x)"""
        return _runtime_swig.gr_vsize_t_push_back(self, *args, **kwargs)

    def front(self):
        """front(gr_vsize_t self) -> std::vector< size_t >::value_type const &"""
        return _runtime_swig.gr_vsize_t_front(self)

    def back(self):
        """back(gr_vsize_t self) -> std::vector< size_t >::value_type const &"""
        return _runtime_swig.gr_vsize_t_back(self)

    def assign(self, *args, **kwargs):
        """assign(gr_vsize_t self, std::vector< size_t >::size_type n, std::vector< size_t >::value_type const & x)"""
        return _runtime_swig.gr_vsize_t_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(gr_vsize_t self, std::vector< size_t >::size_type new_size)
        resize(gr_vsize_t self, std::vector< size_t >::size_type new_size, std::vector< size_t >::value_type const & x)
        """
        return _runtime_swig.gr_vsize_t_resize(self, *args)

    def insert(self, *args):
        """
        insert(gr_vsize_t self, std::vector< size_t >::iterator pos, std::vector< size_t >::value_type const & x) -> std::vector< size_t >::iterator
        insert(gr_vsize_t self, std::vector< size_t >::iterator pos, std::vector< size_t >::size_type n, std::vector< size_t >::value_type const & x)
        """
        return _runtime_swig.gr_vsize_t_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(gr_vsize_t self, std::vector< size_t >::size_type n)"""
        return _runtime_swig.gr_vsize_t_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(gr_vsize_t self) -> std::vector< size_t >::size_type"""
        return _runtime_swig.gr_vsize_t_capacity(self)

    __swig_destroy__ = _runtime_swig.delete_gr_vsize_t
    __del__ = lambda self : None;
gr_vsize_t_swigregister = _runtime_swig.gr_vsize_t_swigregister
gr_vsize_t_swigregister(gr_vsize_t)

class gr_vvvsize_t(object):
    """Proxy of C++ std::vector<(std::vector<(std::vector<(size_t)>)>)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(gr_vvvsize_t self) -> SwigPyIterator"""
        return _runtime_swig.gr_vvvsize_t_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(gr_vvvsize_t self) -> bool"""
        return _runtime_swig.gr_vvvsize_t___nonzero__(self)

    def __bool__(self):
        """__bool__(gr_vvvsize_t self) -> bool"""
        return _runtime_swig.gr_vvvsize_t___bool__(self)

    def __len__(self):
        """__len__(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::size_type"""
        return _runtime_swig.gr_vvvsize_t___len__(self)

    def pop(self):
        """pop(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::value_type"""
        return _runtime_swig.gr_vvvsize_t_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i, std::vector< std::vector< std::vector< size_t > > >::difference_type j) -> gr_vvvsize_t"""
        return _runtime_swig.gr_vvvsize_t___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """
        __setslice__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i, std::vector< std::vector< std::vector< size_t > > >::difference_type j, 
            gr_vvvsize_t v=std::vector< std::vector< std::vector< size_t,std::allocator< size_t > >,std::allocator< std::vector< size_t,std::allocator< size_t > > > >,std::allocator< std::vector< std::vector< size_t,std::allocator< size_t > >,std::allocator< std::vector< size_t,std::allocator< size_t > > > > > >())
        """
        return _runtime_swig.gr_vvvsize_t___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i, std::vector< std::vector< std::vector< size_t > > >::difference_type j)"""
        return _runtime_swig.gr_vvvsize_t___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i)
        __delitem__(gr_vvvsize_t self, PySliceObject * slice)
        """
        return _runtime_swig.gr_vvvsize_t___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(gr_vvvsize_t self, PySliceObject * slice) -> gr_vvvsize_t
        __getitem__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i) -> std::vector< std::vector< std::vector< size_t > > >::value_type const &
        """
        return _runtime_swig.gr_vvvsize_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(gr_vvvsize_t self, PySliceObject * slice, gr_vvvsize_t v)
        __setitem__(gr_vvvsize_t self, PySliceObject * slice)
        __setitem__(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::difference_type i, std::vector< std::vector< std::vector< size_t > > >::value_type const & x)
        """
        return _runtime_swig.gr_vvvsize_t___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::value_type const & x)"""
        return _runtime_swig.gr_vvvsize_t_append(self, *args, **kwargs)

    def empty(self):
        """empty(gr_vvvsize_t self) -> bool"""
        return _runtime_swig.gr_vvvsize_t_empty(self)

    def size(self):
        """size(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::size_type"""
        return _runtime_swig.gr_vvvsize_t_size(self)

    def clear(self):
        """clear(gr_vvvsize_t self)"""
        return _runtime_swig.gr_vvvsize_t_clear(self)

    def swap(self, *args, **kwargs):
        """swap(gr_vvvsize_t self, gr_vvvsize_t v)"""
        return _runtime_swig.gr_vvvsize_t_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::allocator_type"""
        return _runtime_swig.gr_vvvsize_t_get_allocator(self)

    def begin(self):
        """begin(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::iterator"""
        return _runtime_swig.gr_vvvsize_t_begin(self)

    def end(self):
        """end(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::iterator"""
        return _runtime_swig.gr_vvvsize_t_end(self)

    def rbegin(self):
        """rbegin(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::reverse_iterator"""
        return _runtime_swig.gr_vvvsize_t_rbegin(self)

    def rend(self):
        """rend(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::reverse_iterator"""
        return _runtime_swig.gr_vvvsize_t_rend(self)

    def pop_back(self):
        """pop_back(gr_vvvsize_t self)"""
        return _runtime_swig.gr_vvvsize_t_pop_back(self)

    def erase(self, *args):
        """
        erase(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::iterator pos) -> std::vector< std::vector< std::vector< size_t > > >::iterator
        erase(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::iterator first, std::vector< std::vector< std::vector< size_t > > >::iterator last) -> std::vector< std::vector< std::vector< size_t > > >::iterator
        """
        return _runtime_swig.gr_vvvsize_t_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::vector<(std::vector<(size_t)>)>)> self) -> gr_vvvsize_t
        __init__(std::vector<(std::vector<(std::vector<(size_t)>)>)> self, gr_vvvsize_t arg2) -> gr_vvvsize_t
        __init__(std::vector<(std::vector<(std::vector<(size_t)>)>)> self, std::vector< std::vector< std::vector< size_t > > >::size_type size) -> gr_vvvsize_t
        __init__(std::vector<(std::vector<(std::vector<(size_t)>)>)> self, std::vector< std::vector< std::vector< size_t > > >::size_type size, std::vector< std::vector< std::vector< size_t > > >::value_type const & value) -> gr_vvvsize_t
        """
        this = _runtime_swig.new_gr_vvvsize_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::value_type const & x)"""
        return _runtime_swig.gr_vvvsize_t_push_back(self, *args, **kwargs)

    def front(self):
        """front(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::value_type const &"""
        return _runtime_swig.gr_vvvsize_t_front(self)

    def back(self):
        """back(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::value_type const &"""
        return _runtime_swig.gr_vvvsize_t_back(self)

    def assign(self, *args, **kwargs):
        """assign(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::size_type n, std::vector< std::vector< std::vector< size_t > > >::value_type const & x)"""
        return _runtime_swig.gr_vvvsize_t_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::size_type new_size)
        resize(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::size_type new_size, std::vector< std::vector< std::vector< size_t > > >::value_type const & x)
        """
        return _runtime_swig.gr_vvvsize_t_resize(self, *args)

    def insert(self, *args):
        """
        insert(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::iterator pos, std::vector< std::vector< std::vector< size_t > > >::value_type const & x) -> std::vector< std::vector< std::vector< size_t > > >::iterator
        insert(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::iterator pos, std::vector< std::vector< std::vector< size_t > > >::size_type n, 
            std::vector< std::vector< std::vector< size_t > > >::value_type const & x)
        """
        return _runtime_swig.gr_vvvsize_t_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(gr_vvvsize_t self, std::vector< std::vector< std::vector< size_t > > >::size_type n)"""
        return _runtime_swig.gr_vvvsize_t_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(gr_vvvsize_t self) -> std::vector< std::vector< std::vector< size_t > > >::size_type"""
        return _runtime_swig.gr_vvvsize_t_capacity(self)

    __swig_destroy__ = _runtime_swig.delete_gr_vvvsize_t
    __del__ = lambda self : None;
gr_vvvsize_t_swigregister = _runtime_swig.gr_vvvsize_t_swigregister
gr_vvvsize_t_swigregister(gr_vvvsize_t)

class gr_vector_complexf(object):
    """Proxy of C++ std::vector<(std::complex<(float)>)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(gr_vector_complexf self) -> SwigPyIterator"""
        return _runtime_swig.gr_vector_complexf_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(gr_vector_complexf self) -> bool"""
        return _runtime_swig.gr_vector_complexf___nonzero__(self)

    def __bool__(self):
        """__bool__(gr_vector_complexf self) -> bool"""
        return _runtime_swig.gr_vector_complexf___bool__(self)

    def __len__(self):
        """__len__(gr_vector_complexf self) -> std::vector< std::complex< float > >::size_type"""
        return _runtime_swig.gr_vector_complexf___len__(self)

    def pop(self):
        """pop(gr_vector_complexf self) -> std::vector< std::complex< float > >::value_type"""
        return _runtime_swig.gr_vector_complexf_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i, std::vector< std::complex< float > >::difference_type j) -> std::vector< std::complex< float >,std::allocator< std::complex< float > > > *"""
        return _runtime_swig.gr_vector_complexf___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """
        __setslice__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i, std::vector< std::complex< float > >::difference_type j, 
            std::vector< std::complex< float >,std::allocator< std::complex< float > > > const & v=std::vector< std::complex< float >,std::allocator< std::complex< float > > >())
        """
        return _runtime_swig.gr_vector_complexf___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i, std::vector< std::complex< float > >::difference_type j)"""
        return _runtime_swig.gr_vector_complexf___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i)
        __delitem__(gr_vector_complexf self, PySliceObject * slice)
        """
        return _runtime_swig.gr_vector_complexf___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(gr_vector_complexf self, PySliceObject * slice) -> std::vector< std::complex< float >,std::allocator< std::complex< float > > >
        __getitem__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i) -> std::vector< std::complex< float > >::value_type const &
        """
        return _runtime_swig.gr_vector_complexf___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(gr_vector_complexf self, PySliceObject * slice, std::vector< std::complex< float >,std::allocator< std::complex< float > > > const & v)
        __setitem__(gr_vector_complexf self, PySliceObject * slice)
        __setitem__(gr_vector_complexf self, std::vector< std::complex< float > >::difference_type i, std::vector< std::complex< float > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_complexf___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(gr_vector_complexf self, std::vector< std::complex< float > >::value_type const & x)"""
        return _runtime_swig.gr_vector_complexf_append(self, *args, **kwargs)

    def empty(self):
        """empty(gr_vector_complexf self) -> bool"""
        return _runtime_swig.gr_vector_complexf_empty(self)

    def size(self):
        """size(gr_vector_complexf self) -> std::vector< std::complex< float > >::size_type"""
        return _runtime_swig.gr_vector_complexf_size(self)

    def clear(self):
        """clear(gr_vector_complexf self)"""
        return _runtime_swig.gr_vector_complexf_clear(self)

    def swap(self, *args, **kwargs):
        """swap(gr_vector_complexf self, gr_vector_complexf v)"""
        return _runtime_swig.gr_vector_complexf_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(gr_vector_complexf self) -> std::vector< std::complex< float > >::allocator_type"""
        return _runtime_swig.gr_vector_complexf_get_allocator(self)

    def begin(self):
        """begin(gr_vector_complexf self) -> std::vector< std::complex< float > >::iterator"""
        return _runtime_swig.gr_vector_complexf_begin(self)

    def end(self):
        """end(gr_vector_complexf self) -> std::vector< std::complex< float > >::iterator"""
        return _runtime_swig.gr_vector_complexf_end(self)

    def rbegin(self):
        """rbegin(gr_vector_complexf self) -> std::vector< std::complex< float > >::reverse_iterator"""
        return _runtime_swig.gr_vector_complexf_rbegin(self)

    def rend(self):
        """rend(gr_vector_complexf self) -> std::vector< std::complex< float > >::reverse_iterator"""
        return _runtime_swig.gr_vector_complexf_rend(self)

    def pop_back(self):
        """pop_back(gr_vector_complexf self)"""
        return _runtime_swig.gr_vector_complexf_pop_back(self)

    def erase(self, *args):
        """
        erase(gr_vector_complexf self, std::vector< std::complex< float > >::iterator pos) -> std::vector< std::complex< float > >::iterator
        erase(gr_vector_complexf self, std::vector< std::complex< float > >::iterator first, std::vector< std::complex< float > >::iterator last) -> std::vector< std::complex< float > >::iterator
        """
        return _runtime_swig.gr_vector_complexf_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::complex<(float)>)> self) -> gr_vector_complexf
        __init__(std::vector<(std::complex<(float)>)> self, gr_vector_complexf arg2) -> gr_vector_complexf
        __init__(std::vector<(std::complex<(float)>)> self, std::vector< std::complex< float > >::size_type size) -> gr_vector_complexf
        __init__(std::vector<(std::complex<(float)>)> self, std::vector< std::complex< float > >::size_type size, std::vector< std::complex< float > >::value_type const & value) -> gr_vector_complexf
        """
        this = _runtime_swig.new_gr_vector_complexf(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(gr_vector_complexf self, std::vector< std::complex< float > >::value_type const & x)"""
        return _runtime_swig.gr_vector_complexf_push_back(self, *args, **kwargs)

    def front(self):
        """front(gr_vector_complexf self) -> std::vector< std::complex< float > >::value_type const &"""
        return _runtime_swig.gr_vector_complexf_front(self)

    def back(self):
        """back(gr_vector_complexf self) -> std::vector< std::complex< float > >::value_type const &"""
        return _runtime_swig.gr_vector_complexf_back(self)

    def assign(self, *args, **kwargs):
        """assign(gr_vector_complexf self, std::vector< std::complex< float > >::size_type n, std::vector< std::complex< float > >::value_type const & x)"""
        return _runtime_swig.gr_vector_complexf_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(gr_vector_complexf self, std::vector< std::complex< float > >::size_type new_size)
        resize(gr_vector_complexf self, std::vector< std::complex< float > >::size_type new_size, std::vector< std::complex< float > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_complexf_resize(self, *args)

    def insert(self, *args):
        """
        insert(gr_vector_complexf self, std::vector< std::complex< float > >::iterator pos, std::vector< std::complex< float > >::value_type const & x) -> std::vector< std::complex< float > >::iterator
        insert(gr_vector_complexf self, std::vector< std::complex< float > >::iterator pos, std::vector< std::complex< float > >::size_type n, 
            std::vector< std::complex< float > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_complexf_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(gr_vector_complexf self, std::vector< std::complex< float > >::size_type n)"""
        return _runtime_swig.gr_vector_complexf_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(gr_vector_complexf self) -> std::vector< std::complex< float > >::size_type"""
        return _runtime_swig.gr_vector_complexf_capacity(self)

    __swig_destroy__ = _runtime_swig.delete_gr_vector_complexf
    __del__ = lambda self : None;
gr_vector_complexf_swigregister = _runtime_swig.gr_vector_complexf_swigregister
gr_vector_complexf_swigregister(gr_vector_complexf)

class gr_vector_complexd(object):
    """Proxy of C++ std::vector<(std::complex<(double)>)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(gr_vector_complexd self) -> SwigPyIterator"""
        return _runtime_swig.gr_vector_complexd_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(gr_vector_complexd self) -> bool"""
        return _runtime_swig.gr_vector_complexd___nonzero__(self)

    def __bool__(self):
        """__bool__(gr_vector_complexd self) -> bool"""
        return _runtime_swig.gr_vector_complexd___bool__(self)

    def __len__(self):
        """__len__(gr_vector_complexd self) -> std::vector< std::complex< double > >::size_type"""
        return _runtime_swig.gr_vector_complexd___len__(self)

    def pop(self):
        """pop(gr_vector_complexd self) -> std::vector< std::complex< double > >::value_type"""
        return _runtime_swig.gr_vector_complexd_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j) -> gr_vector_complexd"""
        return _runtime_swig.gr_vector_complexd___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """
        __setslice__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j, 
            gr_vector_complexd v=std::vector< std::complex< double >,std::allocator< std::complex< double > > >())
        """
        return _runtime_swig.gr_vector_complexd___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::difference_type j)"""
        return _runtime_swig.gr_vector_complexd___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i)
        __delitem__(gr_vector_complexd self, PySliceObject * slice)
        """
        return _runtime_swig.gr_vector_complexd___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(gr_vector_complexd self, PySliceObject * slice) -> gr_vector_complexd
        __getitem__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i) -> std::vector< std::complex< double > >::value_type const &
        """
        return _runtime_swig.gr_vector_complexd___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(gr_vector_complexd self, PySliceObject * slice, gr_vector_complexd v)
        __setitem__(gr_vector_complexd self, PySliceObject * slice)
        __setitem__(gr_vector_complexd self, std::vector< std::complex< double > >::difference_type i, std::vector< std::complex< double > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_complexd___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(gr_vector_complexd self, std::vector< std::complex< double > >::value_type const & x)"""
        return _runtime_swig.gr_vector_complexd_append(self, *args, **kwargs)

    def empty(self):
        """empty(gr_vector_complexd self) -> bool"""
        return _runtime_swig.gr_vector_complexd_empty(self)

    def size(self):
        """size(gr_vector_complexd self) -> std::vector< std::complex< double > >::size_type"""
        return _runtime_swig.gr_vector_complexd_size(self)

    def clear(self):
        """clear(gr_vector_complexd self)"""
        return _runtime_swig.gr_vector_complexd_clear(self)

    def swap(self, *args, **kwargs):
        """swap(gr_vector_complexd self, gr_vector_complexd v)"""
        return _runtime_swig.gr_vector_complexd_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(gr_vector_complexd self) -> std::vector< std::complex< double > >::allocator_type"""
        return _runtime_swig.gr_vector_complexd_get_allocator(self)

    def begin(self):
        """begin(gr_vector_complexd self) -> std::vector< std::complex< double > >::iterator"""
        return _runtime_swig.gr_vector_complexd_begin(self)

    def end(self):
        """end(gr_vector_complexd self) -> std::vector< std::complex< double > >::iterator"""
        return _runtime_swig.gr_vector_complexd_end(self)

    def rbegin(self):
        """rbegin(gr_vector_complexd self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _runtime_swig.gr_vector_complexd_rbegin(self)

    def rend(self):
        """rend(gr_vector_complexd self) -> std::vector< std::complex< double > >::reverse_iterator"""
        return _runtime_swig.gr_vector_complexd_rend(self)

    def pop_back(self):
        """pop_back(gr_vector_complexd self)"""
        return _runtime_swig.gr_vector_complexd_pop_back(self)

    def erase(self, *args):
        """
        erase(gr_vector_complexd self, std::vector< std::complex< double > >::iterator pos) -> std::vector< std::complex< double > >::iterator
        erase(gr_vector_complexd self, std::vector< std::complex< double > >::iterator first, std::vector< std::complex< double > >::iterator last) -> std::vector< std::complex< double > >::iterator
        """
        return _runtime_swig.gr_vector_complexd_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::complex<(double)>)> self) -> gr_vector_complexd
        __init__(std::vector<(std::complex<(double)>)> self, gr_vector_complexd arg2) -> gr_vector_complexd
        __init__(std::vector<(std::complex<(double)>)> self, std::vector< std::complex< double > >::size_type size) -> gr_vector_complexd
        __init__(std::vector<(std::complex<(double)>)> self, std::vector< std::complex< double > >::size_type size, std::vector< std::complex< double > >::value_type const & value) -> gr_vector_complexd
        """
        this = _runtime_swig.new_gr_vector_complexd(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(gr_vector_complexd self, std::vector< std::complex< double > >::value_type const & x)"""
        return _runtime_swig.gr_vector_complexd_push_back(self, *args, **kwargs)

    def front(self):
        """front(gr_vector_complexd self) -> std::vector< std::complex< double > >::value_type const &"""
        return _runtime_swig.gr_vector_complexd_front(self)

    def back(self):
        """back(gr_vector_complexd self) -> std::vector< std::complex< double > >::value_type const &"""
        return _runtime_swig.gr_vector_complexd_back(self)

    def assign(self, *args, **kwargs):
        """assign(gr_vector_complexd self, std::vector< std::complex< double > >::size_type n, std::vector< std::complex< double > >::value_type const & x)"""
        return _runtime_swig.gr_vector_complexd_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(gr_vector_complexd self, std::vector< std::complex< double > >::size_type new_size)
        resize(gr_vector_complexd self, std::vector< std::complex< double > >::size_type new_size, std::vector< std::complex< double > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_complexd_resize(self, *args)

    def insert(self, *args):
        """
        insert(gr_vector_complexd self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::value_type const & x) -> std::vector< std::complex< double > >::iterator
        insert(gr_vector_complexd self, std::vector< std::complex< double > >::iterator pos, std::vector< std::complex< double > >::size_type n, 
            std::vector< std::complex< double > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_complexd_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(gr_vector_complexd self, std::vector< std::complex< double > >::size_type n)"""
        return _runtime_swig.gr_vector_complexd_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(gr_vector_complexd self) -> std::vector< std::complex< double > >::size_type"""
        return _runtime_swig.gr_vector_complexd_capacity(self)

    __swig_destroy__ = _runtime_swig.delete_gr_vector_complexd
    __del__ = lambda self : None;
gr_vector_complexd_swigregister = _runtime_swig.gr_vector_complexd_swigregister
gr_vector_complexd_swigregister(gr_vector_complexd)

class gr_vector_vector_complexf(object):
    """Proxy of C++ std::vector<(std::vector<(std::complex<(float)>)>)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(gr_vector_vector_complexf self) -> SwigPyIterator"""
        return _runtime_swig.gr_vector_vector_complexf_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(gr_vector_vector_complexf self) -> bool"""
        return _runtime_swig.gr_vector_vector_complexf___nonzero__(self)

    def __bool__(self):
        """__bool__(gr_vector_vector_complexf self) -> bool"""
        return _runtime_swig.gr_vector_vector_complexf___bool__(self)

    def __len__(self):
        """__len__(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::size_type"""
        return _runtime_swig.gr_vector_vector_complexf___len__(self)

    def pop(self):
        """pop(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::value_type"""
        return _runtime_swig.gr_vector_vector_complexf_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i, std::vector< std::vector< std::complex< float > > >::difference_type j) -> gr_vector_vector_complexf"""
        return _runtime_swig.gr_vector_vector_complexf___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """
        __setslice__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i, std::vector< std::vector< std::complex< float > > >::difference_type j, 
            gr_vector_vector_complexf v=std::vector< std::vector< std::complex< float >,std::allocator< std::complex< float > > >,std::allocator< std::vector< std::complex< float >,std::allocator< std::complex< float > > > > >())
        """
        return _runtime_swig.gr_vector_vector_complexf___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i, std::vector< std::vector< std::complex< float > > >::difference_type j)"""
        return _runtime_swig.gr_vector_vector_complexf___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i)
        __delitem__(gr_vector_vector_complexf self, PySliceObject * slice)
        """
        return _runtime_swig.gr_vector_vector_complexf___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(gr_vector_vector_complexf self, PySliceObject * slice) -> gr_vector_vector_complexf
        __getitem__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i) -> std::vector< std::vector< std::complex< float > > >::value_type const &
        """
        return _runtime_swig.gr_vector_vector_complexf___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(gr_vector_vector_complexf self, PySliceObject * slice, gr_vector_vector_complexf v)
        __setitem__(gr_vector_vector_complexf self, PySliceObject * slice)
        __setitem__(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::difference_type i, std::vector< std::vector< std::complex< float > > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_vector_complexf___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::value_type const & x)"""
        return _runtime_swig.gr_vector_vector_complexf_append(self, *args, **kwargs)

    def empty(self):
        """empty(gr_vector_vector_complexf self) -> bool"""
        return _runtime_swig.gr_vector_vector_complexf_empty(self)

    def size(self):
        """size(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::size_type"""
        return _runtime_swig.gr_vector_vector_complexf_size(self)

    def clear(self):
        """clear(gr_vector_vector_complexf self)"""
        return _runtime_swig.gr_vector_vector_complexf_clear(self)

    def swap(self, *args, **kwargs):
        """swap(gr_vector_vector_complexf self, gr_vector_vector_complexf v)"""
        return _runtime_swig.gr_vector_vector_complexf_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::allocator_type"""
        return _runtime_swig.gr_vector_vector_complexf_get_allocator(self)

    def begin(self):
        """begin(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::iterator"""
        return _runtime_swig.gr_vector_vector_complexf_begin(self)

    def end(self):
        """end(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::iterator"""
        return _runtime_swig.gr_vector_vector_complexf_end(self)

    def rbegin(self):
        """rbegin(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::reverse_iterator"""
        return _runtime_swig.gr_vector_vector_complexf_rbegin(self)

    def rend(self):
        """rend(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::reverse_iterator"""
        return _runtime_swig.gr_vector_vector_complexf_rend(self)

    def pop_back(self):
        """pop_back(gr_vector_vector_complexf self)"""
        return _runtime_swig.gr_vector_vector_complexf_pop_back(self)

    def erase(self, *args):
        """
        erase(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::iterator pos) -> std::vector< std::vector< std::complex< float > > >::iterator
        erase(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::iterator first, std::vector< std::vector< std::complex< float > > >::iterator last) -> std::vector< std::vector< std::complex< float > > >::iterator
        """
        return _runtime_swig.gr_vector_vector_complexf_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::vector<(std::complex<(float)>)>)> self) -> gr_vector_vector_complexf
        __init__(std::vector<(std::vector<(std::complex<(float)>)>)> self, gr_vector_vector_complexf arg2) -> gr_vector_vector_complexf
        __init__(std::vector<(std::vector<(std::complex<(float)>)>)> self, std::vector< std::vector< std::complex< float > > >::size_type size) -> gr_vector_vector_complexf
        __init__(std::vector<(std::vector<(std::complex<(float)>)>)> self, std::vector< std::vector< std::complex< float > > >::size_type size, std::vector< std::vector< std::complex< float > > >::value_type const & value) -> gr_vector_vector_complexf
        """
        this = _runtime_swig.new_gr_vector_vector_complexf(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::value_type const & x)"""
        return _runtime_swig.gr_vector_vector_complexf_push_back(self, *args, **kwargs)

    def front(self):
        """front(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::value_type const &"""
        return _runtime_swig.gr_vector_vector_complexf_front(self)

    def back(self):
        """back(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::value_type const &"""
        return _runtime_swig.gr_vector_vector_complexf_back(self)

    def assign(self, *args, **kwargs):
        """assign(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::size_type n, std::vector< std::vector< std::complex< float > > >::value_type const & x)"""
        return _runtime_swig.gr_vector_vector_complexf_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::size_type new_size)
        resize(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::size_type new_size, std::vector< std::vector< std::complex< float > > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_vector_complexf_resize(self, *args)

    def insert(self, *args):
        """
        insert(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::iterator pos, std::vector< std::vector< std::complex< float > > >::value_type const & x) -> std::vector< std::vector< std::complex< float > > >::iterator
        insert(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::iterator pos, std::vector< std::vector< std::complex< float > > >::size_type n, 
            std::vector< std::vector< std::complex< float > > >::value_type const & x)
        """
        return _runtime_swig.gr_vector_vector_complexf_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(gr_vector_vector_complexf self, std::vector< std::vector< std::complex< float > > >::size_type n)"""
        return _runtime_swig.gr_vector_vector_complexf_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(gr_vector_vector_complexf self) -> std::vector< std::vector< std::complex< float > > >::size_type"""
        return _runtime_swig.gr_vector_vector_complexf_capacity(self)

    __swig_destroy__ = _runtime_swig.delete_gr_vector_vector_complexf
    __del__ = lambda self : None;
gr_vector_vector_complexf_swigregister = _runtime_swig.gr_vector_vector_complexf_swigregister
gr_vector_vector_complexf_swigregister(gr_vector_vector_complexf)

class gr_vector_vector_complexd(object):
    """Proxy of C++ std::vector<(std::vector<(std::complex<(double)>)>)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(gr_vector_vector_complexd self) -> SwigPyIterator"""
        return _runtime_swig.gr_vector_vector_complexd_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(gr_vector_vector_complexd self) -> bool"""
        return _runtime_swig.gr_vector_vector_complexd___nonzero__(self)

    def __bool__(self):
        """__bool__(gr_vector_vector_complexd self) -> bool"""
        return _runtime_swig.gr_vector_vector_complexd___bool__(self)

    def __len__(self):
        """__len__(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::size_type"""
        return _runtime_swig.gr_vector_vector_complexd___len__(self)

    def pop(self):
        """pop(gr_vector_vector_complexd self) -> gr_vector_complexd"""
        return _runtime_swig.gr_vector_vector_complexd_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j) -> gr_vector_vector_complexd"""
        return _runtime_swig.gr_vector_vector_complexd___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """
        __setslice__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j, 
            gr_vector_vector_complexd v=std::vector< std::vector< std::complex< double >,std::allocator< std::complex< double > > >,std::allocator< std::vector< std::complex< double >,std::allocator< std::complex< double > > > > >())
        """
        return _runtime_swig.gr_vector_vector_complexd___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i, std::vector< std::vector< std::complex< double > > >::difference_type j)"""
        return _runtime_swig.gr_vector_vector_complexd___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i)
        __delitem__(gr_vector_vector_complexd self, PySliceObject * slice)
        """
        return _runtime_swig.gr_vector_vector_complexd___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(gr_vector_vector_complexd self, PySliceObject * slice) -> gr_vector_vector_complexd
        __getitem__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i) -> gr_vector_complexd
        """
        return _runtime_swig.gr_vector_vector_complexd___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(gr_vector_vector_complexd self, PySliceObject * slice, gr_vector_vector_complexd v)
        __setitem__(gr_vector_vector_complexd self, PySliceObject * slice)
        __setitem__(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::difference_type i, gr_vector_complexd x)
        """
        return _runtime_swig.gr_vector_vector_complexd___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(gr_vector_vector_complexd self, gr_vector_complexd x)"""
        return _runtime_swig.gr_vector_vector_complexd_append(self, *args, **kwargs)

    def empty(self):
        """empty(gr_vector_vector_complexd self) -> bool"""
        return _runtime_swig.gr_vector_vector_complexd_empty(self)

    def size(self):
        """size(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::size_type"""
        return _runtime_swig.gr_vector_vector_complexd_size(self)

    def clear(self):
        """clear(gr_vector_vector_complexd self)"""
        return _runtime_swig.gr_vector_vector_complexd_clear(self)

    def swap(self, *args, **kwargs):
        """swap(gr_vector_vector_complexd self, gr_vector_vector_complexd v)"""
        return _runtime_swig.gr_vector_vector_complexd_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::allocator_type"""
        return _runtime_swig.gr_vector_vector_complexd_get_allocator(self)

    def begin(self):
        """begin(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::iterator"""
        return _runtime_swig.gr_vector_vector_complexd_begin(self)

    def end(self):
        """end(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::iterator"""
        return _runtime_swig.gr_vector_vector_complexd_end(self)

    def rbegin(self):
        """rbegin(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::reverse_iterator"""
        return _runtime_swig.gr_vector_vector_complexd_rbegin(self)

    def rend(self):
        """rend(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::reverse_iterator"""
        return _runtime_swig.gr_vector_vector_complexd_rend(self)

    def pop_back(self):
        """pop_back(gr_vector_vector_complexd self)"""
        return _runtime_swig.gr_vector_vector_complexd_pop_back(self)

    def erase(self, *args):
        """
        erase(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::iterator pos) -> std::vector< std::vector< std::complex< double > > >::iterator
        erase(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::iterator first, std::vector< std::vector< std::complex< double > > >::iterator last) -> std::vector< std::vector< std::complex< double > > >::iterator
        """
        return _runtime_swig.gr_vector_vector_complexd_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(std::vector<(std::complex<(double)>)>)> self) -> gr_vector_vector_complexd
        __init__(std::vector<(std::vector<(std::complex<(double)>)>)> self, gr_vector_vector_complexd arg2) -> gr_vector_vector_complexd
        __init__(std::vector<(std::vector<(std::complex<(double)>)>)> self, std::vector< std::vector< std::complex< double > > >::size_type size) -> gr_vector_vector_complexd
        __init__(std::vector<(std::vector<(std::complex<(double)>)>)> self, std::vector< std::vector< std::complex< double > > >::size_type size, gr_vector_complexd value) -> gr_vector_vector_complexd
        """
        this = _runtime_swig.new_gr_vector_vector_complexd(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(gr_vector_vector_complexd self, gr_vector_complexd x)"""
        return _runtime_swig.gr_vector_vector_complexd_push_back(self, *args, **kwargs)

    def front(self):
        """front(gr_vector_vector_complexd self) -> gr_vector_complexd"""
        return _runtime_swig.gr_vector_vector_complexd_front(self)

    def back(self):
        """back(gr_vector_vector_complexd self) -> gr_vector_complexd"""
        return _runtime_swig.gr_vector_vector_complexd_back(self)

    def assign(self, *args, **kwargs):
        """assign(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::size_type n, gr_vector_complexd x)"""
        return _runtime_swig.gr_vector_vector_complexd_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::size_type new_size)
        resize(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::size_type new_size, gr_vector_complexd x)
        """
        return _runtime_swig.gr_vector_vector_complexd_resize(self, *args)

    def insert(self, *args):
        """
        insert(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::iterator pos, gr_vector_complexd x) -> std::vector< std::vector< std::complex< double > > >::iterator
        insert(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::iterator pos, std::vector< std::vector< std::complex< double > > >::size_type n, 
            gr_vector_complexd x)
        """
        return _runtime_swig.gr_vector_vector_complexd_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(gr_vector_vector_complexd self, std::vector< std::vector< std::complex< double > > >::size_type n)"""
        return _runtime_swig.gr_vector_vector_complexd_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(gr_vector_vector_complexd self) -> std::vector< std::vector< std::complex< double > > >::size_type"""
        return _runtime_swig.gr_vector_vector_complexd_capacity(self)

    __swig_destroy__ = _runtime_swig.delete_gr_vector_vector_complexd
    __del__ = lambda self : None;
gr_vector_vector_complexd_swigregister = _runtime_swig.gr_vector_vector_complexd_swigregister
gr_vector_vector_complexd_swigregister(gr_vector_vector_complexd)


def high_res_timer_now():
  """
    high_res_timer_now() -> gr::high_res_timer_type

    Get the current time in ticks.
    """
  return _runtime_swig.high_res_timer_now()

def high_res_timer_now_perfmon():
  """
    high_res_timer_now_perfmon() -> gr::high_res_timer_type

    Get the current time in ticks - for performance monitoring.
    """
  return _runtime_swig.high_res_timer_now_perfmon()

def high_res_timer_tps():
  """
    high_res_timer_tps() -> gr::high_res_timer_type

    Get the number of ticks per second.
    """
  return _runtime_swig.high_res_timer_tps()

def high_res_timer_epoch():
  """
    high_res_timer_epoch() -> gr::high_res_timer_type

    Get the tick count at the epoch.
    """
  return _runtime_swig.high_res_timer_epoch()
sizeof_char = _runtime_swig.sizeof_char
sizeof_short = _runtime_swig.sizeof_short
sizeof_int = _runtime_swig.sizeof_int
sizeof_float = _runtime_swig.sizeof_float
sizeof_double = _runtime_swig.sizeof_double
sizeof_gr_complex = _runtime_swig.sizeof_gr_complex
GR_MSB_FIRST = _runtime_swig.GR_MSB_FIRST
GR_LSB_FIRST = _runtime_swig.GR_LSB_FIRST
class basic_block_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::basic_block)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::basic_block)> self) -> basic_block_sptr
        __init__(boost::shared_ptr<(gr::basic_block)> self, basic_block p) -> basic_block_sptr
        """
        this = _runtime_swig.new_basic_block_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(basic_block_sptr self) -> basic_block"""
        return _runtime_swig.basic_block_sptr___deref__(self)

    __swig_destroy__ = _runtime_swig.delete_basic_block_sptr
    __del__ = lambda self : None;
    def name(self):
        """
        name(basic_block_sptr self) -> std::string

        The name of the block
        """
        return _runtime_swig.basic_block_sptr_name(self)

    def symbol_name(self):
        """
        symbol_name(basic_block_sptr self) -> std::string

        The sybolic name of the block, which is used in the block_registry. The name is assigned by the block's constructor and never changes during the life of the block.
        """
        return _runtime_swig.basic_block_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(basic_block_sptr self) -> io_signature_sptr"""
        return _runtime_swig.basic_block_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(basic_block_sptr self) -> io_signature_sptr"""
        return _runtime_swig.basic_block_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(basic_block_sptr self) -> long"""
        return _runtime_swig.basic_block_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(basic_block_sptr self) -> basic_block_sptr"""
        return _runtime_swig.basic_block_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """
        check_topology(basic_block_sptr self, int ninputs, int noutputs) -> bool

        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr::io_signatures.
        """
        return _runtime_swig.basic_block_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """
        alias(basic_block_sptr self) -> std::string

        Returns the block's alias as a string.
        """
        return _runtime_swig.basic_block_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """
        set_block_alias(basic_block_sptr self, std::string name)

        Set's a new alias for the block; also adds an entry into the block_registry to get the block using either the alias or the original symbol name.
        """
        return _runtime_swig.basic_block_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """
        _post(basic_block_sptr self, swig_int_ptr which_port, swig_int_ptr msg)

        Accept msg, place in queue, arrange for thread to be awakened if it's not already.
        """
        return _runtime_swig.basic_block_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """
        message_ports_in(basic_block_sptr self) -> swig_int_ptr

        Get input message port names.

        Returns the available input message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.basic_block_sptr_message_ports_in(self)

    def message_ports_out(self):
        """
        message_ports_out(basic_block_sptr self) -> swig_int_ptr

        Get output message port names.

        Returns the available output message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.basic_block_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(basic_block_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _runtime_swig.basic_block_sptr_message_subscribers(self, *args, **kwargs)

basic_block_sptr_swigregister = _runtime_swig.basic_block_sptr_swigregister
basic_block_sptr_swigregister(basic_block_sptr)

class x_vector_basic_block_sptr(object):
    """Proxy of C++ std::vector<(gr::basic_block_sptr)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(x_vector_basic_block_sptr self) -> SwigPyIterator"""
        return _runtime_swig.x_vector_basic_block_sptr_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(x_vector_basic_block_sptr self) -> bool"""
        return _runtime_swig.x_vector_basic_block_sptr___nonzero__(self)

    def __bool__(self):
        """__bool__(x_vector_basic_block_sptr self) -> bool"""
        return _runtime_swig.x_vector_basic_block_sptr___bool__(self)

    def __len__(self):
        """__len__(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::size_type"""
        return _runtime_swig.x_vector_basic_block_sptr___len__(self)

    def pop(self):
        """pop(x_vector_basic_block_sptr self) -> basic_block_sptr"""
        return _runtime_swig.x_vector_basic_block_sptr_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type j) -> x_vector_basic_block_sptr"""
        return _runtime_swig.x_vector_basic_block_sptr___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """
        __setslice__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type j, 
            x_vector_basic_block_sptr v=std::vector< boost::shared_ptr< gr::basic_block >,std::allocator< boost::shared_ptr< gr::basic_block > > >())
        """
        return _runtime_swig.x_vector_basic_block_sptr___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type j)"""
        return _runtime_swig.x_vector_basic_block_sptr___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i)
        __delitem__(x_vector_basic_block_sptr self, PySliceObject * slice)
        """
        return _runtime_swig.x_vector_basic_block_sptr___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(x_vector_basic_block_sptr self, PySliceObject * slice) -> x_vector_basic_block_sptr
        __getitem__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i) -> basic_block_sptr
        """
        return _runtime_swig.x_vector_basic_block_sptr___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(x_vector_basic_block_sptr self, PySliceObject * slice, x_vector_basic_block_sptr v)
        __setitem__(x_vector_basic_block_sptr self, PySliceObject * slice)
        __setitem__(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::difference_type i, basic_block_sptr x)
        """
        return _runtime_swig.x_vector_basic_block_sptr___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(x_vector_basic_block_sptr self, basic_block_sptr x)"""
        return _runtime_swig.x_vector_basic_block_sptr_append(self, *args, **kwargs)

    def empty(self):
        """empty(x_vector_basic_block_sptr self) -> bool"""
        return _runtime_swig.x_vector_basic_block_sptr_empty(self)

    def size(self):
        """size(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::size_type"""
        return _runtime_swig.x_vector_basic_block_sptr_size(self)

    def clear(self):
        """clear(x_vector_basic_block_sptr self)"""
        return _runtime_swig.x_vector_basic_block_sptr_clear(self)

    def swap(self, *args, **kwargs):
        """swap(x_vector_basic_block_sptr self, x_vector_basic_block_sptr v)"""
        return _runtime_swig.x_vector_basic_block_sptr_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::allocator_type"""
        return _runtime_swig.x_vector_basic_block_sptr_get_allocator(self)

    def begin(self):
        """begin(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::iterator"""
        return _runtime_swig.x_vector_basic_block_sptr_begin(self)

    def end(self):
        """end(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::iterator"""
        return _runtime_swig.x_vector_basic_block_sptr_end(self)

    def rbegin(self):
        """rbegin(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::reverse_iterator"""
        return _runtime_swig.x_vector_basic_block_sptr_rbegin(self)

    def rend(self):
        """rend(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::reverse_iterator"""
        return _runtime_swig.x_vector_basic_block_sptr_rend(self)

    def pop_back(self):
        """pop_back(x_vector_basic_block_sptr self)"""
        return _runtime_swig.x_vector_basic_block_sptr_pop_back(self)

    def erase(self, *args):
        """
        erase(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::iterator pos) -> std::vector< boost::shared_ptr< gr::basic_block > >::iterator
        erase(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::iterator first, std::vector< boost::shared_ptr< gr::basic_block > >::iterator last) -> std::vector< boost::shared_ptr< gr::basic_block > >::iterator
        """
        return _runtime_swig.x_vector_basic_block_sptr_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(gr::basic_block_sptr)> self) -> x_vector_basic_block_sptr
        __init__(std::vector<(gr::basic_block_sptr)> self, x_vector_basic_block_sptr arg2) -> x_vector_basic_block_sptr
        __init__(std::vector<(gr::basic_block_sptr)> self, std::vector< boost::shared_ptr< gr::basic_block > >::size_type size) -> x_vector_basic_block_sptr
        __init__(std::vector<(gr::basic_block_sptr)> self, std::vector< boost::shared_ptr< gr::basic_block > >::size_type size, basic_block_sptr value) -> x_vector_basic_block_sptr
        """
        this = _runtime_swig.new_x_vector_basic_block_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(x_vector_basic_block_sptr self, basic_block_sptr x)"""
        return _runtime_swig.x_vector_basic_block_sptr_push_back(self, *args, **kwargs)

    def front(self):
        """front(x_vector_basic_block_sptr self) -> basic_block_sptr"""
        return _runtime_swig.x_vector_basic_block_sptr_front(self)

    def back(self):
        """back(x_vector_basic_block_sptr self) -> basic_block_sptr"""
        return _runtime_swig.x_vector_basic_block_sptr_back(self)

    def assign(self, *args, **kwargs):
        """assign(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::size_type n, basic_block_sptr x)"""
        return _runtime_swig.x_vector_basic_block_sptr_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::size_type new_size)
        resize(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::size_type new_size, basic_block_sptr x)
        """
        return _runtime_swig.x_vector_basic_block_sptr_resize(self, *args)

    def insert(self, *args):
        """
        insert(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::iterator pos, basic_block_sptr x) -> std::vector< boost::shared_ptr< gr::basic_block > >::iterator
        insert(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::iterator pos, std::vector< boost::shared_ptr< gr::basic_block > >::size_type n, 
            basic_block_sptr x)
        """
        return _runtime_swig.x_vector_basic_block_sptr_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(x_vector_basic_block_sptr self, std::vector< boost::shared_ptr< gr::basic_block > >::size_type n)"""
        return _runtime_swig.x_vector_basic_block_sptr_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(x_vector_basic_block_sptr self) -> std::vector< boost::shared_ptr< gr::basic_block > >::size_type"""
        return _runtime_swig.x_vector_basic_block_sptr_capacity(self)

    __swig_destroy__ = _runtime_swig.delete_x_vector_basic_block_sptr
    __del__ = lambda self : None;
x_vector_basic_block_sptr_swigregister = _runtime_swig.x_vector_basic_block_sptr_swigregister
x_vector_basic_block_sptr_swigregister(x_vector_basic_block_sptr)

class basic_block(object):
    """
    The abstract base class for all signal processing blocks.

    Basic blocks are the bare abstraction of an entity that has a name, a set of inputs and outputs, and a message queue. These are never instantiated directly; rather, this is the abstract parent class of both gr_hier_block, which is a recursive container, and block, which implements actual signal processing functions.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_basic_block
    __del__ = lambda self : None;
    def name(self):
        """
        name(basic_block self) -> std::string

        The name of the block
        """
        return _runtime_swig.basic_block_name(self)

    def symbol_name(self):
        """
        symbol_name(basic_block self) -> std::string

        The sybolic name of the block, which is used in the block_registry. The name is assigned by the block's constructor and never changes during the life of the block.
        """
        return _runtime_swig.basic_block_symbol_name(self)

    def input_signature(self):
        """input_signature(basic_block self) -> io_signature_sptr"""
        return _runtime_swig.basic_block_input_signature(self)

    def output_signature(self):
        """output_signature(basic_block self) -> io_signature_sptr"""
        return _runtime_swig.basic_block_output_signature(self)

    def unique_id(self):
        """unique_id(basic_block self) -> long"""
        return _runtime_swig.basic_block_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(basic_block self) -> basic_block_sptr"""
        return _runtime_swig.basic_block_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """
        check_topology(basic_block self, int ninputs, int noutputs) -> bool

        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr::io_signatures.
        """
        return _runtime_swig.basic_block_check_topology(self, *args, **kwargs)

    def alias(self):
        """
        alias(basic_block self) -> std::string

        Returns the block's alias as a string.
        """
        return _runtime_swig.basic_block_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """
        set_block_alias(basic_block self, std::string name)

        Set's a new alias for the block; also adds an entry into the block_registry to get the block using either the alias or the original symbol name.
        """
        return _runtime_swig.basic_block_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """
        _post(basic_block self, swig_int_ptr which_port, swig_int_ptr msg)

        Accept msg, place in queue, arrange for thread to be awakened if it's not already.
        """
        return _runtime_swig.basic_block__post(self, *args, **kwargs)

    def message_ports_in(self):
        """
        message_ports_in(basic_block self) -> swig_int_ptr

        Get input message port names.

        Returns the available input message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.basic_block_message_ports_in(self)

    def message_ports_out(self):
        """
        message_ports_out(basic_block self) -> swig_int_ptr

        Get output message port names.

        Returns the available output message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.basic_block_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(basic_block self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _runtime_swig.basic_block_message_subscribers(self, *args, **kwargs)

basic_block_swigregister = _runtime_swig.basic_block_swigregister
basic_block_swigregister(basic_block)


def block_ncurrently_allocated():
  """block_ncurrently_allocated() -> long"""
  return _runtime_swig.block_ncurrently_allocated()
basic_block_sptr.__repr__ = lambda self: "<basic_block %s (%d)>" % (self.name(), self.unique_id ())

class block_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::block)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::block)> self) -> block_sptr
        __init__(boost::shared_ptr<(gr::block)> self, block p) -> block_sptr
        """
        this = _runtime_swig.new_block_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(block_sptr self) -> block"""
        return _runtime_swig.block_sptr___deref__(self)

    __swig_destroy__ = _runtime_swig.delete_block_sptr
    __del__ = lambda self : None;
    def history(self):
        """
        history(block_sptr self) -> unsigned int

        Assume block computes y_i = f(x_i, x_i-1, x_i-2, x_i-3...) History is the number of x_i's that are examined to produce one y_i. This comes in handy for FIR filters, where we use history to ensure that our input contains the appropriate "history" for the filter. History should be equal to the number of filter taps. First history samples (when there are no previous samples) are initialized with zeroes.
        """
        return _runtime_swig.block_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(block_sptr self, int which, int delay)
        declare_sample_delay(block_sptr self, unsigned int delay)

        Declares the block's delay in samples. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.

        This does not actively set the delay; it just tells the scheduler what the delay is.

        This delay is mostly used to adjust the placement of the tags and is not currently used for any signal processing. When a tag is passed through a block with internal delay, its location should be moved based on the delay of the block. This interface allows us to tell the scheduler this value.
        """
        return _runtime_swig.block_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """
        sample_delay(block_sptr self, int which) -> unsigned int

        Gets the delay of the block. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.
        """
        return _runtime_swig.block_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(block_sptr self) -> int"""
        return _runtime_swig.block_sptr_output_multiple(self)

    def relative_rate(self):
        """
        relative_rate(block_sptr self) -> double

        return the approximate output rate / input rate
        """
        return _runtime_swig.block_sptr_relative_rate(self)

    def start(self):
        """
        start(block_sptr self) -> bool

        Called to enable drivers, etc for i/o devices.

        This allows a block to enable an associated driver to begin transferring data just before we start to execute the scheduler. The end result is that this reduces latency in the pipeline when dealing with audio devices, usrps, etc.
        """
        return _runtime_swig.block_sptr_start(self)

    def stop(self):
        """
        stop(block_sptr self) -> bool

        Called to disable drivers, etc for i/o devices.
        """
        return _runtime_swig.block_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """
        nitems_read(block_sptr self, unsigned int which_input) -> uint64_t

        Return the number of items read on input stream which_input.
        """
        return _runtime_swig.block_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """
        nitems_written(block_sptr self, unsigned int which_output) -> uint64_t

        Return the number of items written on output stream which_output.
        """
        return _runtime_swig.block_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """
        max_noutput_items(block_sptr self) -> int

        Return the maximum number of output items this block will handle during a call to work.
        """
        return _runtime_swig.block_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """
        set_max_noutput_items(block_sptr self, int m)

        Set the maximum number of output items this block will handle during a call to work.
        """
        return _runtime_swig.block_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """
        unset_max_noutput_items(block_sptr self)

        Clear the switch for using the max_noutput_items value of this block.

        When is_set_max_noutput_items() returns 'true', the scheduler will use the value returned by max_noutput_items() to limit the size of the number of items possible for this block's work function. If is_set_max_notput_items() returns 'false', then the scheduler ignores the internal value and uses the value set globally in the top_block.

        Use this value to clear the 'is_set' flag so the scheduler will ignore this. Use the set_max_noutput_items(m) call to both set a new value for max_noutput_items and to re-enable its use in the scheduler.
        """
        return _runtime_swig.block_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """
        is_set_max_noutput_items(block_sptr self) -> bool

        Ask the block if the flag is or is not set to use the internal value of max_noutput_items during a call to work.
        """
        return _runtime_swig.block_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """
        set_min_noutput_items(block_sptr self, int m)

        Set the minimum number of output items this block can produce during a call to work.
        """
        return _runtime_swig.block_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """
        min_noutput_items(block_sptr self) -> int

        Return the minimum number of output items this block can produce during a call to work.

        Should be 0 for most blocks. Useful if we're dealing with packets and the block produces one packet per call to work.
        """
        return _runtime_swig.block_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """
        max_output_buffer(block_sptr self, int i) -> long

        Returns max buffer size on output port .
        """
        return _runtime_swig.block_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(block_sptr self, long max_output_buffer)
        set_max_output_buffer(block_sptr self, int port, long max_output_buffer)

        Request limit on max buffer size on all output ports.

        This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.

        The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested maximum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.
        """
        return _runtime_swig.block_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """
        min_output_buffer(block_sptr self, int i) -> long

        Returns min buffer size on output port .
        """
        return _runtime_swig.block_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(block_sptr self, long min_output_buffer)
        set_min_output_buffer(block_sptr self, int port, long min_output_buffer)

        Request limit on the minimum buffer size on all output ports.

        This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.

        The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested minimum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.
        """
        return _runtime_swig.block_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """
        pc_noutput_items(block_sptr self) -> float

        Gets instantaneous noutput_items performance counter.
        """
        return _runtime_swig.block_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """
        pc_noutput_items_avg(block_sptr self) -> float

        Gets average noutput_items performance counter.
        """
        return _runtime_swig.block_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """
        pc_noutput_items_var(block_sptr self) -> float

        Gets variance of noutput_items performance counter.
        """
        return _runtime_swig.block_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """
        pc_nproduced(block_sptr self) -> float

        Gets instantaneous num items produced performance counter.
        """
        return _runtime_swig.block_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """
        pc_nproduced_avg(block_sptr self) -> float

        Gets average num items produced performance counter.
        """
        return _runtime_swig.block_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """
        pc_nproduced_var(block_sptr self) -> float

        Gets variance of num items produced performance counter.
        """
        return _runtime_swig.block_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(block_sptr self, int which) -> float
        pc_input_buffers_full(block_sptr self) -> std::vector< float,std::allocator< float > >

        Gets instantaneous fullness of  input buffer.
        """
        return _runtime_swig.block_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(block_sptr self, int which) -> float
        pc_input_buffers_full_avg(block_sptr self) -> std::vector< float,std::allocator< float > >

        Gets average fullness of  input buffer.
        """
        return _runtime_swig.block_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(block_sptr self, int which) -> float
        pc_input_buffers_full_var(block_sptr self) -> std::vector< float,std::allocator< float > >

        Gets variance of fullness of  input buffer.
        """
        return _runtime_swig.block_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(block_sptr self, int which) -> float
        pc_output_buffers_full(block_sptr self) -> std::vector< float,std::allocator< float > >

        Gets instantaneous fullness of  input buffer.
        """
        return _runtime_swig.block_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(block_sptr self, int which) -> float
        pc_output_buffers_full_avg(block_sptr self) -> std::vector< float,std::allocator< float > >

        Gets average fullness of  input buffer.
        """
        return _runtime_swig.block_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(block_sptr self, int which) -> float
        pc_output_buffers_full_var(block_sptr self) -> std::vector< float,std::allocator< float > >

        Gets variance of fullness of  input buffer.
        """
        return _runtime_swig.block_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """
        pc_work_time(block_sptr self) -> float

        Gets instantaneous clock cycles spent in work.
        """
        return _runtime_swig.block_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """
        pc_work_time_avg(block_sptr self) -> float

        Gets average clock cycles spent in work.
        """
        return _runtime_swig.block_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """
        pc_work_time_var(block_sptr self) -> float

        Gets average clock cycles spent in work.
        """
        return _runtime_swig.block_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """
        pc_work_time_total(block_sptr self) -> float

        Gets total clock cycles spent in work.
        """
        return _runtime_swig.block_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """
        pc_throughput_avg(block_sptr self) -> float

        Gets average throughput.
        """
        return _runtime_swig.block_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """
        set_processor_affinity(block_sptr self, std::vector< int,std::allocator< int > > const & mask)

        Set the thread's affinity to processor core .
        """
        return _runtime_swig.block_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """
        unset_processor_affinity(block_sptr self)

        Remove processor affinity to a specific core.
        """
        return _runtime_swig.block_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """
        processor_affinity(block_sptr self) -> std::vector< int,std::allocator< int > >

        Get the current processor affinity.
        """
        return _runtime_swig.block_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """
        active_thread_priority(block_sptr self) -> int

        Get the current thread priority in use.
        """
        return _runtime_swig.block_sptr_active_thread_priority(self)

    def thread_priority(self):
        """
        thread_priority(block_sptr self) -> int

        Get the current thread priority stored.
        """
        return _runtime_swig.block_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """
        set_thread_priority(block_sptr self, int priority) -> int

        Set the current thread priority.
        """
        return _runtime_swig.block_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """
        name(block_sptr self) -> std::string

        The name of the block
        """
        return _runtime_swig.block_sptr_name(self)

    def symbol_name(self):
        """
        symbol_name(block_sptr self) -> std::string

        The sybolic name of the block, which is used in the block_registry. The name is assigned by the block's constructor and never changes during the life of the block.
        """
        return _runtime_swig.block_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(block_sptr self) -> io_signature_sptr"""
        return _runtime_swig.block_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(block_sptr self) -> io_signature_sptr"""
        return _runtime_swig.block_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(block_sptr self) -> long"""
        return _runtime_swig.block_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(block_sptr self) -> basic_block_sptr"""
        return _runtime_swig.block_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """
        check_topology(block_sptr self, int ninputs, int noutputs) -> bool

        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr::io_signatures.
        """
        return _runtime_swig.block_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """
        alias(block_sptr self) -> std::string

        Returns the block's alias as a string.
        """
        return _runtime_swig.block_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """
        set_block_alias(block_sptr self, std::string name)

        Set's a new alias for the block; also adds an entry into the block_registry to get the block using either the alias or the original symbol name.
        """
        return _runtime_swig.block_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """
        _post(block_sptr self, swig_int_ptr which_port, swig_int_ptr msg)

        Accept msg, place in queue, arrange for thread to be awakened if it's not already.
        """
        return _runtime_swig.block_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """
        message_ports_in(block_sptr self) -> swig_int_ptr

        Get input message port names.

        Returns the available input message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.block_sptr_message_ports_in(self)

    def message_ports_out(self):
        """
        message_ports_out(block_sptr self) -> swig_int_ptr

        Get output message port names.

        Returns the available output message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.block_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(block_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _runtime_swig.block_sptr_message_subscribers(self, *args, **kwargs)

block_sptr_swigregister = _runtime_swig.block_sptr_swigregister
block_sptr_swigregister(block_sptr)

class x_vector_block_sptr(object):
    """Proxy of C++ std::vector<(gr::block_sptr)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(x_vector_block_sptr self) -> SwigPyIterator"""
        return _runtime_swig.x_vector_block_sptr_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(x_vector_block_sptr self) -> bool"""
        return _runtime_swig.x_vector_block_sptr___nonzero__(self)

    def __bool__(self):
        """__bool__(x_vector_block_sptr self) -> bool"""
        return _runtime_swig.x_vector_block_sptr___bool__(self)

    def __len__(self):
        """__len__(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::size_type"""
        return _runtime_swig.x_vector_block_sptr___len__(self)

    def pop(self):
        """pop(x_vector_block_sptr self) -> block_sptr"""
        return _runtime_swig.x_vector_block_sptr_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i, std::vector< boost::shared_ptr< gr::block > >::difference_type j) -> x_vector_block_sptr"""
        return _runtime_swig.x_vector_block_sptr___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """
        __setslice__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i, std::vector< boost::shared_ptr< gr::block > >::difference_type j, 
            x_vector_block_sptr v=std::vector< boost::shared_ptr< gr::block >,std::allocator< boost::shared_ptr< gr::block > > >())
        """
        return _runtime_swig.x_vector_block_sptr___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i, std::vector< boost::shared_ptr< gr::block > >::difference_type j)"""
        return _runtime_swig.x_vector_block_sptr___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i)
        __delitem__(x_vector_block_sptr self, PySliceObject * slice)
        """
        return _runtime_swig.x_vector_block_sptr___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(x_vector_block_sptr self, PySliceObject * slice) -> x_vector_block_sptr
        __getitem__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i) -> block_sptr
        """
        return _runtime_swig.x_vector_block_sptr___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(x_vector_block_sptr self, PySliceObject * slice, x_vector_block_sptr v)
        __setitem__(x_vector_block_sptr self, PySliceObject * slice)
        __setitem__(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::difference_type i, block_sptr x)
        """
        return _runtime_swig.x_vector_block_sptr___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(x_vector_block_sptr self, block_sptr x)"""
        return _runtime_swig.x_vector_block_sptr_append(self, *args, **kwargs)

    def empty(self):
        """empty(x_vector_block_sptr self) -> bool"""
        return _runtime_swig.x_vector_block_sptr_empty(self)

    def size(self):
        """size(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::size_type"""
        return _runtime_swig.x_vector_block_sptr_size(self)

    def clear(self):
        """clear(x_vector_block_sptr self)"""
        return _runtime_swig.x_vector_block_sptr_clear(self)

    def swap(self, *args, **kwargs):
        """swap(x_vector_block_sptr self, x_vector_block_sptr v)"""
        return _runtime_swig.x_vector_block_sptr_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::allocator_type"""
        return _runtime_swig.x_vector_block_sptr_get_allocator(self)

    def begin(self):
        """begin(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::iterator"""
        return _runtime_swig.x_vector_block_sptr_begin(self)

    def end(self):
        """end(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::iterator"""
        return _runtime_swig.x_vector_block_sptr_end(self)

    def rbegin(self):
        """rbegin(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::reverse_iterator"""
        return _runtime_swig.x_vector_block_sptr_rbegin(self)

    def rend(self):
        """rend(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::reverse_iterator"""
        return _runtime_swig.x_vector_block_sptr_rend(self)

    def pop_back(self):
        """pop_back(x_vector_block_sptr self)"""
        return _runtime_swig.x_vector_block_sptr_pop_back(self)

    def erase(self, *args):
        """
        erase(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::iterator pos) -> std::vector< boost::shared_ptr< gr::block > >::iterator
        erase(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::iterator first, std::vector< boost::shared_ptr< gr::block > >::iterator last) -> std::vector< boost::shared_ptr< gr::block > >::iterator
        """
        return _runtime_swig.x_vector_block_sptr_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(gr::block_sptr)> self) -> x_vector_block_sptr
        __init__(std::vector<(gr::block_sptr)> self, x_vector_block_sptr arg2) -> x_vector_block_sptr
        __init__(std::vector<(gr::block_sptr)> self, std::vector< boost::shared_ptr< gr::block > >::size_type size) -> x_vector_block_sptr
        __init__(std::vector<(gr::block_sptr)> self, std::vector< boost::shared_ptr< gr::block > >::size_type size, block_sptr value) -> x_vector_block_sptr
        """
        this = _runtime_swig.new_x_vector_block_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(x_vector_block_sptr self, block_sptr x)"""
        return _runtime_swig.x_vector_block_sptr_push_back(self, *args, **kwargs)

    def front(self):
        """front(x_vector_block_sptr self) -> block_sptr"""
        return _runtime_swig.x_vector_block_sptr_front(self)

    def back(self):
        """back(x_vector_block_sptr self) -> block_sptr"""
        return _runtime_swig.x_vector_block_sptr_back(self)

    def assign(self, *args, **kwargs):
        """assign(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::size_type n, block_sptr x)"""
        return _runtime_swig.x_vector_block_sptr_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::size_type new_size)
        resize(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::size_type new_size, block_sptr x)
        """
        return _runtime_swig.x_vector_block_sptr_resize(self, *args)

    def insert(self, *args):
        """
        insert(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::iterator pos, block_sptr x) -> std::vector< boost::shared_ptr< gr::block > >::iterator
        insert(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::iterator pos, std::vector< boost::shared_ptr< gr::block > >::size_type n, 
            block_sptr x)
        """
        return _runtime_swig.x_vector_block_sptr_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(x_vector_block_sptr self, std::vector< boost::shared_ptr< gr::block > >::size_type n)"""
        return _runtime_swig.x_vector_block_sptr_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(x_vector_block_sptr self) -> std::vector< boost::shared_ptr< gr::block > >::size_type"""
        return _runtime_swig.x_vector_block_sptr_capacity(self)

    __swig_destroy__ = _runtime_swig.delete_x_vector_block_sptr
    __del__ = lambda self : None;
x_vector_block_sptr_swigregister = _runtime_swig.x_vector_block_sptr_swigregister
x_vector_block_sptr_swigregister(x_vector_block_sptr)

class block(basic_block):
    """
    The abstract base class for all 'terminal' processing blocks.

    A signal processing flow is constructed by creating a tree of hierarchical blocks, which at any level may also contain terminal nodes that actually implement signal processing functions. This is the base class for all such leaf nodes.

    Blocks have a set of input streams and output streams. The input_signature and output_signature define the number of input streams and output streams respectively, and the type of the data items in each stream.

    Blocks report the number of items consumed on each input in general_work(), using consume() or consume_each().

    If the same number of items is produced on each output, the block returns that number from general_work(). Otherwise, the block calls produce() for each output, then returns WORK_CALLED_PRODUCE. The input and output rates are not required to be related.

    User derived blocks override two methods, forecast and general_work, to implement their signal processing behavior. forecast is called by the system scheduler to determine how many items are required on each input stream in order to produce a given number of output items.

    general_work is called to perform the signal processing in the block. It reads the input items and writes the output items.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_block
    __del__ = lambda self : None;
    def history(self):
        """
        history(block self) -> unsigned int

        Assume block computes y_i = f(x_i, x_i-1, x_i-2, x_i-3...) History is the number of x_i's that are examined to produce one y_i. This comes in handy for FIR filters, where we use history to ensure that our input contains the appropriate "history" for the filter. History should be equal to the number of filter taps. First history samples (when there are no previous samples) are initialized with zeroes.
        """
        return _runtime_swig.block_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(block self, int which, int delay)
        declare_sample_delay(block self, unsigned int delay)

        Declares the block's delay in samples. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.

        This does not actively set the delay; it just tells the scheduler what the delay is.

        This delay is mostly used to adjust the placement of the tags and is not currently used for any signal processing. When a tag is passed through a block with internal delay, its location should be moved based on the delay of the block. This interface allows us to tell the scheduler this value.
        """
        return _runtime_swig.block_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """
        sample_delay(block self, int which) -> unsigned int

        Gets the delay of the block. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.
        """
        return _runtime_swig.block_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(block self) -> int"""
        return _runtime_swig.block_output_multiple(self)

    def relative_rate(self):
        """
        relative_rate(block self) -> double

        return the approximate output rate / input rate
        """
        return _runtime_swig.block_relative_rate(self)

    def start(self):
        """
        start(block self) -> bool

        Called to enable drivers, etc for i/o devices.

        This allows a block to enable an associated driver to begin transferring data just before we start to execute the scheduler. The end result is that this reduces latency in the pipeline when dealing with audio devices, usrps, etc.
        """
        return _runtime_swig.block_start(self)

    def stop(self):
        """
        stop(block self) -> bool

        Called to disable drivers, etc for i/o devices.
        """
        return _runtime_swig.block_stop(self)

    def nitems_read(self, *args, **kwargs):
        """
        nitems_read(block self, unsigned int which_input) -> uint64_t

        Return the number of items read on input stream which_input.
        """
        return _runtime_swig.block_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """
        nitems_written(block self, unsigned int which_output) -> uint64_t

        Return the number of items written on output stream which_output.
        """
        return _runtime_swig.block_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """
        max_noutput_items(block self) -> int

        Return the maximum number of output items this block will handle during a call to work.
        """
        return _runtime_swig.block_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """
        set_max_noutput_items(block self, int m)

        Set the maximum number of output items this block will handle during a call to work.
        """
        return _runtime_swig.block_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """
        unset_max_noutput_items(block self)

        Clear the switch for using the max_noutput_items value of this block.

        When is_set_max_noutput_items() returns 'true', the scheduler will use the value returned by max_noutput_items() to limit the size of the number of items possible for this block's work function. If is_set_max_notput_items() returns 'false', then the scheduler ignores the internal value and uses the value set globally in the top_block.

        Use this value to clear the 'is_set' flag so the scheduler will ignore this. Use the set_max_noutput_items(m) call to both set a new value for max_noutput_items and to re-enable its use in the scheduler.
        """
        return _runtime_swig.block_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """
        is_set_max_noutput_items(block self) -> bool

        Ask the block if the flag is or is not set to use the internal value of max_noutput_items during a call to work.
        """
        return _runtime_swig.block_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """
        set_min_noutput_items(block self, int m)

        Set the minimum number of output items this block can produce during a call to work.
        """
        return _runtime_swig.block_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """
        min_noutput_items(block self) -> int

        Return the minimum number of output items this block can produce during a call to work.

        Should be 0 for most blocks. Useful if we're dealing with packets and the block produces one packet per call to work.
        """
        return _runtime_swig.block_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """
        max_output_buffer(block self, int i) -> long

        Returns max buffer size on output port .
        """
        return _runtime_swig.block_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(block self, long max_output_buffer)
        set_max_output_buffer(block self, int port, long max_output_buffer)

        Request limit on max buffer size on all output ports.

        This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.

        The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested maximum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.
        """
        return _runtime_swig.block_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """
        min_output_buffer(block self, int i) -> long

        Returns min buffer size on output port .
        """
        return _runtime_swig.block_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(block self, long min_output_buffer)
        set_min_output_buffer(block self, int port, long min_output_buffer)

        Request limit on the minimum buffer size on all output ports.

        This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.

        The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested minimum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.
        """
        return _runtime_swig.block_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """
        pc_noutput_items(block self) -> float

        Gets instantaneous noutput_items performance counter.
        """
        return _runtime_swig.block_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """
        pc_noutput_items_avg(block self) -> float

        Gets average noutput_items performance counter.
        """
        return _runtime_swig.block_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """
        pc_noutput_items_var(block self) -> float

        Gets variance of noutput_items performance counter.
        """
        return _runtime_swig.block_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """
        pc_nproduced(block self) -> float

        Gets instantaneous num items produced performance counter.
        """
        return _runtime_swig.block_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """
        pc_nproduced_avg(block self) -> float

        Gets average num items produced performance counter.
        """
        return _runtime_swig.block_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """
        pc_nproduced_var(block self) -> float

        Gets variance of num items produced performance counter.
        """
        return _runtime_swig.block_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(block self, int which) -> float
        pc_input_buffers_full(block self) -> std::vector< float,std::allocator< float > >

        Gets instantaneous fullness of  input buffer.
        """
        return _runtime_swig.block_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(block self, int which) -> float
        pc_input_buffers_full_avg(block self) -> std::vector< float,std::allocator< float > >

        Gets average fullness of  input buffer.
        """
        return _runtime_swig.block_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(block self, int which) -> float
        pc_input_buffers_full_var(block self) -> std::vector< float,std::allocator< float > >

        Gets variance of fullness of  input buffer.
        """
        return _runtime_swig.block_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(block self, int which) -> float
        pc_output_buffers_full(block self) -> std::vector< float,std::allocator< float > >

        Gets instantaneous fullness of  input buffer.
        """
        return _runtime_swig.block_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(block self, int which) -> float
        pc_output_buffers_full_avg(block self) -> std::vector< float,std::allocator< float > >

        Gets average fullness of  input buffer.
        """
        return _runtime_swig.block_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(block self, int which) -> float
        pc_output_buffers_full_var(block self) -> std::vector< float,std::allocator< float > >

        Gets variance of fullness of  input buffer.
        """
        return _runtime_swig.block_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """
        pc_work_time(block self) -> float

        Gets instantaneous clock cycles spent in work.
        """
        return _runtime_swig.block_pc_work_time(self)

    def pc_work_time_avg(self):
        """
        pc_work_time_avg(block self) -> float

        Gets average clock cycles spent in work.
        """
        return _runtime_swig.block_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """
        pc_work_time_var(block self) -> float

        Gets average clock cycles spent in work.
        """
        return _runtime_swig.block_pc_work_time_var(self)

    def pc_work_time_total(self):
        """
        pc_work_time_total(block self) -> float

        Gets total clock cycles spent in work.
        """
        return _runtime_swig.block_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """
        pc_throughput_avg(block self) -> float

        Gets average throughput.
        """
        return _runtime_swig.block_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """
        set_processor_affinity(block self, std::vector< int,std::allocator< int > > const & mask)

        Set the thread's affinity to processor core .
        """
        return _runtime_swig.block_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """
        unset_processor_affinity(block self)

        Remove processor affinity to a specific core.
        """
        return _runtime_swig.block_unset_processor_affinity(self)

    def processor_affinity(self):
        """
        processor_affinity(block self) -> std::vector< int,std::allocator< int > >

        Get the current processor affinity.
        """
        return _runtime_swig.block_processor_affinity(self)

    def active_thread_priority(self):
        """
        active_thread_priority(block self) -> int

        Get the current thread priority in use.
        """
        return _runtime_swig.block_active_thread_priority(self)

    def thread_priority(self):
        """
        thread_priority(block self) -> int

        Get the current thread priority stored.
        """
        return _runtime_swig.block_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """
        set_thread_priority(block self, int priority) -> int

        Set the current thread priority.
        """
        return _runtime_swig.block_set_thread_priority(self, *args, **kwargs)

block_swigregister = _runtime_swig.block_swigregister
block_swigregister(block)

class block_detail_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::block_detail)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::block_detail)> self) -> block_detail_sptr
        __init__(boost::shared_ptr<(gr::block_detail)> self, gr::block_detail * p) -> block_detail_sptr
        """
        this = _runtime_swig.new_block_detail_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(block_detail_sptr self) -> gr::block_detail *"""
        return _runtime_swig.block_detail_sptr___deref__(self)

    __swig_destroy__ = _runtime_swig.delete_block_detail_sptr
    __del__ = lambda self : None;
    def ninputs(self):
        """ninputs(block_detail_sptr self) -> int"""
        return _runtime_swig.block_detail_sptr_ninputs(self)

    def noutputs(self):
        """noutputs(block_detail_sptr self) -> int"""
        return _runtime_swig.block_detail_sptr_noutputs(self)

    def sink_p(self):
        """sink_p(block_detail_sptr self) -> bool"""
        return _runtime_swig.block_detail_sptr_sink_p(self)

    def source_p(self):
        """source_p(block_detail_sptr self) -> bool"""
        return _runtime_swig.block_detail_sptr_source_p(self)

    def set_input(self, *args, **kwargs):
        """set_input(block_detail_sptr self, unsigned int which, buffer_reader_sptr reader)"""
        return _runtime_swig.block_detail_sptr_set_input(self, *args, **kwargs)

    def input(self, *args, **kwargs):
        """input(block_detail_sptr self, unsigned int which) -> buffer_reader_sptr"""
        return _runtime_swig.block_detail_sptr_input(self, *args, **kwargs)

    def set_output(self, *args, **kwargs):
        """set_output(block_detail_sptr self, unsigned int which, buffer_sptr buffer)"""
        return _runtime_swig.block_detail_sptr_set_output(self, *args, **kwargs)

    def output(self, *args, **kwargs):
        """output(block_detail_sptr self, unsigned int which) -> buffer_sptr"""
        return _runtime_swig.block_detail_sptr_output(self, *args, **kwargs)

block_detail_sptr_swigregister = _runtime_swig.block_detail_sptr_swigregister
block_detail_sptr_swigregister(block_detail_sptr)


def block_detail_ncurrently_allocated():
  """block_detail_ncurrently_allocated() -> long"""
  return _runtime_swig.block_detail_ncurrently_allocated()
class buffer_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::buffer)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::buffer)> self) -> buffer_sptr
        __init__(boost::shared_ptr<(gr::buffer)> self, gr::buffer * p) -> buffer_sptr
        """
        this = _runtime_swig.new_buffer_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(buffer_sptr self) -> gr::buffer *"""
        return _runtime_swig.buffer_sptr___deref__(self)

    __swig_destroy__ = _runtime_swig.delete_buffer_sptr
    __del__ = lambda self : None;
buffer_sptr_swigregister = _runtime_swig.buffer_sptr_swigregister
buffer_sptr_swigregister(buffer_sptr)

class buffer_reader_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::buffer_reader)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::buffer_reader)> self) -> buffer_reader_sptr
        __init__(boost::shared_ptr<(gr::buffer_reader)> self, gr::buffer_reader * p) -> buffer_reader_sptr
        """
        this = _runtime_swig.new_buffer_reader_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(buffer_reader_sptr self) -> gr::buffer_reader *"""
        return _runtime_swig.buffer_reader_sptr___deref__(self)

    __swig_destroy__ = _runtime_swig.delete_buffer_reader_sptr
    __del__ = lambda self : None;
buffer_reader_sptr_swigregister = _runtime_swig.buffer_reader_sptr_swigregister
buffer_reader_sptr_swigregister(buffer_reader_sptr)


def buffer_ncurrently_allocated():
  """
    buffer_ncurrently_allocated() -> long

    returns # of buffers currently allocated
    """
  return _runtime_swig.buffer_ncurrently_allocated()

def buffer_reader_ncurrently_allocated():
  """
    buffer_reader_ncurrently_allocated() -> long

    returns # of buffer_readers currently allocated
    """
  return _runtime_swig.buffer_reader_ncurrently_allocated()

def prefix():
  """
    prefix() -> std::string const

    return SYSCONFDIR. Typically ${CMAKE_INSTALL_PREFIX}/etc or /etc
    """
  return _runtime_swig.prefix()

def sysconfdir():
  """
    sysconfdir() -> std::string const

    return SYSCONFDIR. Typically ${CMAKE_INSTALL_PREFIX}/etc or /etc
    """
  return _runtime_swig.sysconfdir()

def prefsdir():
  """
    prefsdir() -> std::string const

    return preferences file directory. Typically ${SYSCONFDIR}/etc/conf.d
    """
  return _runtime_swig.prefsdir()

def build_date():
  """
    build_date() -> std::string const

    return date/time of build, as set when 'cmake' is run
    """
  return _runtime_swig.build_date()

def version():
  """
    version() -> std::string const

    return version string defined by cmake (GrVersion.cmake)
    """
  return _runtime_swig.version()

def major_version():
  """
    major_version() -> std::string const

    return just the major version defined by cmake
    """
  return _runtime_swig.major_version()

def api_version():
  """
    api_version() -> std::string const

    return just the api version defined by cmake
    """
  return _runtime_swig.api_version()

def minor_version():
  """
    minor_version() -> std::string const

    returnjust the minor version defined by cmake
    """
  return _runtime_swig.minor_version()

def feval_dd_example(*args, **kwargs):
  """
    feval_dd_example(gr::feval_dd * f, double x) -> double

    trivial examples / test cases showing C++ calling Python code
    """
  return _runtime_swig.feval_dd_example(*args, **kwargs)

def feval_cc_example(*args, **kwargs):
  """feval_cc_example(gr::feval_cc * f, gr_complex x) -> gr_complex"""
  return _runtime_swig.feval_cc_example(*args, **kwargs)

def feval_ll_example(*args, **kwargs):
  """feval_ll_example(gr::feval_ll * f, long x) -> long"""
  return _runtime_swig.feval_ll_example(*args, **kwargs)

def feval_example(*args, **kwargs):
  """feval_example(gr::feval * f)"""
  return _runtime_swig.feval_example(*args, **kwargs)
class ensure_py_gil_state(object):
    """Proxy of C++ ensure_py_gil_state class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(ensure_py_gil_state self) -> ensure_py_gil_state"""
        this = _runtime_swig.new_ensure_py_gil_state()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _runtime_swig.delete_ensure_py_gil_state
    __del__ = lambda self : None;
ensure_py_gil_state_swigregister = _runtime_swig.ensure_py_gil_state_swigregister
ensure_py_gil_state_swigregister(ensure_py_gil_state)

class feval_dd(object):
    """Proxy of C++ gr::py_feval_dd class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def calleval(self, *args, **kwargs):
        """calleval(feval_dd self, double x) -> double"""
        return _runtime_swig.feval_dd_calleval(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_feval_dd
    __del__ = lambda self : None;
    def __init__(self): 
        """__init__(gr::py_feval_dd self) -> feval_dd"""
        if self.__class__ == feval_dd:
            _self = None
        else:
            _self = self
        this = _runtime_swig.new_feval_dd(_self, )
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _runtime_swig.disown_feval_dd(self)
        return weakref_proxy(self)
    def eval(self, *args, **kwargs):
        """
        eval(feval_dd self, double x) -> double

        override this to define the function
        """
        return _runtime_swig.feval_dd_eval(self, *args, **kwargs)

feval_dd_swigregister = _runtime_swig.feval_dd_swigregister
feval_dd_swigregister(feval_dd)

class feval_cc(object):
    """Proxy of C++ gr::py_feval_cc class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def calleval(self, *args, **kwargs):
        """calleval(feval_cc self, gr_complex x) -> gr_complex"""
        return _runtime_swig.feval_cc_calleval(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_feval_cc
    __del__ = lambda self : None;
    def __init__(self): 
        """__init__(gr::py_feval_cc self) -> feval_cc"""
        if self.__class__ == feval_cc:
            _self = None
        else:
            _self = self
        this = _runtime_swig.new_feval_cc(_self, )
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _runtime_swig.disown_feval_cc(self)
        return weakref_proxy(self)
    def eval(self, *args, **kwargs):
        """
        eval(feval_cc self, gr_complex x) -> gr_complex

        override this to define the function
        """
        return _runtime_swig.feval_cc_eval(self, *args, **kwargs)

feval_cc_swigregister = _runtime_swig.feval_cc_swigregister
feval_cc_swigregister(feval_cc)

class feval_ll(object):
    """Proxy of C++ gr::py_feval_ll class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def calleval(self, *args, **kwargs):
        """calleval(feval_ll self, long x) -> long"""
        return _runtime_swig.feval_ll_calleval(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_feval_ll
    __del__ = lambda self : None;
    def __init__(self): 
        """__init__(gr::py_feval_ll self) -> feval_ll"""
        if self.__class__ == feval_ll:
            _self = None
        else:
            _self = self
        this = _runtime_swig.new_feval_ll(_self, )
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _runtime_swig.disown_feval_ll(self)
        return weakref_proxy(self)
    def eval(self, *args, **kwargs):
        """
        eval(feval_ll self, long x) -> long

        override this to define the function
        """
        return _runtime_swig.feval_ll_eval(self, *args, **kwargs)

feval_ll_swigregister = _runtime_swig.feval_ll_swigregister
feval_ll_swigregister(feval_ll)

class feval(object):
    """Proxy of C++ gr::py_feval class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def calleval(self):
        """calleval(feval self)"""
        return _runtime_swig.feval_calleval(self)

    __swig_destroy__ = _runtime_swig.delete_feval
    __del__ = lambda self : None;
    def __init__(self): 
        """__init__(gr::py_feval self) -> feval"""
        if self.__class__ == feval:
            _self = None
        else:
            _self = self
        this = _runtime_swig.new_feval(_self, )
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _runtime_swig.disown_feval(self)
        return weakref_proxy(self)
    def eval(self):
        """
        eval(feval self)

        override this to define the function
        """
        return _runtime_swig.feval_eval(self)

feval_swigregister = _runtime_swig.feval_swigregister
feval_swigregister(feval)

class feval_p(object):
    """Proxy of C++ gr::py_feval_p class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def calleval(self, *args, **kwargs):
        """calleval(feval_p self, swig_int_ptr x)"""
        return _runtime_swig.feval_p_calleval(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_feval_p
    __del__ = lambda self : None;
    def __init__(self): 
        """__init__(gr::py_feval_p self) -> feval_p"""
        if self.__class__ == feval_p:
            _self = None
        else:
            _self = self
        this = _runtime_swig.new_feval_p(_self, )
        try: self.this.append(this)
        except: self.this = this
    def __disown__(self):
        self.this.disown()
        _runtime_swig.disown_feval_p(self)
        return weakref_proxy(self)
    def eval(self, *args, **kwargs):
        """
        eval(feval_p self, swig_int_ptr x)

        override this to define the function
        """
        return _runtime_swig.feval_p_eval(self, *args, **kwargs)

feval_p_swigregister = _runtime_swig.feval_p_swigregister
feval_p_swigregister(feval_p)

class hier_block2_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::hier_block2)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::hier_block2)> self) -> hier_block2_sptr
        __init__(boost::shared_ptr<(gr::hier_block2)> self, hier_block2 p) -> hier_block2_sptr
        """
        this = _runtime_swig.new_hier_block2_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(hier_block2_sptr self) -> hier_block2"""
        return _runtime_swig.hier_block2_sptr___deref__(self)

    __swig_destroy__ = _runtime_swig.delete_hier_block2_sptr
    __del__ = lambda self : None;
    def primitive_connect(self, *args):
        """
        primitive_connect(hier_block2_sptr self, basic_block_sptr block)
        primitive_connect(hier_block2_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)

        Add a stand-alone (possibly hierarchical) block to internal graph.

        This adds a gr-block or hierarchical block to the internal graph without wiring it to anything else.
        """
        return _runtime_swig.hier_block2_sptr_primitive_connect(self, *args)

    def primitive_msg_connect(self, *args):
        """
        primitive_msg_connect(hier_block2_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_connect(hier_block2_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)

        Add gr-blocks or hierarchical blocks to internal graph and wire together.

        This adds (if not done earlier by another connect) a pair of gr-blocks or hierarchical blocks to the internal message port subscription
        """
        return _runtime_swig.hier_block2_sptr_primitive_msg_connect(self, *args)

    def primitive_msg_disconnect(self, *args):
        """
        primitive_msg_disconnect(hier_block2_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_disconnect(hier_block2_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _runtime_swig.hier_block2_sptr_primitive_msg_disconnect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(hier_block2_sptr self, basic_block_sptr block)
        primitive_disconnect(hier_block2_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)

        Remove a gr-block or hierarchical block from the internal flowgraph.

        This removes a gr-block or hierarchical block from the internal flowgraph, disconnecting it from other blocks as needed.
        """
        return _runtime_swig.hier_block2_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """
        disconnect_all(hier_block2_sptr self)

        Disconnect all connections in the internal flowgraph.

        This call removes all output port to input port connections in the internal flowgraph.
        """
        return _runtime_swig.hier_block2_sptr_disconnect_all(self)

    def lock(self):
        """
        lock(hier_block2_sptr self)

        Lock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr::block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.hier_block2_sptr_lock(self)

    def unlock(self):
        """
        unlock(hier_block2_sptr self)

        Unlock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr::block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.hier_block2_sptr_unlock(self)

    def primitive_message_port_register_hier_in(self, *args, **kwargs):
        """primitive_message_port_register_hier_in(hier_block2_sptr self, swig_int_ptr port_id)"""
        return _runtime_swig.hier_block2_sptr_primitive_message_port_register_hier_in(self, *args, **kwargs)

    def primitive_message_port_register_hier_out(self, *args, **kwargs):
        """primitive_message_port_register_hier_out(hier_block2_sptr self, swig_int_ptr port_id)"""
        return _runtime_swig.hier_block2_sptr_primitive_message_port_register_hier_out(self, *args, **kwargs)

    def set_processor_affinity(self, *args, **kwargs):
        """
        set_processor_affinity(hier_block2_sptr self, std::vector< int,std::allocator< int > > const & mask)

        Set the affinity of all blocks in hier_block2 to processor core .
        """
        return _runtime_swig.hier_block2_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """
        unset_processor_affinity(hier_block2_sptr self)

        Remove processor affinity for all blocks in hier_block2.
        """
        return _runtime_swig.hier_block2_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """
        processor_affinity(hier_block2_sptr self) -> std::vector< int,std::allocator< int > >

        Get the current processor affinity.

        This returns the processor affinity value for the first block in the hier_block2's list of blocks with the assumption that they have always only been set through the hier_block2's interface. If any block has been individually set, then this call could be misleading.
        """
        return _runtime_swig.hier_block2_sptr_processor_affinity(self)

    def max_output_buffer(self, *args, **kwargs):
        """
        max_output_buffer(hier_block2_sptr self, int i) -> size_t

        Returns max buffer size (itemcount) on output port .
        """
        return _runtime_swig.hier_block2_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(hier_block2_sptr self, size_t max_output_buffer)
        set_max_output_buffer(hier_block2_sptr self, int port, size_t max_output_buffer)

        Sets max buffer size (itemcount) on all output ports.
        """
        return _runtime_swig.hier_block2_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """
        min_output_buffer(hier_block2_sptr self, int i) -> size_t

        Returns min buffer size (itemcount) on output port .
        """
        return _runtime_swig.hier_block2_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(hier_block2_sptr self, size_t min_output_buffer)
        set_min_output_buffer(hier_block2_sptr self, int port, size_t min_output_buffer)

        Sets min buffer size (itemcount) on all output ports.
        """
        return _runtime_swig.hier_block2_sptr_set_min_output_buffer(self, *args)

    def to_hier_block2(self):
        """to_hier_block2(hier_block2_sptr self) -> hier_block2_sptr"""
        return _runtime_swig.hier_block2_sptr_to_hier_block2(self)

    def name(self):
        """
        name(hier_block2_sptr self) -> std::string

        The name of the block
        """
        return _runtime_swig.hier_block2_sptr_name(self)

    def symbol_name(self):
        """
        symbol_name(hier_block2_sptr self) -> std::string

        The sybolic name of the block, which is used in the block_registry. The name is assigned by the block's constructor and never changes during the life of the block.
        """
        return _runtime_swig.hier_block2_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(hier_block2_sptr self) -> io_signature_sptr"""
        return _runtime_swig.hier_block2_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(hier_block2_sptr self) -> io_signature_sptr"""
        return _runtime_swig.hier_block2_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(hier_block2_sptr self) -> long"""
        return _runtime_swig.hier_block2_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(hier_block2_sptr self) -> basic_block_sptr"""
        return _runtime_swig.hier_block2_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """
        check_topology(hier_block2_sptr self, int ninputs, int noutputs) -> bool

        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr::io_signatures.
        """
        return _runtime_swig.hier_block2_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """
        alias(hier_block2_sptr self) -> std::string

        Returns the block's alias as a string.
        """
        return _runtime_swig.hier_block2_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """
        set_block_alias(hier_block2_sptr self, std::string name)

        Set's a new alias for the block; also adds an entry into the block_registry to get the block using either the alias or the original symbol name.
        """
        return _runtime_swig.hier_block2_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """
        _post(hier_block2_sptr self, swig_int_ptr which_port, swig_int_ptr msg)

        Accept msg, place in queue, arrange for thread to be awakened if it's not already.
        """
        return _runtime_swig.hier_block2_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """
        message_ports_in(hier_block2_sptr self) -> swig_int_ptr

        Get input message port names.

        Returns the available input message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.hier_block2_sptr_message_ports_in(self)

    def message_ports_out(self):
        """
        message_ports_out(hier_block2_sptr self) -> swig_int_ptr

        Get output message port names.

        Returns the available output message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.hier_block2_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(hier_block2_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _runtime_swig.hier_block2_sptr_message_subscribers(self, *args, **kwargs)

hier_block2_sptr_swigregister = _runtime_swig.hier_block2_sptr_swigregister
hier_block2_sptr_swigregister(hier_block2_sptr)


def hier_block2_swig(*args, **kwargs):
  """
    hier_block2_swig(std::string const name, io_signature_sptr input_signature, io_signature_sptr output_signature) -> hier_block2_sptr

    public constructor for hier_block2
    """
  return _runtime_swig.hier_block2_swig(*args, **kwargs)
class hier_block2(basic_block):
    """Hierarchical container class for gr::block's and gr::hier_block2's."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_hier_block2
    __del__ = lambda self : None;
    def primitive_connect(self, *args):
        """
        primitive_connect(hier_block2 self, basic_block_sptr block)
        primitive_connect(hier_block2 self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)

        Add a stand-alone (possibly hierarchical) block to internal graph.

        This adds a gr-block or hierarchical block to the internal graph without wiring it to anything else.
        """
        return _runtime_swig.hier_block2_primitive_connect(self, *args)

    def primitive_msg_connect(self, *args):
        """
        primitive_msg_connect(hier_block2 self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_connect(hier_block2 self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)

        Add gr-blocks or hierarchical blocks to internal graph and wire together.

        This adds (if not done earlier by another connect) a pair of gr-blocks or hierarchical blocks to the internal message port subscription
        """
        return _runtime_swig.hier_block2_primitive_msg_connect(self, *args)

    def primitive_msg_disconnect(self, *args):
        """
        primitive_msg_disconnect(hier_block2 self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_disconnect(hier_block2 self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _runtime_swig.hier_block2_primitive_msg_disconnect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(hier_block2 self, basic_block_sptr block)
        primitive_disconnect(hier_block2 self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)

        Remove a gr-block or hierarchical block from the internal flowgraph.

        This removes a gr-block or hierarchical block from the internal flowgraph, disconnecting it from other blocks as needed.
        """
        return _runtime_swig.hier_block2_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """
        disconnect_all(hier_block2 self)

        Disconnect all connections in the internal flowgraph.

        This call removes all output port to input port connections in the internal flowgraph.
        """
        return _runtime_swig.hier_block2_disconnect_all(self)

    def lock(self):
        """
        lock(hier_block2 self)

        Lock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr::block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.hier_block2_lock(self)

    def unlock(self):
        """
        unlock(hier_block2 self)

        Unlock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., gr::block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.hier_block2_unlock(self)

    def primitive_message_port_register_hier_in(self, *args, **kwargs):
        """primitive_message_port_register_hier_in(hier_block2 self, swig_int_ptr port_id)"""
        return _runtime_swig.hier_block2_primitive_message_port_register_hier_in(self, *args, **kwargs)

    def primitive_message_port_register_hier_out(self, *args, **kwargs):
        """primitive_message_port_register_hier_out(hier_block2 self, swig_int_ptr port_id)"""
        return _runtime_swig.hier_block2_primitive_message_port_register_hier_out(self, *args, **kwargs)

    def set_processor_affinity(self, *args, **kwargs):
        """
        set_processor_affinity(hier_block2 self, std::vector< int,std::allocator< int > > const & mask)

        Set the affinity of all blocks in hier_block2 to processor core .
        """
        return _runtime_swig.hier_block2_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """
        unset_processor_affinity(hier_block2 self)

        Remove processor affinity for all blocks in hier_block2.
        """
        return _runtime_swig.hier_block2_unset_processor_affinity(self)

    def processor_affinity(self):
        """
        processor_affinity(hier_block2 self) -> std::vector< int,std::allocator< int > >

        Get the current processor affinity.

        This returns the processor affinity value for the first block in the hier_block2's list of blocks with the assumption that they have always only been set through the hier_block2's interface. If any block has been individually set, then this call could be misleading.
        """
        return _runtime_swig.hier_block2_processor_affinity(self)

    def max_output_buffer(self, *args, **kwargs):
        """
        max_output_buffer(hier_block2 self, int i) -> size_t

        Returns max buffer size (itemcount) on output port .
        """
        return _runtime_swig.hier_block2_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(hier_block2 self, size_t max_output_buffer)
        set_max_output_buffer(hier_block2 self, int port, size_t max_output_buffer)

        Sets max buffer size (itemcount) on all output ports.
        """
        return _runtime_swig.hier_block2_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """
        min_output_buffer(hier_block2 self, int i) -> size_t

        Returns min buffer size (itemcount) on output port .
        """
        return _runtime_swig.hier_block2_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(hier_block2 self, size_t min_output_buffer)
        set_min_output_buffer(hier_block2 self, int port, size_t min_output_buffer)

        Sets min buffer size (itemcount) on all output ports.
        """
        return _runtime_swig.hier_block2_set_min_output_buffer(self, *args)

    def to_hier_block2(self):
        """to_hier_block2(hier_block2 self) -> hier_block2_sptr"""
        return _runtime_swig.hier_block2_to_hier_block2(self)

hier_block2_swigregister = _runtime_swig.hier_block2_swigregister
hier_block2_swigregister(hier_block2)


def dot_graph(*args, **kwargs):
  """
    dot_graph(hier_block2_sptr hierblock2) -> std::string

    Return hierarchical block's flow graph represented in dot language.
    """
  return _runtime_swig.dot_graph(*args, **kwargs)
class io_signature(object):
    """
    i/o signature for input and output ports.

    misc

    Constructor Specific Documentation:

    Create an i/o signature.

    Args:
        min_streams : specify minimum number of streams (>= 0)
        max_streams : specify maximum number of streams (>= min_streams or -1 -> infinite)
        sizeof_stream_item : specify the size of the items in each stream
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_io_signature
    __del__ = lambda self : None;
    def make(*args, **kwargs):
        """
        make(int min_streams, int max_streams, int sizeof_stream_item) -> io_signature_sptr

        i/o signature for input and output ports.

        misc

        Constructor Specific Documentation:

        Create an i/o signature.

        Args:
            min_streams : specify minimum number of streams (>= 0)
            max_streams : specify maximum number of streams (>= min_streams or -1 -> infinite)
            sizeof_stream_item : specify the size of the items in each stream
        """
        return _runtime_swig.io_signature_make(*args, **kwargs)

    make = staticmethod(make)
    def make2(*args, **kwargs):
        """
        make2(int min_streams, int max_streams, int sizeof_stream_item1, int sizeof_stream_item2) -> io_signature_sptr

        Create an i/o signature.
        """
        return _runtime_swig.io_signature_make2(*args, **kwargs)

    make2 = staticmethod(make2)
    def make3(*args, **kwargs):
        """
        make3(int min_streams, int max_streams, int sizeof_stream_item1, int sizeof_stream_item2, 
            int sizeof_stream_item3) -> io_signature_sptr

        Create an i/o signature.
        """
        return _runtime_swig.io_signature_make3(*args, **kwargs)

    make3 = staticmethod(make3)
    def makev(*args, **kwargs):
        """
        makev(int min_streams, int max_streams, std::vector< int,std::allocator< int > > const & sizeof_stream_items) -> io_signature_sptr

        Create an i/o signature.

        If there are more streams than there are entries in sizeof_stream_items, the value of the last entry in sizeof_stream_items is used for the missing values. sizeof_stream_items must contain at least 1 entry.
        """
        return _runtime_swig.io_signature_makev(*args, **kwargs)

    makev = staticmethod(makev)
    def min_streams(self):
        """min_streams(io_signature self) -> int"""
        return _runtime_swig.io_signature_min_streams(self)

    def max_streams(self):
        """max_streams(io_signature self) -> int"""
        return _runtime_swig.io_signature_max_streams(self)

    def sizeof_stream_item(self, *args, **kwargs):
        """sizeof_stream_item(io_signature self, int index) -> int"""
        return _runtime_swig.io_signature_sizeof_stream_item(self, *args, **kwargs)

    def sizeof_stream_items(self):
        """sizeof_stream_items(io_signature self) -> std::vector< int,std::allocator< int > >"""
        return _runtime_swig.io_signature_sizeof_stream_items(self)

io_signature_swigregister = _runtime_swig.io_signature_swigregister
io_signature_swigregister(io_signature)

def io_signature_make(*args, **kwargs):
  """
    io_signature_make(int min_streams, int max_streams, int sizeof_stream_item) -> io_signature_sptr

    i/o signature for input and output ports.

    misc

    Constructor Specific Documentation:

    Create an i/o signature.

    Args:
        min_streams : specify minimum number of streams (>= 0)
        max_streams : specify maximum number of streams (>= min_streams or -1 -> infinite)
        sizeof_stream_item : specify the size of the items in each stream
    """
  return _runtime_swig.io_signature_make(*args, **kwargs)

def io_signature_make2(*args, **kwargs):
  """
    io_signature_make2(int min_streams, int max_streams, int sizeof_stream_item1, int sizeof_stream_item2) -> io_signature_sptr

    Create an i/o signature.
    """
  return _runtime_swig.io_signature_make2(*args, **kwargs)

def io_signature_make3(*args, **kwargs):
  """
    io_signature_make3(int min_streams, int max_streams, int sizeof_stream_item1, int sizeof_stream_item2, 
        int sizeof_stream_item3) -> io_signature_sptr

    Create an i/o signature.
    """
  return _runtime_swig.io_signature_make3(*args, **kwargs)

def io_signature_makev(*args, **kwargs):
  """
    io_signature_makev(int min_streams, int max_streams, std::vector< int,std::allocator< int > > const & sizeof_stream_items) -> io_signature_sptr

    Create an i/o signature.

    If there are more streams than there are entries in sizeof_stream_items, the value of the last entry in sizeof_stream_items is used for the missing values. sizeof_stream_items must contain at least 1 entry.
    """
  return _runtime_swig.io_signature_makev(*args, **kwargs)

class io_signature_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::io_signature)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::io_signature)> self) -> io_signature_sptr
        __init__(boost::shared_ptr<(gr::io_signature)> self, io_signature p) -> io_signature_sptr
        """
        this = _runtime_swig.new_io_signature_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(io_signature_sptr self) -> io_signature"""
        return _runtime_swig.io_signature_sptr___deref__(self)

    __swig_destroy__ = _runtime_swig.delete_io_signature_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(io_signature_sptr self, int min_streams, int max_streams, int sizeof_stream_item) -> io_signature_sptr

        i/o signature for input and output ports.

        misc

        Constructor Specific Documentation:

        Create an i/o signature.

        Args:
            min_streams : specify minimum number of streams (>= 0)
            max_streams : specify maximum number of streams (>= min_streams or -1 -> infinite)
            sizeof_stream_item : specify the size of the items in each stream
        """
        return _runtime_swig.io_signature_sptr_make(self, *args, **kwargs)

    def make2(self, *args, **kwargs):
        """
        make2(io_signature_sptr self, int min_streams, int max_streams, int sizeof_stream_item1, int sizeof_stream_item2) -> io_signature_sptr

        Create an i/o signature.
        """
        return _runtime_swig.io_signature_sptr_make2(self, *args, **kwargs)

    def make3(self, *args, **kwargs):
        """
        make3(io_signature_sptr self, int min_streams, int max_streams, int sizeof_stream_item1, int sizeof_stream_item2, 
            int sizeof_stream_item3) -> io_signature_sptr

        Create an i/o signature.
        """
        return _runtime_swig.io_signature_sptr_make3(self, *args, **kwargs)

    def makev(self, *args, **kwargs):
        """
        makev(io_signature_sptr self, int min_streams, int max_streams, std::vector< int,std::allocator< int > > const & sizeof_stream_items) -> io_signature_sptr

        Create an i/o signature.

        If there are more streams than there are entries in sizeof_stream_items, the value of the last entry in sizeof_stream_items is used for the missing values. sizeof_stream_items must contain at least 1 entry.
        """
        return _runtime_swig.io_signature_sptr_makev(self, *args, **kwargs)

    def min_streams(self):
        """min_streams(io_signature_sptr self) -> int"""
        return _runtime_swig.io_signature_sptr_min_streams(self)

    def max_streams(self):
        """max_streams(io_signature_sptr self) -> int"""
        return _runtime_swig.io_signature_sptr_max_streams(self)

    def sizeof_stream_item(self, *args, **kwargs):
        """sizeof_stream_item(io_signature_sptr self, int index) -> int"""
        return _runtime_swig.io_signature_sptr_sizeof_stream_item(self, *args, **kwargs)

    def sizeof_stream_items(self):
        """sizeof_stream_items(io_signature_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _runtime_swig.io_signature_sptr_sizeof_stream_items(self)

io_signature_sptr_swigregister = _runtime_swig.io_signature_sptr_swigregister
io_signature_sptr_swigregister(io_signature_sptr)

io_signature_sptr.__repr__ = lambda self: "<io_signature: %d, %d>" % (self.min_streams(), self.max_streams())
io_signaturev = io_signature.makev;
io_signature3 = io_signature.make3;
io_signature2 = io_signature.make2;
io_signature = io_signature.make;

class message(object):
    """
    Message class.

    The ideas and method names for adjustable message length were lifted from the click modular router "Packet" class.

    Constructor Specific Documentation:

    public constructor for message

    Args:
        type : 
        arg1 : 
        arg2 : 
        length : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(type=0, arg1=0, arg2=0, length=0):
        """
        make(long type=0, double arg1=0, double arg2=0, size_t length=0) -> message_sptr

        Message class.

        The ideas and method names for adjustable message length were lifted from the click modular router "Packet" class.

        Constructor Specific Documentation:

        public constructor for message

        Args:
            type : 
            arg1 : 
            arg2 : 
            length : 
        """
        return _runtime_swig.message_make(type, arg1, arg2, length)

    make = staticmethod(make)
    def make_from_string(*args, **kwargs):
        """make_from_string(std::string const s, long type=0, double arg1=0, double arg2=0) -> message_sptr"""
        return _runtime_swig.message_make_from_string(*args, **kwargs)

    make_from_string = staticmethod(make_from_string)
    __swig_destroy__ = _runtime_swig.delete_message
    __del__ = lambda self : None;
    def type(self):
        """type(message self) -> long"""
        return _runtime_swig.message_type(self)

    def arg1(self):
        """arg1(message self) -> double"""
        return _runtime_swig.message_arg1(self)

    def arg2(self):
        """arg2(message self) -> double"""
        return _runtime_swig.message_arg2(self)

    def set_type(self, *args, **kwargs):
        """set_type(message self, long type)"""
        return _runtime_swig.message_set_type(self, *args, **kwargs)

    def set_arg1(self, *args, **kwargs):
        """set_arg1(message self, double arg1)"""
        return _runtime_swig.message_set_arg1(self, *args, **kwargs)

    def set_arg2(self, *args, **kwargs):
        """set_arg2(message self, double arg2)"""
        return _runtime_swig.message_set_arg2(self, *args, **kwargs)

    def length(self):
        """
        length(message self) -> size_t

        Return the number of elements in v.
        """
        return _runtime_swig.message_length(self)

    def to_string(self):
        """to_string(message self) -> std::string"""
        return _runtime_swig.message_to_string(self)

message_swigregister = _runtime_swig.message_swigregister
message_swigregister(message)

def message_make(type=0, arg1=0, arg2=0, length=0):
  """
    message_make(long type=0, double arg1=0, double arg2=0, size_t length=0) -> message_sptr

    Message class.

    The ideas and method names for adjustable message length were lifted from the click modular router "Packet" class.

    Constructor Specific Documentation:

    public constructor for message

    Args:
        type : 
        arg1 : 
        arg2 : 
        length : 
    """
  return _runtime_swig.message_make(type, arg1, arg2, length)

def message_make_from_string(*args, **kwargs):
  """message_make_from_string(std::string const s, long type=0, double arg1=0, double arg2=0) -> message_sptr"""
  return _runtime_swig.message_make_from_string(*args, **kwargs)


def message_ncurrently_allocated():
  """message_ncurrently_allocated() -> long"""
  return _runtime_swig.message_ncurrently_allocated()
class message_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::message)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::message)> self) -> message_sptr
        __init__(boost::shared_ptr<(gr::message)> self, message p) -> message_sptr
        """
        this = _runtime_swig.new_message_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(message_sptr self) -> message"""
        return _runtime_swig.message_sptr___deref__(self)

    __swig_destroy__ = _runtime_swig.delete_message_sptr
    __del__ = lambda self : None;
    def make(self, type=0, arg1=0, arg2=0, length=0):
        """
        make(message_sptr self, long type=0, double arg1=0, double arg2=0, size_t length=0) -> message_sptr

        Message class.

        The ideas and method names for adjustable message length were lifted from the click modular router "Packet" class.

        Constructor Specific Documentation:

        public constructor for message

        Args:
            type : 
            arg1 : 
            arg2 : 
            length : 
        """
        return _runtime_swig.message_sptr_make(self, type, arg1, arg2, length)

    def make_from_string(self, *args, **kwargs):
        """make_from_string(message_sptr self, std::string const s, long type=0, double arg1=0, double arg2=0) -> message_sptr"""
        return _runtime_swig.message_sptr_make_from_string(self, *args, **kwargs)

    def type(self):
        """type(message_sptr self) -> long"""
        return _runtime_swig.message_sptr_type(self)

    def arg1(self):
        """arg1(message_sptr self) -> double"""
        return _runtime_swig.message_sptr_arg1(self)

    def arg2(self):
        """arg2(message_sptr self) -> double"""
        return _runtime_swig.message_sptr_arg2(self)

    def set_type(self, *args, **kwargs):
        """set_type(message_sptr self, long type)"""
        return _runtime_swig.message_sptr_set_type(self, *args, **kwargs)

    def set_arg1(self, *args, **kwargs):
        """set_arg1(message_sptr self, double arg1)"""
        return _runtime_swig.message_sptr_set_arg1(self, *args, **kwargs)

    def set_arg2(self, *args, **kwargs):
        """set_arg2(message_sptr self, double arg2)"""
        return _runtime_swig.message_sptr_set_arg2(self, *args, **kwargs)

    def length(self):
        """
        length(message_sptr self) -> size_t

        Return the number of elements in v.
        """
        return _runtime_swig.message_sptr_length(self)

    def to_string(self):
        """to_string(message_sptr self) -> std::string"""
        return _runtime_swig.message_sptr_to_string(self)

message_sptr_swigregister = _runtime_swig.message_sptr_swigregister
message_sptr_swigregister(message_sptr)

message_from_string = message.make_from_string
message = message.make

class msg_handler(object):
    """abstract class of message handlers"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_msg_handler
    __del__ = lambda self : None;
    def handle(self, *args, **kwargs):
        """
        handle(msg_handler self, message_sptr msg)

        handle
        """
        return _runtime_swig.msg_handler_handle(self, *args, **kwargs)

msg_handler_swigregister = _runtime_swig.msg_handler_swigregister
msg_handler_swigregister(msg_handler)

class msg_queue(msg_handler):
    """
    thread-safe message queue

    Constructor Specific Documentation:



    Args:
        limit : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(limit=0):
        """
        make(unsigned int limit=0) -> msg_queue_sptr

        thread-safe message queue

        Constructor Specific Documentation:



        Args:
            limit : 
        """
        return _runtime_swig.msg_queue_make(limit)

    make = staticmethod(make)
    __swig_destroy__ = _runtime_swig.delete_msg_queue
    __del__ = lambda self : None;
    def delete_head_nowait(self):
        """
        delete_head_nowait(msg_queue self) -> message_sptr

        If there's a message in the q, delete it and return it. If no message is available, return 0.
        """
        return _runtime_swig.msg_queue_delete_head_nowait(self)

    def empty_p(self):
        """
        empty_p(msg_queue self) -> bool

        is the queue empty?
        """
        return _runtime_swig.msg_queue_empty_p(self)

    def full_p(self):
        """
        full_p(msg_queue self) -> bool

        is the queue full?
        """
        return _runtime_swig.msg_queue_full_p(self)

    def count(self):
        """
        count(msg_queue self) -> unsigned int

        return number of messages in queue
        """
        return _runtime_swig.msg_queue_count(self)

    def flush(self):
        """
        flush(msg_queue self)

        Delete all messages from the queue.
        """
        return _runtime_swig.msg_queue_flush(self)

msg_queue_swigregister = _runtime_swig.msg_queue_swigregister
msg_queue_swigregister(msg_queue)

def msg_queue_make(limit=0):
  """
    msg_queue_make(unsigned int limit=0) -> msg_queue_sptr

    thread-safe message queue

    Constructor Specific Documentation:



    Args:
        limit : 
    """
  return _runtime_swig.msg_queue_make(limit)


def py_msg_queue__delete_head(*args, **kwargs):
  """py_msg_queue__delete_head(msg_queue_sptr q) -> message_sptr"""
  return _runtime_swig.py_msg_queue__delete_head(*args, **kwargs)

def py_msg_queue__insert_tail(*args, **kwargs):
  """py_msg_queue__insert_tail(msg_queue_sptr q, message_sptr msg)"""
  return _runtime_swig.py_msg_queue__insert_tail(*args, **kwargs)
class msg_queue_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::msg_queue)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::msg_queue)> self) -> msg_queue_sptr
        __init__(boost::shared_ptr<(gr::msg_queue)> self, msg_queue p) -> msg_queue_sptr
        """
        this = _runtime_swig.new_msg_queue_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(msg_queue_sptr self) -> msg_queue"""
        return _runtime_swig.msg_queue_sptr___deref__(self)

    __swig_destroy__ = _runtime_swig.delete_msg_queue_sptr
    __del__ = lambda self : None;
    def make(self, limit=0):
        """
        make(msg_queue_sptr self, unsigned int limit=0) -> msg_queue_sptr

        thread-safe message queue

        Constructor Specific Documentation:



        Args:
            limit : 
        """
        return _runtime_swig.msg_queue_sptr_make(self, limit)

    def delete_head_nowait(self):
        """
        delete_head_nowait(msg_queue_sptr self) -> message_sptr

        If there's a message in the q, delete it and return it. If no message is available, return 0.
        """
        return _runtime_swig.msg_queue_sptr_delete_head_nowait(self)

    def empty_p(self):
        """
        empty_p(msg_queue_sptr self) -> bool

        is the queue empty?
        """
        return _runtime_swig.msg_queue_sptr_empty_p(self)

    def full_p(self):
        """
        full_p(msg_queue_sptr self) -> bool

        is the queue full?
        """
        return _runtime_swig.msg_queue_sptr_full_p(self)

    def count(self):
        """
        count(msg_queue_sptr self) -> unsigned int

        return number of messages in queue
        """
        return _runtime_swig.msg_queue_sptr_count(self)

    def flush(self):
        """
        flush(msg_queue_sptr self)

        Delete all messages from the queue.
        """
        return _runtime_swig.msg_queue_sptr_flush(self)

    def handle(self, *args, **kwargs):
        """
        handle(msg_queue_sptr self, message_sptr msg)

        handle
        """
        return _runtime_swig.msg_queue_sptr_handle(self, *args, **kwargs)

msg_queue_sptr_swigregister = _runtime_swig.msg_queue_sptr_swigregister
msg_queue_sptr_swigregister(msg_queue_sptr)

msg_queue_sptr.delete_head = py_msg_queue__delete_head
msg_queue_sptr.insert_tail = py_msg_queue__insert_tail
msg_queue_sptr.handle = py_msg_queue__insert_tail
msg_queue = msg_queue.make

class prefs(object):
    """
    Base class for representing user preferences a la windows INI files.

    The real implementation is in Python, and is accessible from C++ via the magic of SWIG directors.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def singleton():
        """singleton() -> prefs"""
        return _runtime_swig.prefs_singleton()

    singleton = staticmethod(singleton)
    def add_config_file(self, *args, **kwargs):
        """
        add_config_file(prefs self, std::string const & configfile)

        If specifying a file name, this opens that specific configuration file of the standard form containing sections and key-value pairs:
        """
        return _runtime_swig.prefs_add_config_file(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_prefs
    __del__ = lambda self : None;
    def to_string(self):
        """
        to_string(prefs self) -> std::string

        Returns the configuration options as a string.
        """
        return _runtime_swig.prefs_to_string(self)

    def save(self):
        """
        save(prefs self)

        Saves the configuration settings to ${HOME}/.gnuradio/config.conf.

        WARNING: this will overwrite your current config.conf file.
        """
        return _runtime_swig.prefs_save(self)

    def has_section(self, *args, **kwargs):
        """
        has_section(prefs self, std::string const & section) -> bool

        Does  exist?
        """
        return _runtime_swig.prefs_has_section(self, *args, **kwargs)

    def has_option(self, *args, **kwargs):
        """
        has_option(prefs self, std::string const & section, std::string const & option) -> bool

        Does  exist?
        """
        return _runtime_swig.prefs_has_option(self, *args, **kwargs)

    def get_string(self, *args, **kwargs):
        """
        get_string(prefs self, std::string const & section, std::string const & option, std::string const & default_val) -> std::string const

        If option exists return associated value; else default_val.
        """
        return _runtime_swig.prefs_get_string(self, *args, **kwargs)

    def set_string(self, *args, **kwargs):
        """
        set_string(prefs self, std::string const & section, std::string const & option, std::string const & val)

        Set or add a string  to  with value .
        """
        return _runtime_swig.prefs_set_string(self, *args, **kwargs)

    def get_bool(self, *args, **kwargs):
        """
        get_bool(prefs self, std::string const & section, std::string const & option, bool default_val) -> bool

        If option exists and value can be converted to bool, return it; else default_val.
        """
        return _runtime_swig.prefs_get_bool(self, *args, **kwargs)

    def set_bool(self, *args, **kwargs):
        """
        set_bool(prefs self, std::string const & section, std::string const & option, bool val)

        Set or add a bool  to  with value .
        """
        return _runtime_swig.prefs_set_bool(self, *args, **kwargs)

    def get_long(self, *args, **kwargs):
        """
        get_long(prefs self, std::string const & section, std::string const & option, long default_val) -> long

        If option exists and value can be converted to long, return it; else default_val.
        """
        return _runtime_swig.prefs_get_long(self, *args, **kwargs)

    def set_long(self, *args, **kwargs):
        """
        set_long(prefs self, std::string const & section, std::string const & option, long val)

        Set or add a long  to  with value .
        """
        return _runtime_swig.prefs_set_long(self, *args, **kwargs)

    def get_double(self, *args, **kwargs):
        """
        get_double(prefs self, std::string const & section, std::string const & option, double default_val) -> double

        If option exists and value can be converted to double, return it; else default_val.
        """
        return _runtime_swig.prefs_get_double(self, *args, **kwargs)

    def set_double(self, *args, **kwargs):
        """
        set_double(prefs self, std::string const & section, std::string const & option, double val)

        Set or add a double  to  with value .
        """
        return _runtime_swig.prefs_set_double(self, *args, **kwargs)

    def __init__(self): 
        """
        __init__(gr::prefs self) -> prefs

        Creates an object to read preference files.

        If no file name is given (empty arg list or ""), this opens up the standard GNU Radio configuration files in prefix/etc/gnuradio/conf.d as well as ~/.gnuradio/config.conf.

        Only access this through the singleton defined here:
        """
        this = _runtime_swig.new_prefs()
        try: self.this.append(this)
        except: self.this = this
prefs_swigregister = _runtime_swig.prefs_swigregister
prefs_swigregister(prefs)

def prefs_singleton():
  """prefs_singleton() -> prefs"""
  return _runtime_swig.prefs_singleton()

RT_OK = _runtime_swig.RT_OK
RT_NOT_IMPLEMENTED = _runtime_swig.RT_NOT_IMPLEMENTED
RT_NO_PRIVS = _runtime_swig.RT_NO_PRIVS
RT_OTHER_ERROR = _runtime_swig.RT_OTHER_ERROR

def enable_realtime_scheduling():
  """
    enable_realtime_scheduling() -> gr::rt_status_t

    If possible, enable "realtime" scheduling.

    In general, this means that the code will be scheduled before any non-realtime (normal) processes. Note that if your code contains an non-blocking infinite loop and you enable realtime scheduling, it's possible to hang the system.
    """
  return _runtime_swig.enable_realtime_scheduling()
class sync_block(block):
    """
    synchronous 1:1 input to output with history

    Override work to provide the signal processing implementation.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_sync_block
    __del__ = lambda self : None;
sync_block_swigregister = _runtime_swig.sync_block_swigregister
sync_block_swigregister(sync_block)

class sync_decimator(sync_block):
    """
    synchronous N:1 input to output with history

    Override work to provide the signal processing implementation.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_sync_decimator
    __del__ = lambda self : None;
sync_decimator_swigregister = _runtime_swig.sync_decimator_swigregister
sync_decimator_swigregister(sync_decimator)

class sync_interpolator(sync_block):
    """
    synchronous 1:N input to output with history

    Override work to provide the signal processing implementation.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_sync_interpolator
    __del__ = lambda self : None;
sync_interpolator_swigregister = _runtime_swig.sync_interpolator_swigregister
sync_interpolator_swigregister(sync_interpolator)

class tagged_stream_block(block):
    """
    Block that operates on PDUs in form of tagged streams

    Override work to provide the signal processing implementation.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_tagged_stream_block
    __del__ = lambda self : None;
tagged_stream_block_swigregister = _runtime_swig.tagged_stream_block_swigregister
tagged_stream_block_swigregister(tagged_stream_block)

class tag_t(object):
    """Proxy of C++ gr::tag_t class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    offset = _swig_property(_runtime_swig.tag_t_offset_get, _runtime_swig.tag_t_offset_set)
    key = _swig_property(_runtime_swig.tag_t_key_get, _runtime_swig.tag_t_key_set)
    value = _swig_property(_runtime_swig.tag_t_value_get, _runtime_swig.tag_t_value_set)
    srcid = _swig_property(_runtime_swig.tag_t_srcid_get, _runtime_swig.tag_t_srcid_set)
    marked_deleted = _swig_property(_runtime_swig.tag_t_marked_deleted_get, _runtime_swig.tag_t_marked_deleted_set)
    def offset_compare(*args, **kwargs):
        """offset_compare(tag_t x, tag_t y) -> bool"""
        return _runtime_swig.tag_t_offset_compare(*args, **kwargs)

    offset_compare = staticmethod(offset_compare)
    def __eq__(self, *args, **kwargs):
        """__eq__(tag_t self, tag_t t) -> bool"""
        return _runtime_swig.tag_t___eq__(self, *args, **kwargs)

    def __init__(self, *args): 
        """
        __init__(gr::tag_t self) -> tag_t
        __init__(gr::tag_t self, tag_t rhs) -> tag_t
        """
        this = _runtime_swig.new_tag_t(*args)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _runtime_swig.delete_tag_t
    __del__ = lambda self : None;
tag_t_swigregister = _runtime_swig.tag_t_swigregister
tag_t_swigregister(tag_t)

def tag_t_offset_compare(*args, **kwargs):
  """tag_t_offset_compare(tag_t x, tag_t y) -> bool"""
  return _runtime_swig.tag_t_offset_compare(*args, **kwargs)

class tags_vector_t(object):
    """Proxy of C++ std::vector<(gr::tag_t)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(tags_vector_t self) -> SwigPyIterator"""
        return _runtime_swig.tags_vector_t_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(tags_vector_t self) -> bool"""
        return _runtime_swig.tags_vector_t___nonzero__(self)

    def __bool__(self):
        """__bool__(tags_vector_t self) -> bool"""
        return _runtime_swig.tags_vector_t___bool__(self)

    def __len__(self):
        """__len__(tags_vector_t self) -> std::vector< gr::tag_t >::size_type"""
        return _runtime_swig.tags_vector_t___len__(self)

    def pop(self):
        """pop(tags_vector_t self) -> tag_t"""
        return _runtime_swig.tags_vector_t_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i, std::vector< gr::tag_t >::difference_type j) -> tags_vector_t"""
        return _runtime_swig.tags_vector_t___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """
        __setslice__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i, std::vector< gr::tag_t >::difference_type j, 
            tags_vector_t v=std::vector< gr::tag_t,std::allocator< gr::tag_t > >())
        """
        return _runtime_swig.tags_vector_t___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i, std::vector< gr::tag_t >::difference_type j)"""
        return _runtime_swig.tags_vector_t___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i)
        __delitem__(tags_vector_t self, PySliceObject * slice)
        """
        return _runtime_swig.tags_vector_t___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(tags_vector_t self, PySliceObject * slice) -> tags_vector_t
        __getitem__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i) -> tag_t
        """
        return _runtime_swig.tags_vector_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(tags_vector_t self, PySliceObject * slice, tags_vector_t v)
        __setitem__(tags_vector_t self, PySliceObject * slice)
        __setitem__(tags_vector_t self, std::vector< gr::tag_t >::difference_type i, tag_t x)
        """
        return _runtime_swig.tags_vector_t___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(tags_vector_t self, tag_t x)"""
        return _runtime_swig.tags_vector_t_append(self, *args, **kwargs)

    def empty(self):
        """empty(tags_vector_t self) -> bool"""
        return _runtime_swig.tags_vector_t_empty(self)

    def size(self):
        """size(tags_vector_t self) -> std::vector< gr::tag_t >::size_type"""
        return _runtime_swig.tags_vector_t_size(self)

    def clear(self):
        """clear(tags_vector_t self)"""
        return _runtime_swig.tags_vector_t_clear(self)

    def swap(self, *args, **kwargs):
        """swap(tags_vector_t self, tags_vector_t v)"""
        return _runtime_swig.tags_vector_t_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(tags_vector_t self) -> std::vector< gr::tag_t >::allocator_type"""
        return _runtime_swig.tags_vector_t_get_allocator(self)

    def begin(self):
        """begin(tags_vector_t self) -> std::vector< gr::tag_t >::iterator"""
        return _runtime_swig.tags_vector_t_begin(self)

    def end(self):
        """end(tags_vector_t self) -> std::vector< gr::tag_t >::iterator"""
        return _runtime_swig.tags_vector_t_end(self)

    def rbegin(self):
        """rbegin(tags_vector_t self) -> std::vector< gr::tag_t >::reverse_iterator"""
        return _runtime_swig.tags_vector_t_rbegin(self)

    def rend(self):
        """rend(tags_vector_t self) -> std::vector< gr::tag_t >::reverse_iterator"""
        return _runtime_swig.tags_vector_t_rend(self)

    def pop_back(self):
        """pop_back(tags_vector_t self)"""
        return _runtime_swig.tags_vector_t_pop_back(self)

    def erase(self, *args):
        """
        erase(tags_vector_t self, std::vector< gr::tag_t >::iterator pos) -> std::vector< gr::tag_t >::iterator
        erase(tags_vector_t self, std::vector< gr::tag_t >::iterator first, std::vector< gr::tag_t >::iterator last) -> std::vector< gr::tag_t >::iterator
        """
        return _runtime_swig.tags_vector_t_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(gr::tag_t)> self) -> tags_vector_t
        __init__(std::vector<(gr::tag_t)> self, tags_vector_t arg2) -> tags_vector_t
        __init__(std::vector<(gr::tag_t)> self, std::vector< gr::tag_t >::size_type size) -> tags_vector_t
        __init__(std::vector<(gr::tag_t)> self, std::vector< gr::tag_t >::size_type size, tag_t value) -> tags_vector_t
        """
        this = _runtime_swig.new_tags_vector_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(tags_vector_t self, tag_t x)"""
        return _runtime_swig.tags_vector_t_push_back(self, *args, **kwargs)

    def front(self):
        """front(tags_vector_t self) -> tag_t"""
        return _runtime_swig.tags_vector_t_front(self)

    def back(self):
        """back(tags_vector_t self) -> tag_t"""
        return _runtime_swig.tags_vector_t_back(self)

    def assign(self, *args, **kwargs):
        """assign(tags_vector_t self, std::vector< gr::tag_t >::size_type n, tag_t x)"""
        return _runtime_swig.tags_vector_t_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(tags_vector_t self, std::vector< gr::tag_t >::size_type new_size)
        resize(tags_vector_t self, std::vector< gr::tag_t >::size_type new_size, tag_t x)
        """
        return _runtime_swig.tags_vector_t_resize(self, *args)

    def insert(self, *args):
        """
        insert(tags_vector_t self, std::vector< gr::tag_t >::iterator pos, tag_t x) -> std::vector< gr::tag_t >::iterator
        insert(tags_vector_t self, std::vector< gr::tag_t >::iterator pos, std::vector< gr::tag_t >::size_type n, tag_t x)
        """
        return _runtime_swig.tags_vector_t_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(tags_vector_t self, std::vector< gr::tag_t >::size_type n)"""
        return _runtime_swig.tags_vector_t_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(tags_vector_t self) -> std::vector< gr::tag_t >::size_type"""
        return _runtime_swig.tags_vector_t_capacity(self)

    __swig_destroy__ = _runtime_swig.delete_tags_vector_t
    __del__ = lambda self : None;
tags_vector_t_swigregister = _runtime_swig.tags_vector_t_swigregister
tags_vector_t_swigregister(tags_vector_t)

class top_block_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::top_block)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::top_block)> self) -> top_block_sptr
        __init__(boost::shared_ptr<(gr::top_block)> self, top_block p) -> top_block_sptr
        """
        this = _runtime_swig.new_top_block_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(top_block_sptr self) -> top_block"""
        return _runtime_swig.top_block_sptr___deref__(self)

    __swig_destroy__ = _runtime_swig.delete_top_block_sptr
    __del__ = lambda self : None;
    def start(self, max_noutput_items=100000000):
        """
        start(top_block_sptr self, int max_noutput_items=100000000)

        Start the contained flowgraph. Creates one or more threads to execute the flow graph. Returns to the caller once the threads are created. Calling start() on a top_block that is already started IS an error.
        """
        return _runtime_swig.top_block_sptr_start(self, max_noutput_items)

    def stop(self):
        """
        stop(top_block_sptr self)

        Stop the running flowgraph. Notifies each thread created by the scheduler to shutdown, then returns to caller. Calling stop() on a top_block that is already stopped IS NOT an error.
        """
        return _runtime_swig.top_block_sptr_stop(self)

    def lock(self):
        """
        lock(top_block_sptr self)

        Lock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.top_block_sptr_lock(self)

    def unlock(self):
        """
        unlock(top_block_sptr self)

        Unlock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.top_block_sptr_unlock(self)

    def edge_list(self):
        """
        edge_list(top_block_sptr self) -> std::string

        Returns a string that lists the edge connections in the flattened flowgraph.
        """
        return _runtime_swig.top_block_sptr_edge_list(self)

    def msg_edge_list(self):
        """
        msg_edge_list(top_block_sptr self) -> std::string

        Returns a string that lists the msg edge connections in the flattened flowgraph.
        """
        return _runtime_swig.top_block_sptr_msg_edge_list(self)

    def dump(self):
        """
        dump(top_block_sptr self)

        Displays flattened flowgraph edges and block connectivity
        """
        return _runtime_swig.top_block_sptr_dump(self)

    def max_noutput_items(self):
        """
        max_noutput_items(top_block_sptr self) -> int

        Get the number of max noutput_items in the flowgraph.
        """
        return _runtime_swig.top_block_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """
        set_max_noutput_items(top_block_sptr self, int nmax)

        Set the maximum number of noutput_items in the flowgraph.
        """
        return _runtime_swig.top_block_sptr_set_max_noutput_items(self, *args, **kwargs)

    def to_top_block(self):
        """to_top_block(top_block_sptr self) -> top_block_sptr"""
        return _runtime_swig.top_block_sptr_to_top_block(self)

    def primitive_connect(self, *args):
        """
        primitive_connect(top_block_sptr self, basic_block_sptr block)
        primitive_connect(top_block_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)

        Add a stand-alone (possibly hierarchical) block to internal graph.

        This adds a gr-block or hierarchical block to the internal graph without wiring it to anything else.
        """
        return _runtime_swig.top_block_sptr_primitive_connect(self, *args)

    def primitive_msg_connect(self, *args):
        """
        primitive_msg_connect(top_block_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_connect(top_block_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)

        Add gr-blocks or hierarchical blocks to internal graph and wire together.

        This adds (if not done earlier by another connect) a pair of gr-blocks or hierarchical blocks to the internal message port subscription
        """
        return _runtime_swig.top_block_sptr_primitive_msg_connect(self, *args)

    def primitive_msg_disconnect(self, *args):
        """
        primitive_msg_disconnect(top_block_sptr self, basic_block_sptr src, swig_int_ptr srcport, basic_block_sptr dst, swig_int_ptr dstport)
        primitive_msg_disconnect(top_block_sptr self, basic_block_sptr src, std::string srcport, basic_block_sptr dst, std::string dstport)
        """
        return _runtime_swig.top_block_sptr_primitive_msg_disconnect(self, *args)

    def primitive_disconnect(self, *args):
        """
        primitive_disconnect(top_block_sptr self, basic_block_sptr block)
        primitive_disconnect(top_block_sptr self, basic_block_sptr src, int src_port, basic_block_sptr dst, int dst_port)

        Remove a gr-block or hierarchical block from the internal flowgraph.

        This removes a gr-block or hierarchical block from the internal flowgraph, disconnecting it from other blocks as needed.
        """
        return _runtime_swig.top_block_sptr_primitive_disconnect(self, *args)

    def disconnect_all(self):
        """
        disconnect_all(top_block_sptr self)

        Disconnect all connections in the internal flowgraph.

        This call removes all output port to input port connections in the internal flowgraph.
        """
        return _runtime_swig.top_block_sptr_disconnect_all(self)

    def primitive_message_port_register_hier_in(self, *args, **kwargs):
        """primitive_message_port_register_hier_in(top_block_sptr self, swig_int_ptr port_id)"""
        return _runtime_swig.top_block_sptr_primitive_message_port_register_hier_in(self, *args, **kwargs)

    def primitive_message_port_register_hier_out(self, *args, **kwargs):
        """primitive_message_port_register_hier_out(top_block_sptr self, swig_int_ptr port_id)"""
        return _runtime_swig.top_block_sptr_primitive_message_port_register_hier_out(self, *args, **kwargs)

    def set_processor_affinity(self, *args, **kwargs):
        """
        set_processor_affinity(top_block_sptr self, std::vector< int,std::allocator< int > > const & mask)

        Set the affinity of all blocks in hier_block2 to processor core .
        """
        return _runtime_swig.top_block_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """
        unset_processor_affinity(top_block_sptr self)

        Remove processor affinity for all blocks in hier_block2.
        """
        return _runtime_swig.top_block_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """
        processor_affinity(top_block_sptr self) -> std::vector< int,std::allocator< int > >

        Get the current processor affinity.

        This returns the processor affinity value for the first block in the hier_block2's list of blocks with the assumption that they have always only been set through the hier_block2's interface. If any block has been individually set, then this call could be misleading.
        """
        return _runtime_swig.top_block_sptr_processor_affinity(self)

    def max_output_buffer(self, *args, **kwargs):
        """
        max_output_buffer(top_block_sptr self, int i) -> size_t

        Returns max buffer size (itemcount) on output port .
        """
        return _runtime_swig.top_block_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(top_block_sptr self, size_t max_output_buffer)
        set_max_output_buffer(top_block_sptr self, int port, size_t max_output_buffer)

        Sets max buffer size (itemcount) on all output ports.
        """
        return _runtime_swig.top_block_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """
        min_output_buffer(top_block_sptr self, int i) -> size_t

        Returns min buffer size (itemcount) on output port .
        """
        return _runtime_swig.top_block_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(top_block_sptr self, size_t min_output_buffer)
        set_min_output_buffer(top_block_sptr self, int port, size_t min_output_buffer)

        Sets min buffer size (itemcount) on all output ports.
        """
        return _runtime_swig.top_block_sptr_set_min_output_buffer(self, *args)

    def to_hier_block2(self):
        """to_hier_block2(top_block_sptr self) -> hier_block2_sptr"""
        return _runtime_swig.top_block_sptr_to_hier_block2(self)

    def name(self):
        """
        name(top_block_sptr self) -> std::string

        The name of the block
        """
        return _runtime_swig.top_block_sptr_name(self)

    def symbol_name(self):
        """
        symbol_name(top_block_sptr self) -> std::string

        The sybolic name of the block, which is used in the block_registry. The name is assigned by the block's constructor and never changes during the life of the block.
        """
        return _runtime_swig.top_block_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(top_block_sptr self) -> io_signature_sptr"""
        return _runtime_swig.top_block_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(top_block_sptr self) -> io_signature_sptr"""
        return _runtime_swig.top_block_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(top_block_sptr self) -> long"""
        return _runtime_swig.top_block_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(top_block_sptr self) -> basic_block_sptr"""
        return _runtime_swig.top_block_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """
        check_topology(top_block_sptr self, int ninputs, int noutputs) -> bool

        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr::io_signatures.
        """
        return _runtime_swig.top_block_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """
        alias(top_block_sptr self) -> std::string

        Returns the block's alias as a string.
        """
        return _runtime_swig.top_block_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """
        set_block_alias(top_block_sptr self, std::string name)

        Set's a new alias for the block; also adds an entry into the block_registry to get the block using either the alias or the original symbol name.
        """
        return _runtime_swig.top_block_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """
        _post(top_block_sptr self, swig_int_ptr which_port, swig_int_ptr msg)

        Accept msg, place in queue, arrange for thread to be awakened if it's not already.
        """
        return _runtime_swig.top_block_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """
        message_ports_in(top_block_sptr self) -> swig_int_ptr

        Get input message port names.

        Returns the available input message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.top_block_sptr_message_ports_in(self)

    def message_ports_out(self):
        """
        message_ports_out(top_block_sptr self) -> swig_int_ptr

        Get output message port names.

        Returns the available output message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.top_block_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(top_block_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _runtime_swig.top_block_sptr_message_subscribers(self, *args, **kwargs)

top_block_sptr_swigregister = _runtime_swig.top_block_sptr_swigregister
top_block_sptr_swigregister(top_block_sptr)


def top_block_swig(*args, **kwargs):
  """top_block_swig(std::string const name) -> top_block_sptr"""
  return _runtime_swig.top_block_swig(*args, **kwargs)
class top_block(hier_block2):
    """Top-level hierarchical block representing a flowgraph."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_top_block
    __del__ = lambda self : None;
    def start(self, max_noutput_items=100000000):
        """
        start(top_block self, int max_noutput_items=100000000)

        Start the contained flowgraph. Creates one or more threads to execute the flow graph. Returns to the caller once the threads are created. Calling start() on a top_block that is already started IS an error.
        """
        return _runtime_swig.top_block_start(self, max_noutput_items)

    def stop(self):
        """
        stop(top_block self)

        Stop the running flowgraph. Notifies each thread created by the scheduler to shutdown, then returns to caller. Calling stop() on a top_block that is already stopped IS NOT an error.
        """
        return _runtime_swig.top_block_stop(self)

    def lock(self):
        """
        lock(top_block self)

        Lock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.top_block_lock(self)

    def unlock(self):
        """
        unlock(top_block self)

        Unlock a flowgraph in preparation for reconfiguration. When an equal number of calls to lock() and unlock() have occurred, the flowgraph will be reconfigured.

        N.B. lock() and unlock() may not be called from a flowgraph thread (E.g., block::work method) or deadlock will occur when reconfiguration happens.
        """
        return _runtime_swig.top_block_unlock(self)

    def edge_list(self):
        """
        edge_list(top_block self) -> std::string

        Returns a string that lists the edge connections in the flattened flowgraph.
        """
        return _runtime_swig.top_block_edge_list(self)

    def msg_edge_list(self):
        """
        msg_edge_list(top_block self) -> std::string

        Returns a string that lists the msg edge connections in the flattened flowgraph.
        """
        return _runtime_swig.top_block_msg_edge_list(self)

    def dump(self):
        """
        dump(top_block self)

        Displays flattened flowgraph edges and block connectivity
        """
        return _runtime_swig.top_block_dump(self)

    def max_noutput_items(self):
        """
        max_noutput_items(top_block self) -> int

        Get the number of max noutput_items in the flowgraph.
        """
        return _runtime_swig.top_block_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """
        set_max_noutput_items(top_block self, int nmax)

        Set the maximum number of noutput_items in the flowgraph.
        """
        return _runtime_swig.top_block_set_max_noutput_items(self, *args, **kwargs)

    def to_top_block(self):
        """to_top_block(top_block self) -> top_block_sptr"""
        return _runtime_swig.top_block_to_top_block(self)

top_block_swigregister = _runtime_swig.top_block_swigregister
top_block_swigregister(top_block)


def top_block_run_unlocked(*args, **kwargs):
  """top_block_run_unlocked(top_block_sptr r)"""
  return _runtime_swig.top_block_run_unlocked(*args, **kwargs)

def top_block_start_unlocked(*args, **kwargs):
  """top_block_start_unlocked(top_block_sptr r, int max_noutput_items)"""
  return _runtime_swig.top_block_start_unlocked(*args, **kwargs)

def top_block_wait_unlocked(*args, **kwargs):
  """top_block_wait_unlocked(top_block_sptr r)"""
  return _runtime_swig.top_block_wait_unlocked(*args, **kwargs)

def top_block_stop_unlocked(*args, **kwargs):
  """top_block_stop_unlocked(top_block_sptr r)"""
  return _runtime_swig.top_block_stop_unlocked(*args, **kwargs)

def top_block_unlock_unlocked(*args, **kwargs):
  """top_block_unlock_unlocked(top_block_sptr r)"""
  return _runtime_swig.top_block_unlock_unlocked(*args, **kwargs)

def dot_graph_tb(*args, **kwargs):
  """dot_graph_tb(top_block_sptr r) -> std::string"""
  return _runtime_swig.dot_graph_tb(*args, **kwargs)
class void_start_vector_t(object):
    """Proxy of C++ std::vector<(p.void)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def iterator(self):
        """iterator(void_start_vector_t self) -> SwigPyIterator"""
        return _runtime_swig.void_start_vector_t_iterator(self)

    def __iter__(self): return self.iterator()
    def __nonzero__(self):
        """__nonzero__(void_start_vector_t self) -> bool"""
        return _runtime_swig.void_start_vector_t___nonzero__(self)

    def __bool__(self):
        """__bool__(void_start_vector_t self) -> bool"""
        return _runtime_swig.void_start_vector_t___bool__(self)

    def __len__(self):
        """__len__(void_start_vector_t self) -> std::vector< void * >::size_type"""
        return _runtime_swig.void_start_vector_t___len__(self)

    def pop(self):
        """pop(void_start_vector_t self) -> std::vector< void * >::value_type"""
        return _runtime_swig.void_start_vector_t_pop(self)

    def __getslice__(self, *args, **kwargs):
        """__getslice__(void_start_vector_t self, std::vector< void * >::difference_type i, std::vector< void * >::difference_type j) -> void_start_vector_t"""
        return _runtime_swig.void_start_vector_t___getslice__(self, *args, **kwargs)

    def __setslice__(self, *args, **kwargs):
        """
        __setslice__(void_start_vector_t self, std::vector< void * >::difference_type i, std::vector< void * >::difference_type j, 
            void_start_vector_t v=std::vector< void *,std::allocator< void * > >())
        """
        return _runtime_swig.void_start_vector_t___setslice__(self, *args, **kwargs)

    def __delslice__(self, *args, **kwargs):
        """__delslice__(void_start_vector_t self, std::vector< void * >::difference_type i, std::vector< void * >::difference_type j)"""
        return _runtime_swig.void_start_vector_t___delslice__(self, *args, **kwargs)

    def __delitem__(self, *args):
        """
        __delitem__(void_start_vector_t self, std::vector< void * >::difference_type i)
        __delitem__(void_start_vector_t self, PySliceObject * slice)
        """
        return _runtime_swig.void_start_vector_t___delitem__(self, *args)

    def __getitem__(self, *args):
        """
        __getitem__(void_start_vector_t self, PySliceObject * slice) -> void_start_vector_t
        __getitem__(void_start_vector_t self, std::vector< void * >::difference_type i) -> std::vector< void * >::value_type
        """
        return _runtime_swig.void_start_vector_t___getitem__(self, *args)

    def __setitem__(self, *args):
        """
        __setitem__(void_start_vector_t self, PySliceObject * slice, void_start_vector_t v)
        __setitem__(void_start_vector_t self, PySliceObject * slice)
        __setitem__(void_start_vector_t self, std::vector< void * >::difference_type i, std::vector< void * >::value_type x)
        """
        return _runtime_swig.void_start_vector_t___setitem__(self, *args)

    def append(self, *args, **kwargs):
        """append(void_start_vector_t self, std::vector< void * >::value_type x)"""
        return _runtime_swig.void_start_vector_t_append(self, *args, **kwargs)

    def empty(self):
        """empty(void_start_vector_t self) -> bool"""
        return _runtime_swig.void_start_vector_t_empty(self)

    def size(self):
        """size(void_start_vector_t self) -> std::vector< void * >::size_type"""
        return _runtime_swig.void_start_vector_t_size(self)

    def clear(self):
        """clear(void_start_vector_t self)"""
        return _runtime_swig.void_start_vector_t_clear(self)

    def swap(self, *args, **kwargs):
        """swap(void_start_vector_t self, void_start_vector_t v)"""
        return _runtime_swig.void_start_vector_t_swap(self, *args, **kwargs)

    def get_allocator(self):
        """get_allocator(void_start_vector_t self) -> std::vector< void * >::allocator_type"""
        return _runtime_swig.void_start_vector_t_get_allocator(self)

    def begin(self):
        """begin(void_start_vector_t self) -> std::vector< void * >::iterator"""
        return _runtime_swig.void_start_vector_t_begin(self)

    def end(self):
        """end(void_start_vector_t self) -> std::vector< void * >::iterator"""
        return _runtime_swig.void_start_vector_t_end(self)

    def rbegin(self):
        """rbegin(void_start_vector_t self) -> std::vector< void * >::reverse_iterator"""
        return _runtime_swig.void_start_vector_t_rbegin(self)

    def rend(self):
        """rend(void_start_vector_t self) -> std::vector< void * >::reverse_iterator"""
        return _runtime_swig.void_start_vector_t_rend(self)

    def pop_back(self):
        """pop_back(void_start_vector_t self)"""
        return _runtime_swig.void_start_vector_t_pop_back(self)

    def erase(self, *args):
        """
        erase(void_start_vector_t self, std::vector< void * >::iterator pos) -> std::vector< void * >::iterator
        erase(void_start_vector_t self, std::vector< void * >::iterator first, std::vector< void * >::iterator last) -> std::vector< void * >::iterator
        """
        return _runtime_swig.void_start_vector_t_erase(self, *args)

    def __init__(self, *args): 
        """
        __init__(std::vector<(p.void)> self) -> void_start_vector_t
        __init__(std::vector<(p.void)> self, void_start_vector_t arg2) -> void_start_vector_t
        __init__(std::vector<(p.void)> self, std::vector< void * >::size_type size) -> void_start_vector_t
        __init__(std::vector<(p.void)> self, std::vector< void * >::size_type size, std::vector< void * >::value_type value) -> void_start_vector_t
        """
        this = _runtime_swig.new_void_start_vector_t(*args)
        try: self.this.append(this)
        except: self.this = this
    def push_back(self, *args, **kwargs):
        """push_back(void_start_vector_t self, std::vector< void * >::value_type x)"""
        return _runtime_swig.void_start_vector_t_push_back(self, *args, **kwargs)

    def front(self):
        """front(void_start_vector_t self) -> std::vector< void * >::value_type"""
        return _runtime_swig.void_start_vector_t_front(self)

    def back(self):
        """back(void_start_vector_t self) -> std::vector< void * >::value_type"""
        return _runtime_swig.void_start_vector_t_back(self)

    def assign(self, *args, **kwargs):
        """assign(void_start_vector_t self, std::vector< void * >::size_type n, std::vector< void * >::value_type x)"""
        return _runtime_swig.void_start_vector_t_assign(self, *args, **kwargs)

    def resize(self, *args):
        """
        resize(void_start_vector_t self, std::vector< void * >::size_type new_size)
        resize(void_start_vector_t self, std::vector< void * >::size_type new_size, std::vector< void * >::value_type x)
        """
        return _runtime_swig.void_start_vector_t_resize(self, *args)

    def insert(self, *args):
        """
        insert(void_start_vector_t self, std::vector< void * >::iterator pos, std::vector< void * >::value_type x) -> std::vector< void * >::iterator
        insert(void_start_vector_t self, std::vector< void * >::iterator pos, std::vector< void * >::size_type n, std::vector< void * >::value_type x)
        """
        return _runtime_swig.void_start_vector_t_insert(self, *args)

    def reserve(self, *args, **kwargs):
        """reserve(void_start_vector_t self, std::vector< void * >::size_type n)"""
        return _runtime_swig.void_start_vector_t_reserve(self, *args, **kwargs)

    def capacity(self):
        """capacity(void_start_vector_t self) -> std::vector< void * >::size_type"""
        return _runtime_swig.void_start_vector_t_capacity(self)

    __swig_destroy__ = _runtime_swig.delete_void_start_vector_t
    __del__ = lambda self : None;
void_start_vector_t_swigregister = _runtime_swig.void_start_vector_t_swigregister
void_start_vector_t_swigregister(void_start_vector_t)

GR_BLOCK_GW_WORK_GENERAL = _runtime_swig.GR_BLOCK_GW_WORK_GENERAL
GR_BLOCK_GW_WORK_SYNC = _runtime_swig.GR_BLOCK_GW_WORK_SYNC
GR_BLOCK_GW_WORK_DECIM = _runtime_swig.GR_BLOCK_GW_WORK_DECIM
GR_BLOCK_GW_WORK_INTERP = _runtime_swig.GR_BLOCK_GW_WORK_INTERP
WORK_CALLED_PRODUCE = _runtime_swig.WORK_CALLED_PRODUCE
WORK_DONE = _runtime_swig.WORK_DONE
TPP_DONT = _runtime_swig.TPP_DONT
TPP_ALL_TO_ALL = _runtime_swig.TPP_ALL_TO_ALL
TPP_ONE_TO_ONE = _runtime_swig.TPP_ONE_TO_ONE
TPP_CUSTOM = _runtime_swig.TPP_CUSTOM
class block_gw_message_type(object):
    """Proxy of C++ gr::block_gw_message_type class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    ACTION_GENERAL_WORK = _runtime_swig.block_gw_message_type_ACTION_GENERAL_WORK
    ACTION_WORK = _runtime_swig.block_gw_message_type_ACTION_WORK
    ACTION_FORECAST = _runtime_swig.block_gw_message_type_ACTION_FORECAST
    ACTION_START = _runtime_swig.block_gw_message_type_ACTION_START
    ACTION_STOP = _runtime_swig.block_gw_message_type_ACTION_STOP
    action = _swig_property(_runtime_swig.block_gw_message_type_action_get, _runtime_swig.block_gw_message_type_action_set)
    general_work_args_noutput_items = _swig_property(_runtime_swig.block_gw_message_type_general_work_args_noutput_items_get, _runtime_swig.block_gw_message_type_general_work_args_noutput_items_set)
    general_work_args_ninput_items = _swig_property(_runtime_swig.block_gw_message_type_general_work_args_ninput_items_get, _runtime_swig.block_gw_message_type_general_work_args_ninput_items_set)
    general_work_args_input_items = _swig_property(_runtime_swig.block_gw_message_type_general_work_args_input_items_get, _runtime_swig.block_gw_message_type_general_work_args_input_items_set)
    general_work_args_output_items = _swig_property(_runtime_swig.block_gw_message_type_general_work_args_output_items_get, _runtime_swig.block_gw_message_type_general_work_args_output_items_set)
    general_work_args_return_value = _swig_property(_runtime_swig.block_gw_message_type_general_work_args_return_value_get, _runtime_swig.block_gw_message_type_general_work_args_return_value_set)
    work_args_ninput_items = _swig_property(_runtime_swig.block_gw_message_type_work_args_ninput_items_get, _runtime_swig.block_gw_message_type_work_args_ninput_items_set)
    work_args_noutput_items = _swig_property(_runtime_swig.block_gw_message_type_work_args_noutput_items_get, _runtime_swig.block_gw_message_type_work_args_noutput_items_set)
    work_args_input_items = _swig_property(_runtime_swig.block_gw_message_type_work_args_input_items_get, _runtime_swig.block_gw_message_type_work_args_input_items_set)
    work_args_output_items = _swig_property(_runtime_swig.block_gw_message_type_work_args_output_items_get, _runtime_swig.block_gw_message_type_work_args_output_items_set)
    work_args_return_value = _swig_property(_runtime_swig.block_gw_message_type_work_args_return_value_get, _runtime_swig.block_gw_message_type_work_args_return_value_set)
    forecast_args_noutput_items = _swig_property(_runtime_swig.block_gw_message_type_forecast_args_noutput_items_get, _runtime_swig.block_gw_message_type_forecast_args_noutput_items_set)
    forecast_args_ninput_items_required = _swig_property(_runtime_swig.block_gw_message_type_forecast_args_ninput_items_required_get, _runtime_swig.block_gw_message_type_forecast_args_ninput_items_required_set)
    start_args_return_value = _swig_property(_runtime_swig.block_gw_message_type_start_args_return_value_get, _runtime_swig.block_gw_message_type_start_args_return_value_set)
    stop_args_return_value = _swig_property(_runtime_swig.block_gw_message_type_stop_args_return_value_get, _runtime_swig.block_gw_message_type_stop_args_return_value_set)
    def __init__(self): 
        """__init__(gr::block_gw_message_type self) -> block_gw_message_type"""
        this = _runtime_swig.new_block_gw_message_type()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _runtime_swig.delete_block_gw_message_type
    __del__ = lambda self : None;
block_gw_message_type_swigregister = _runtime_swig.block_gw_message_type_swigregister
block_gw_message_type_swigregister(block_gw_message_type)

class block_gateway(block):
    """
    The gateway block which performs all the magic.

    The gateway provides access to all the gr::block routines. The methods prefixed with gr::block__ are renamed to class methods without the prefix in python.

    Constructor Specific Documentation:

    Make a new gateway block.

    Args:
        handler : the swig director object with callback
        name : the name of the block (Ex: "Shirley")
        in_sig : the input signature for this block
        out_sig : the output signature for this block
        work_type : the type of block overload to implement
        factor : the decimation or interpolation factor
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(gr::feval_ll * handler, std::string const & name, io_signature_sptr in_sig, io_signature_sptr out_sig, 
            gr::block_gw_work_type const work_type, unsigned int const factor) -> block_gateway_sptr

        The gateway block which performs all the magic.

        The gateway provides access to all the gr::block routines. The methods prefixed with gr::block__ are renamed to class methods without the prefix in python.

        Constructor Specific Documentation:

        Make a new gateway block.

        Args:
            handler : the swig director object with callback
            name : the name of the block (Ex: "Shirley")
            in_sig : the input signature for this block
            out_sig : the output signature for this block
            work_type : the type of block overload to implement
            factor : the decimation or interpolation factor
        """
        return _runtime_swig.block_gateway_make(*args, **kwargs)

    make = staticmethod(make)
    def block_message(self):
        """
        block_message(block_gateway self) -> block_gw_message_type

        Provide access to the shared message object.
        """
        return _runtime_swig.block_gateway_block_message(self)

    def block__unique_id(self):
        """block__unique_id(block_gateway self) -> long"""
        return _runtime_swig.block_gateway_block__unique_id(self)

    def block__name(self):
        """block__name(block_gateway self) -> std::string"""
        return _runtime_swig.block_gateway_block__name(self)

    def block__history(self):
        """block__history(block_gateway self) -> unsigned int"""
        return _runtime_swig.block_gateway_block__history(self)

    def block__set_history(self, *args, **kwargs):
        """block__set_history(block_gateway self, unsigned int history)"""
        return _runtime_swig.block_gateway_block__set_history(self, *args, **kwargs)

    def block__set_fixed_rate(self, *args, **kwargs):
        """block__set_fixed_rate(block_gateway self, bool fixed_rate)"""
        return _runtime_swig.block_gateway_block__set_fixed_rate(self, *args, **kwargs)

    def block__fixed_rate(self):
        """block__fixed_rate(block_gateway self) -> bool"""
        return _runtime_swig.block_gateway_block__fixed_rate(self)

    def block__set_output_multiple(self, *args, **kwargs):
        """block__set_output_multiple(block_gateway self, int multiple)"""
        return _runtime_swig.block_gateway_block__set_output_multiple(self, *args, **kwargs)

    def block__set_min_output_buffer(self, *args):
        """
        block__set_min_output_buffer(block_gateway self, int port, long size)
        block__set_min_output_buffer(block_gateway self, long size)
        """
        return _runtime_swig.block_gateway_block__set_min_output_buffer(self, *args)

    def block__output_multiple(self):
        """block__output_multiple(block_gateway self) -> int"""
        return _runtime_swig.block_gateway_block__output_multiple(self)

    def block__consume(self, *args, **kwargs):
        """block__consume(block_gateway self, int which_input, int how_many_items)"""
        return _runtime_swig.block_gateway_block__consume(self, *args, **kwargs)

    def block__consume_each(self, *args, **kwargs):
        """block__consume_each(block_gateway self, int how_many_items)"""
        return _runtime_swig.block_gateway_block__consume_each(self, *args, **kwargs)

    def block__produce(self, *args, **kwargs):
        """block__produce(block_gateway self, int which_output, int how_many_items)"""
        return _runtime_swig.block_gateway_block__produce(self, *args, **kwargs)

    def block__set_relative_rate(self, *args, **kwargs):
        """block__set_relative_rate(block_gateway self, double relative_rate)"""
        return _runtime_swig.block_gateway_block__set_relative_rate(self, *args, **kwargs)

    def block__relative_rate(self):
        """block__relative_rate(block_gateway self) -> double"""
        return _runtime_swig.block_gateway_block__relative_rate(self)

    def block__nitems_read(self, *args, **kwargs):
        """block__nitems_read(block_gateway self, unsigned int which_input) -> uint64_t"""
        return _runtime_swig.block_gateway_block__nitems_read(self, *args, **kwargs)

    def block__nitems_written(self, *args, **kwargs):
        """block__nitems_written(block_gateway self, unsigned int which_output) -> uint64_t"""
        return _runtime_swig.block_gateway_block__nitems_written(self, *args, **kwargs)

    def block__tag_propagation_policy(self):
        """block__tag_propagation_policy(block_gateway self) -> gr::block::tag_propagation_policy_t"""
        return _runtime_swig.block_gateway_block__tag_propagation_policy(self)

    def block__set_tag_propagation_policy(self, *args, **kwargs):
        """block__set_tag_propagation_policy(block_gateway self, gr::block::tag_propagation_policy_t p)"""
        return _runtime_swig.block_gateway_block__set_tag_propagation_policy(self, *args, **kwargs)

    def block__add_item_tag(self, *args):
        """
        block__add_item_tag(block_gateway self, unsigned int which_output, tag_t tag)
        block__add_item_tag(block_gateway self, unsigned int which_output, uint64_t abs_offset, swig_int_ptr key, swig_int_ptr value, 
            swig_int_ptr srcid=pmt::get_PMT_F())
        """
        return _runtime_swig.block_gateway_block__add_item_tag(self, *args)

    def block__get_tags_in_range(self, *args):
        """
        block__get_tags_in_range(block_gateway self, unsigned int which_input, uint64_t abs_start, uint64_t abs_end) -> tags_vector_t
        block__get_tags_in_range(block_gateway self, unsigned int which_input, uint64_t abs_start, uint64_t abs_end, swig_int_ptr key) -> tags_vector_t
        """
        return _runtime_swig.block_gateway_block__get_tags_in_range(self, *args)

    def block__get_tags_in_window(self, *args):
        """
        block__get_tags_in_window(block_gateway self, unsigned int which_input, uint64_t rel_start, uint64_t rel_end) -> tags_vector_t
        block__get_tags_in_window(block_gateway self, unsigned int which_input, uint64_t rel_start, uint64_t rel_end, swig_int_ptr key) -> tags_vector_t
        """
        return _runtime_swig.block_gateway_block__get_tags_in_window(self, *args)

    def block__message_port_register_in(self, *args, **kwargs):
        """block__message_port_register_in(block_gateway self, swig_int_ptr port_id)"""
        return _runtime_swig.block_gateway_block__message_port_register_in(self, *args, **kwargs)

    def block__message_port_register_out(self, *args, **kwargs):
        """block__message_port_register_out(block_gateway self, swig_int_ptr port_id)"""
        return _runtime_swig.block_gateway_block__message_port_register_out(self, *args, **kwargs)

    def block__message_port_pub(self, *args, **kwargs):
        """block__message_port_pub(block_gateway self, swig_int_ptr port_id, swig_int_ptr msg)"""
        return _runtime_swig.block_gateway_block__message_port_pub(self, *args, **kwargs)

    def block__message_port_sub(self, *args, **kwargs):
        """block__message_port_sub(block_gateway self, swig_int_ptr port_id, swig_int_ptr target)"""
        return _runtime_swig.block_gateway_block__message_port_sub(self, *args, **kwargs)

    def block__message_port_unsub(self, *args, **kwargs):
        """block__message_port_unsub(block_gateway self, swig_int_ptr port_id, swig_int_ptr target)"""
        return _runtime_swig.block_gateway_block__message_port_unsub(self, *args, **kwargs)

    def block__message_subscribers(self, *args, **kwargs):
        """block__message_subscribers(block_gateway self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _runtime_swig.block_gateway_block__message_subscribers(self, *args, **kwargs)

    def block__message_ports_in(self):
        """block__message_ports_in(block_gateway self) -> swig_int_ptr"""
        return _runtime_swig.block_gateway_block__message_ports_in(self)

    def block__message_ports_out(self):
        """block__message_ports_out(block_gateway self) -> swig_int_ptr"""
        return _runtime_swig.block_gateway_block__message_ports_out(self)

    def set_msg_handler_feval(self, *args, **kwargs):
        """set_msg_handler_feval(block_gateway self, swig_int_ptr which_port, gr::feval_p * msg_handler)"""
        return _runtime_swig.block_gateway_set_msg_handler_feval(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_block_gateway
    __del__ = lambda self : None;
block_gateway_swigregister = _runtime_swig.block_gateway_swigregister
block_gateway_swigregister(block_gateway)

def block_gateway_make(*args, **kwargs):
  """
    block_gateway_make(gr::feval_ll * handler, std::string const & name, io_signature_sptr in_sig, io_signature_sptr out_sig, 
        gr::block_gw_work_type const work_type, unsigned int const factor) -> block_gateway_sptr

    The gateway block which performs all the magic.

    The gateway provides access to all the gr::block routines. The methods prefixed with gr::block__ are renamed to class methods without the prefix in python.

    Constructor Specific Documentation:

    Make a new gateway block.

    Args:
        handler : the swig director object with callback
        name : the name of the block (Ex: "Shirley")
        in_sig : the input signature for this block
        out_sig : the output signature for this block
        work_type : the type of block overload to implement
        factor : the decimation or interpolation factor
    """
  return _runtime_swig.block_gateway_make(*args, **kwargs)

class block_gateway_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::block_gateway)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::block_gateway)> self) -> block_gateway_sptr
        __init__(boost::shared_ptr<(gr::block_gateway)> self, block_gateway p) -> block_gateway_sptr
        """
        this = _runtime_swig.new_block_gateway_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(block_gateway_sptr self) -> block_gateway"""
        return _runtime_swig.block_gateway_sptr___deref__(self)

    __swig_destroy__ = _runtime_swig.delete_block_gateway_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(block_gateway_sptr self, gr::feval_ll * handler, std::string const & name, io_signature_sptr in_sig, io_signature_sptr out_sig, 
            gr::block_gw_work_type const work_type, unsigned int const factor) -> block_gateway_sptr

        The gateway block which performs all the magic.

        The gateway provides access to all the gr::block routines. The methods prefixed with gr::block__ are renamed to class methods without the prefix in python.

        Constructor Specific Documentation:

        Make a new gateway block.

        Args:
            handler : the swig director object with callback
            name : the name of the block (Ex: "Shirley")
            in_sig : the input signature for this block
            out_sig : the output signature for this block
            work_type : the type of block overload to implement
            factor : the decimation or interpolation factor
        """
        return _runtime_swig.block_gateway_sptr_make(self, *args, **kwargs)

    def block_message(self):
        """
        block_message(block_gateway_sptr self) -> block_gw_message_type

        Provide access to the shared message object.
        """
        return _runtime_swig.block_gateway_sptr_block_message(self)

    def block__unique_id(self):
        """block__unique_id(block_gateway_sptr self) -> long"""
        return _runtime_swig.block_gateway_sptr_block__unique_id(self)

    def block__name(self):
        """block__name(block_gateway_sptr self) -> std::string"""
        return _runtime_swig.block_gateway_sptr_block__name(self)

    def block__history(self):
        """block__history(block_gateway_sptr self) -> unsigned int"""
        return _runtime_swig.block_gateway_sptr_block__history(self)

    def block__set_history(self, *args, **kwargs):
        """block__set_history(block_gateway_sptr self, unsigned int history)"""
        return _runtime_swig.block_gateway_sptr_block__set_history(self, *args, **kwargs)

    def block__set_fixed_rate(self, *args, **kwargs):
        """block__set_fixed_rate(block_gateway_sptr self, bool fixed_rate)"""
        return _runtime_swig.block_gateway_sptr_block__set_fixed_rate(self, *args, **kwargs)

    def block__fixed_rate(self):
        """block__fixed_rate(block_gateway_sptr self) -> bool"""
        return _runtime_swig.block_gateway_sptr_block__fixed_rate(self)

    def block__set_output_multiple(self, *args, **kwargs):
        """block__set_output_multiple(block_gateway_sptr self, int multiple)"""
        return _runtime_swig.block_gateway_sptr_block__set_output_multiple(self, *args, **kwargs)

    def block__set_min_output_buffer(self, *args):
        """
        block__set_min_output_buffer(block_gateway_sptr self, int port, long size)
        block__set_min_output_buffer(block_gateway_sptr self, long size)
        """
        return _runtime_swig.block_gateway_sptr_block__set_min_output_buffer(self, *args)

    def block__output_multiple(self):
        """block__output_multiple(block_gateway_sptr self) -> int"""
        return _runtime_swig.block_gateway_sptr_block__output_multiple(self)

    def block__consume(self, *args, **kwargs):
        """block__consume(block_gateway_sptr self, int which_input, int how_many_items)"""
        return _runtime_swig.block_gateway_sptr_block__consume(self, *args, **kwargs)

    def block__consume_each(self, *args, **kwargs):
        """block__consume_each(block_gateway_sptr self, int how_many_items)"""
        return _runtime_swig.block_gateway_sptr_block__consume_each(self, *args, **kwargs)

    def block__produce(self, *args, **kwargs):
        """block__produce(block_gateway_sptr self, int which_output, int how_many_items)"""
        return _runtime_swig.block_gateway_sptr_block__produce(self, *args, **kwargs)

    def block__set_relative_rate(self, *args, **kwargs):
        """block__set_relative_rate(block_gateway_sptr self, double relative_rate)"""
        return _runtime_swig.block_gateway_sptr_block__set_relative_rate(self, *args, **kwargs)

    def block__relative_rate(self):
        """block__relative_rate(block_gateway_sptr self) -> double"""
        return _runtime_swig.block_gateway_sptr_block__relative_rate(self)

    def block__nitems_read(self, *args, **kwargs):
        """block__nitems_read(block_gateway_sptr self, unsigned int which_input) -> uint64_t"""
        return _runtime_swig.block_gateway_sptr_block__nitems_read(self, *args, **kwargs)

    def block__nitems_written(self, *args, **kwargs):
        """block__nitems_written(block_gateway_sptr self, unsigned int which_output) -> uint64_t"""
        return _runtime_swig.block_gateway_sptr_block__nitems_written(self, *args, **kwargs)

    def block__tag_propagation_policy(self):
        """block__tag_propagation_policy(block_gateway_sptr self) -> gr::block::tag_propagation_policy_t"""
        return _runtime_swig.block_gateway_sptr_block__tag_propagation_policy(self)

    def block__set_tag_propagation_policy(self, *args, **kwargs):
        """block__set_tag_propagation_policy(block_gateway_sptr self, gr::block::tag_propagation_policy_t p)"""
        return _runtime_swig.block_gateway_sptr_block__set_tag_propagation_policy(self, *args, **kwargs)

    def block__add_item_tag(self, *args):
        """
        block__add_item_tag(block_gateway_sptr self, unsigned int which_output, tag_t tag)
        block__add_item_tag(block_gateway_sptr self, unsigned int which_output, uint64_t abs_offset, swig_int_ptr key, swig_int_ptr value, 
            swig_int_ptr srcid=pmt::get_PMT_F())
        """
        return _runtime_swig.block_gateway_sptr_block__add_item_tag(self, *args)

    def block__get_tags_in_range(self, *args):
        """
        block__get_tags_in_range(block_gateway_sptr self, unsigned int which_input, uint64_t abs_start, uint64_t abs_end) -> tags_vector_t
        block__get_tags_in_range(block_gateway_sptr self, unsigned int which_input, uint64_t abs_start, uint64_t abs_end, swig_int_ptr key) -> tags_vector_t
        """
        return _runtime_swig.block_gateway_sptr_block__get_tags_in_range(self, *args)

    def block__get_tags_in_window(self, *args):
        """
        block__get_tags_in_window(block_gateway_sptr self, unsigned int which_input, uint64_t rel_start, uint64_t rel_end) -> tags_vector_t
        block__get_tags_in_window(block_gateway_sptr self, unsigned int which_input, uint64_t rel_start, uint64_t rel_end, swig_int_ptr key) -> tags_vector_t
        """
        return _runtime_swig.block_gateway_sptr_block__get_tags_in_window(self, *args)

    def block__message_port_register_in(self, *args, **kwargs):
        """block__message_port_register_in(block_gateway_sptr self, swig_int_ptr port_id)"""
        return _runtime_swig.block_gateway_sptr_block__message_port_register_in(self, *args, **kwargs)

    def block__message_port_register_out(self, *args, **kwargs):
        """block__message_port_register_out(block_gateway_sptr self, swig_int_ptr port_id)"""
        return _runtime_swig.block_gateway_sptr_block__message_port_register_out(self, *args, **kwargs)

    def block__message_port_pub(self, *args, **kwargs):
        """block__message_port_pub(block_gateway_sptr self, swig_int_ptr port_id, swig_int_ptr msg)"""
        return _runtime_swig.block_gateway_sptr_block__message_port_pub(self, *args, **kwargs)

    def block__message_port_sub(self, *args, **kwargs):
        """block__message_port_sub(block_gateway_sptr self, swig_int_ptr port_id, swig_int_ptr target)"""
        return _runtime_swig.block_gateway_sptr_block__message_port_sub(self, *args, **kwargs)

    def block__message_port_unsub(self, *args, **kwargs):
        """block__message_port_unsub(block_gateway_sptr self, swig_int_ptr port_id, swig_int_ptr target)"""
        return _runtime_swig.block_gateway_sptr_block__message_port_unsub(self, *args, **kwargs)

    def block__message_subscribers(self, *args, **kwargs):
        """block__message_subscribers(block_gateway_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _runtime_swig.block_gateway_sptr_block__message_subscribers(self, *args, **kwargs)

    def block__message_ports_in(self):
        """block__message_ports_in(block_gateway_sptr self) -> swig_int_ptr"""
        return _runtime_swig.block_gateway_sptr_block__message_ports_in(self)

    def block__message_ports_out(self):
        """block__message_ports_out(block_gateway_sptr self) -> swig_int_ptr"""
        return _runtime_swig.block_gateway_sptr_block__message_ports_out(self)

    def set_msg_handler_feval(self, *args, **kwargs):
        """set_msg_handler_feval(block_gateway_sptr self, swig_int_ptr which_port, gr::feval_p * msg_handler)"""
        return _runtime_swig.block_gateway_sptr_set_msg_handler_feval(self, *args, **kwargs)

    def history(self):
        """
        history(block_gateway_sptr self) -> unsigned int

        Assume block computes y_i = f(x_i, x_i-1, x_i-2, x_i-3...) History is the number of x_i's that are examined to produce one y_i. This comes in handy for FIR filters, where we use history to ensure that our input contains the appropriate "history" for the filter. History should be equal to the number of filter taps. First history samples (when there are no previous samples) are initialized with zeroes.
        """
        return _runtime_swig.block_gateway_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(block_gateway_sptr self, int which, int delay)
        declare_sample_delay(block_gateway_sptr self, unsigned int delay)

        Declares the block's delay in samples. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.

        This does not actively set the delay; it just tells the scheduler what the delay is.

        This delay is mostly used to adjust the placement of the tags and is not currently used for any signal processing. When a tag is passed through a block with internal delay, its location should be moved based on the delay of the block. This interface allows us to tell the scheduler this value.
        """
        return _runtime_swig.block_gateway_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """
        sample_delay(block_gateway_sptr self, int which) -> unsigned int

        Gets the delay of the block. Since the delay of blocks like filters is derived from the taps and not the block itself, we cannot automatically calculate this value and so leave it as a user-defined property. It defaults to 0 is not set.
        """
        return _runtime_swig.block_gateway_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(block_gateway_sptr self) -> int"""
        return _runtime_swig.block_gateway_sptr_output_multiple(self)

    def relative_rate(self):
        """
        relative_rate(block_gateway_sptr self) -> double

        return the approximate output rate / input rate
        """
        return _runtime_swig.block_gateway_sptr_relative_rate(self)

    def start(self):
        """
        start(block_gateway_sptr self) -> bool

        Called to enable drivers, etc for i/o devices.

        This allows a block to enable an associated driver to begin transferring data just before we start to execute the scheduler. The end result is that this reduces latency in the pipeline when dealing with audio devices, usrps, etc.
        """
        return _runtime_swig.block_gateway_sptr_start(self)

    def stop(self):
        """
        stop(block_gateway_sptr self) -> bool

        Called to disable drivers, etc for i/o devices.
        """
        return _runtime_swig.block_gateway_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """
        nitems_read(block_gateway_sptr self, unsigned int which_input) -> uint64_t

        Return the number of items read on input stream which_input.
        """
        return _runtime_swig.block_gateway_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """
        nitems_written(block_gateway_sptr self, unsigned int which_output) -> uint64_t

        Return the number of items written on output stream which_output.
        """
        return _runtime_swig.block_gateway_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """
        max_noutput_items(block_gateway_sptr self) -> int

        Return the maximum number of output items this block will handle during a call to work.
        """
        return _runtime_swig.block_gateway_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """
        set_max_noutput_items(block_gateway_sptr self, int m)

        Set the maximum number of output items this block will handle during a call to work.
        """
        return _runtime_swig.block_gateway_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """
        unset_max_noutput_items(block_gateway_sptr self)

        Clear the switch for using the max_noutput_items value of this block.

        When is_set_max_noutput_items() returns 'true', the scheduler will use the value returned by max_noutput_items() to limit the size of the number of items possible for this block's work function. If is_set_max_notput_items() returns 'false', then the scheduler ignores the internal value and uses the value set globally in the top_block.

        Use this value to clear the 'is_set' flag so the scheduler will ignore this. Use the set_max_noutput_items(m) call to both set a new value for max_noutput_items and to re-enable its use in the scheduler.
        """
        return _runtime_swig.block_gateway_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """
        is_set_max_noutput_items(block_gateway_sptr self) -> bool

        Ask the block if the flag is or is not set to use the internal value of max_noutput_items during a call to work.
        """
        return _runtime_swig.block_gateway_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """
        set_min_noutput_items(block_gateway_sptr self, int m)

        Set the minimum number of output items this block can produce during a call to work.
        """
        return _runtime_swig.block_gateway_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """
        min_noutput_items(block_gateway_sptr self) -> int

        Return the minimum number of output items this block can produce during a call to work.

        Should be 0 for most blocks. Useful if we're dealing with packets and the block produces one packet per call to work.
        """
        return _runtime_swig.block_gateway_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """
        max_output_buffer(block_gateway_sptr self, int i) -> long

        Returns max buffer size on output port .
        """
        return _runtime_swig.block_gateway_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(block_gateway_sptr self, long max_output_buffer)
        set_max_output_buffer(block_gateway_sptr self, int port, long max_output_buffer)

        Request limit on max buffer size on all output ports.

        This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.

        The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested maximum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.
        """
        return _runtime_swig.block_gateway_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """
        min_output_buffer(block_gateway_sptr self, int i) -> long

        Returns min buffer size on output port .
        """
        return _runtime_swig.block_gateway_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(block_gateway_sptr self, long min_output_buffer)
        set_min_output_buffer(block_gateway_sptr self, int port, long min_output_buffer)

        Request limit on the minimum buffer size on all output ports.

        This is an advanced feature. Calling this can affect some fundamental assumptions about the system behavior and performance.

        The actual buffer size is determined by a number of other factors from the block and system. This function only provides a requested minimum. The buffers will always be a multiple of the system page size, which may be larger than the value asked for here.
        """
        return _runtime_swig.block_gateway_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """
        pc_noutput_items(block_gateway_sptr self) -> float

        Gets instantaneous noutput_items performance counter.
        """
        return _runtime_swig.block_gateway_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """
        pc_noutput_items_avg(block_gateway_sptr self) -> float

        Gets average noutput_items performance counter.
        """
        return _runtime_swig.block_gateway_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """
        pc_noutput_items_var(block_gateway_sptr self) -> float

        Gets variance of noutput_items performance counter.
        """
        return _runtime_swig.block_gateway_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """
        pc_nproduced(block_gateway_sptr self) -> float

        Gets instantaneous num items produced performance counter.
        """
        return _runtime_swig.block_gateway_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """
        pc_nproduced_avg(block_gateway_sptr self) -> float

        Gets average num items produced performance counter.
        """
        return _runtime_swig.block_gateway_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """
        pc_nproduced_var(block_gateway_sptr self) -> float

        Gets variance of num items produced performance counter.
        """
        return _runtime_swig.block_gateway_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(block_gateway_sptr self, int which) -> float
        pc_input_buffers_full(block_gateway_sptr self) -> std::vector< float,std::allocator< float > >

        Gets instantaneous fullness of  input buffer.
        """
        return _runtime_swig.block_gateway_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(block_gateway_sptr self, int which) -> float
        pc_input_buffers_full_avg(block_gateway_sptr self) -> std::vector< float,std::allocator< float > >

        Gets average fullness of  input buffer.
        """
        return _runtime_swig.block_gateway_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(block_gateway_sptr self, int which) -> float
        pc_input_buffers_full_var(block_gateway_sptr self) -> std::vector< float,std::allocator< float > >

        Gets variance of fullness of  input buffer.
        """
        return _runtime_swig.block_gateway_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(block_gateway_sptr self, int which) -> float
        pc_output_buffers_full(block_gateway_sptr self) -> std::vector< float,std::allocator< float > >

        Gets instantaneous fullness of  input buffer.
        """
        return _runtime_swig.block_gateway_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(block_gateway_sptr self, int which) -> float
        pc_output_buffers_full_avg(block_gateway_sptr self) -> std::vector< float,std::allocator< float > >

        Gets average fullness of  input buffer.
        """
        return _runtime_swig.block_gateway_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(block_gateway_sptr self, int which) -> float
        pc_output_buffers_full_var(block_gateway_sptr self) -> std::vector< float,std::allocator< float > >

        Gets variance of fullness of  input buffer.
        """
        return _runtime_swig.block_gateway_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """
        pc_work_time(block_gateway_sptr self) -> float

        Gets instantaneous clock cycles spent in work.
        """
        return _runtime_swig.block_gateway_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """
        pc_work_time_avg(block_gateway_sptr self) -> float

        Gets average clock cycles spent in work.
        """
        return _runtime_swig.block_gateway_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """
        pc_work_time_var(block_gateway_sptr self) -> float

        Gets average clock cycles spent in work.
        """
        return _runtime_swig.block_gateway_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """
        pc_work_time_total(block_gateway_sptr self) -> float

        Gets total clock cycles spent in work.
        """
        return _runtime_swig.block_gateway_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """
        pc_throughput_avg(block_gateway_sptr self) -> float

        Gets average throughput.
        """
        return _runtime_swig.block_gateway_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """
        set_processor_affinity(block_gateway_sptr self, std::vector< int,std::allocator< int > > const & mask)

        Set the thread's affinity to processor core .
        """
        return _runtime_swig.block_gateway_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """
        unset_processor_affinity(block_gateway_sptr self)

        Remove processor affinity to a specific core.
        """
        return _runtime_swig.block_gateway_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """
        processor_affinity(block_gateway_sptr self) -> std::vector< int,std::allocator< int > >

        Get the current processor affinity.
        """
        return _runtime_swig.block_gateway_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """
        active_thread_priority(block_gateway_sptr self) -> int

        Get the current thread priority in use.
        """
        return _runtime_swig.block_gateway_sptr_active_thread_priority(self)

    def thread_priority(self):
        """
        thread_priority(block_gateway_sptr self) -> int

        Get the current thread priority stored.
        """
        return _runtime_swig.block_gateway_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """
        set_thread_priority(block_gateway_sptr self, int priority) -> int

        Set the current thread priority.
        """
        return _runtime_swig.block_gateway_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """
        name(block_gateway_sptr self) -> std::string

        The name of the block
        """
        return _runtime_swig.block_gateway_sptr_name(self)

    def symbol_name(self):
        """
        symbol_name(block_gateway_sptr self) -> std::string

        The sybolic name of the block, which is used in the block_registry. The name is assigned by the block's constructor and never changes during the life of the block.
        """
        return _runtime_swig.block_gateway_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(block_gateway_sptr self) -> io_signature_sptr"""
        return _runtime_swig.block_gateway_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(block_gateway_sptr self) -> io_signature_sptr"""
        return _runtime_swig.block_gateway_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(block_gateway_sptr self) -> long"""
        return _runtime_swig.block_gateway_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(block_gateway_sptr self) -> basic_block_sptr"""
        return _runtime_swig.block_gateway_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """
        check_topology(block_gateway_sptr self, int ninputs, int noutputs) -> bool

        Confirm that ninputs and noutputs is an acceptable combination.

        This function is called by the runtime system whenever the topology changes. Most classes do not need to override this. This check is in addition to the constraints specified by the input and output gr::io_signatures.
        """
        return _runtime_swig.block_gateway_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """
        alias(block_gateway_sptr self) -> std::string

        Returns the block's alias as a string.
        """
        return _runtime_swig.block_gateway_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """
        set_block_alias(block_gateway_sptr self, std::string name)

        Set's a new alias for the block; also adds an entry into the block_registry to get the block using either the alias or the original symbol name.
        """
        return _runtime_swig.block_gateway_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """
        _post(block_gateway_sptr self, swig_int_ptr which_port, swig_int_ptr msg)

        Accept msg, place in queue, arrange for thread to be awakened if it's not already.
        """
        return _runtime_swig.block_gateway_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """
        message_ports_in(block_gateway_sptr self) -> swig_int_ptr

        Get input message port names.

        Returns the available input message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.block_gateway_sptr_message_ports_in(self)

    def message_ports_out(self):
        """
        message_ports_out(block_gateway_sptr self) -> swig_int_ptr

        Get output message port names.

        Returns the available output message ports for a block. The return object is a PMT vector that is filled with PMT symbols.
        """
        return _runtime_swig.block_gateway_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(block_gateway_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _runtime_swig.block_gateway_sptr_message_subscribers(self, *args, **kwargs)

block_gateway_sptr_swigregister = _runtime_swig.block_gateway_sptr_swigregister
block_gateway_sptr_swigregister(block_gateway_sptr)

block_gateway_sptr.__repr__ = lambda self: "<block_gateway>"
block_gateway = block_gateway.make;


def logger_config(*args, **kwargs):
  """logger_config(std::string const config_filename, unsigned int watch_period=0)"""
  return _runtime_swig.logger_config(*args, **kwargs)

def logger_get_names():
  """logger_get_names() -> std::vector< std::string,std::allocator< std::string > >"""
  return _runtime_swig.logger_get_names()

def logger_reset_config():
  """logger_reset_config()"""
  return _runtime_swig.logger_reset_config()
class logger(object):
    """Proxy of C++ gr::logger class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """__init__(gr::logger self, std::string logger_name) -> logger"""
        this = _runtime_swig.new_logger(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def set_level(self, *args, **kwargs):
        """set_level(logger self, std::string level)"""
        return _runtime_swig.logger_set_level(self, *args, **kwargs)

    def get_level(self, *args, **kwargs):
        """get_level(logger self, std::string & level)"""
        return _runtime_swig.logger_get_level(self, *args, **kwargs)

    def debug(self, *args, **kwargs):
        """debug(logger self, std::string msg)"""
        return _runtime_swig.logger_debug(self, *args, **kwargs)

    def info(self, *args, **kwargs):
        """info(logger self, std::string msg)"""
        return _runtime_swig.logger_info(self, *args, **kwargs)

    def notice(self, *args, **kwargs):
        """notice(logger self, std::string msg)"""
        return _runtime_swig.logger_notice(self, *args, **kwargs)

    def warn(self, *args, **kwargs):
        """warn(logger self, std::string msg)"""
        return _runtime_swig.logger_warn(self, *args, **kwargs)

    def error(self, *args, **kwargs):
        """error(logger self, std::string msg)"""
        return _runtime_swig.logger_error(self, *args, **kwargs)

    def crit(self, *args, **kwargs):
        """crit(logger self, std::string msg)"""
        return _runtime_swig.logger_crit(self, *args, **kwargs)

    def alert(self, *args, **kwargs):
        """alert(logger self, std::string msg)"""
        return _runtime_swig.logger_alert(self, *args, **kwargs)

    def fatal(self, *args, **kwargs):
        """fatal(logger self, std::string msg)"""
        return _runtime_swig.logger_fatal(self, *args, **kwargs)

    def emerg(self, *args, **kwargs):
        """emerg(logger self, std::string msg)"""
        return _runtime_swig.logger_emerg(self, *args, **kwargs)

    def errorIF(self, *args, **kwargs):
        """errorIF(logger self, bool cond, std::string msg)"""
        return _runtime_swig.logger_errorIF(self, *args, **kwargs)

    def log_assert(self, *args, **kwargs):
        """log_assert(logger self, bool cond, std::string msg)"""
        return _runtime_swig.logger_log_assert(self, *args, **kwargs)

    def add_console_appender(self, *args, **kwargs):
        """add_console_appender(logger self, std::string target, std::string pattern)"""
        return _runtime_swig.logger_add_console_appender(self, *args, **kwargs)

    def add_file_appender(self, *args, **kwargs):
        """add_file_appender(logger self, std::string filename, bool append, std::string pattern)"""
        return _runtime_swig.logger_add_file_appender(self, *args, **kwargs)

    def add_rollingfile_appender(self, *args, **kwargs):
        """
        add_rollingfile_appender(logger self, std::string filename, size_t filesize, int bkup_index, bool append, mode_t mode, 
            std::string pattern)
        """
        return _runtime_swig.logger_add_rollingfile_appender(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_logger
    __del__ = lambda self : None;
logger_swigregister = _runtime_swig.logger_swigregister
logger_swigregister(logger)

RPC_PRIVLVL_ALL = _runtime_swig.RPC_PRIVLVL_ALL
RPC_PRIVLVL_MIN = _runtime_swig.RPC_PRIVLVL_MIN
RPC_PRIVLVL_NONE = _runtime_swig.RPC_PRIVLVL_NONE
KNOBBOOL = _runtime_swig.KNOBBOOL
KNOBCHAR = _runtime_swig.KNOBCHAR
KNOBINT = _runtime_swig.KNOBINT
KNOBFLOAT = _runtime_swig.KNOBFLOAT
KNOBDOUBLE = _runtime_swig.KNOBDOUBLE
KNOBSTRING = _runtime_swig.KNOBSTRING
KNOBLONG = _runtime_swig.KNOBLONG
KNOBVECBOOL = _runtime_swig.KNOBVECBOOL
KNOBCOMPLEX = _runtime_swig.KNOBCOMPLEX
KNOBCOMPLEXD = _runtime_swig.KNOBCOMPLEXD
KNOBVECCHAR = _runtime_swig.KNOBVECCHAR
KNOBVECINT = _runtime_swig.KNOBVECINT
KNOBVECFLOAT = _runtime_swig.KNOBVECFLOAT
KNOBVECDOUBLE = _runtime_swig.KNOBVECDOUBLE
KNOBVECSTRING = _runtime_swig.KNOBVECSTRING
KNOBVECLONG = _runtime_swig.KNOBVECLONG
class rpcserver_booter_base(object):
    """Proxy of C++ rpcserver_booter_base class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _runtime_swig.delete_rpcserver_booter_base
    __del__ = lambda self : None;
    def i(self):
        """i(rpcserver_booter_base self) -> rpcserver_base *"""
        return _runtime_swig.rpcserver_booter_base_i(self)

    def endpoints(self):
        """endpoints(rpcserver_booter_base self) -> std::vector< std::string,std::allocator< std::string > > const"""
        return _runtime_swig.rpcserver_booter_base_endpoints(self)

    def type(self):
        """type(rpcserver_booter_base self) -> std::string const &"""
        return _runtime_swig.rpcserver_booter_base_type(self)

rpcserver_booter_base_swigregister = _runtime_swig.rpcserver_booter_base_swigregister
rpcserver_booter_base_swigregister(rpcserver_booter_base)
cvar = _runtime_swig.cvar
DISPNULL = cvar.DISPNULL
DISPTIME = cvar.DISPTIME
DISPXY = cvar.DISPXY
DISPPSD = cvar.DISPPSD
DISPSPEC = cvar.DISPSPEC
DISPRAST = cvar.DISPRAST
DISPOPTCPLX = cvar.DISPOPTCPLX
DISPOPTLOG = cvar.DISPOPTLOG
DISPOPTSTEM = cvar.DISPOPTSTEM
DISPOPTSTRIP = cvar.DISPOPTSTRIP
DISPOPTSCATTER = cvar.DISPOPTSCATTER

class rpcserver_booter_aggregator(rpcserver_booter_base):
    """Proxy of C++ rpcserver_booter_aggregator class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(rpcserver_booter_aggregator self) -> rpcserver_booter_aggregator"""
        this = _runtime_swig.new_rpcserver_booter_aggregator()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _runtime_swig.delete_rpcserver_booter_aggregator
    __del__ = lambda self : None;
    def registeredServers(self):
        """registeredServers(rpcserver_booter_aggregator self) -> std::vector< std::string,std::allocator< std::string > > const &"""
        return _runtime_swig.rpcserver_booter_aggregator_registeredServers(self)

rpcserver_booter_aggregator_swigregister = _runtime_swig.rpcserver_booter_aggregator_swigregister
rpcserver_booter_aggregator_swigregister(rpcserver_booter_aggregator)

PYPORT_STRING = _runtime_swig.PYPORT_STRING
PYPORT_FLOAT = _runtime_swig.PYPORT_FLOAT
class rpcmanager(object):
    """Proxy of C++ rpcmanager class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self): 
        """__init__(rpcmanager self) -> rpcmanager"""
        this = _runtime_swig.new_rpcmanager()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _runtime_swig.delete_rpcmanager
    __del__ = lambda self : None;
    def get():
        """get() -> rpcserver_booter_base"""
        return _runtime_swig.rpcmanager_get()

    get = staticmethod(get)
    def register_booter(*args, **kwargs):
        """register_booter(rpcserver_booter_base booter)"""
        return _runtime_swig.rpcmanager_register_booter(*args, **kwargs)

    register_booter = staticmethod(register_booter)
rpcmanager_swigregister = _runtime_swig.rpcmanager_swigregister
rpcmanager_swigregister(rpcmanager)

def rpcmanager_get():
  """rpcmanager_get() -> rpcserver_booter_base"""
  return _runtime_swig.rpcmanager_get()

def rpcmanager_register_booter(*args, **kwargs):
  """rpcmanager_register_booter(rpcserver_booter_base booter)"""
  return _runtime_swig.rpcmanager_register_booter(*args, **kwargs)

class RPC_get_string(object):
    """Proxy of C++ pycallback_object<(std::string)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(pycallback_object<(std::string)> self, std::string name, std::string functionbase, std::string units, std::string desc, 
            std::string min, std::string max, std::string deflt, DisplayType dtype) -> RPC_get_string
        """
        this = _runtime_swig.new_RPC_get_string(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def add_rpc_variable(self, *args, **kwargs):
        """add_rpc_variable(RPC_get_string self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_string_add_rpc_variable(self, *args, **kwargs)

    def get(self):
        """get(RPC_get_string self) -> std::string"""
        return _runtime_swig.RPC_get_string_get(self)

    def set_callback(self, *args, **kwargs):
        """set_callback(RPC_get_string self, PyObject * cb)"""
        return _runtime_swig.RPC_get_string_set_callback(self, *args, **kwargs)

    def setup_rpc(self):
        """setup_rpc(RPC_get_string self)"""
        return _runtime_swig.RPC_get_string_setup_rpc(self)

    def activate(self, *args, **kwargs):
        """activate(RPC_get_string self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_string_activate(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_RPC_get_string
    __del__ = lambda self : None;
RPC_get_string_swigregister = _runtime_swig.RPC_get_string_swigregister
RPC_get_string_swigregister(RPC_get_string)

class RPC_get_int(object):
    """Proxy of C++ pycallback_object<(int)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(pycallback_object<(int)> self, std::string name, std::string functionbase, std::string units, std::string desc, 
            int min, int max, int deflt, DisplayType dtype) -> RPC_get_int
        """
        this = _runtime_swig.new_RPC_get_int(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def add_rpc_variable(self, *args, **kwargs):
        """add_rpc_variable(RPC_get_int self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_int_add_rpc_variable(self, *args, **kwargs)

    def get(self):
        """get(RPC_get_int self) -> int"""
        return _runtime_swig.RPC_get_int_get(self)

    def set_callback(self, *args, **kwargs):
        """set_callback(RPC_get_int self, PyObject * cb)"""
        return _runtime_swig.RPC_get_int_set_callback(self, *args, **kwargs)

    def setup_rpc(self):
        """setup_rpc(RPC_get_int self)"""
        return _runtime_swig.RPC_get_int_setup_rpc(self)

    def activate(self, *args, **kwargs):
        """activate(RPC_get_int self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_int_activate(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_RPC_get_int
    __del__ = lambda self : None;
RPC_get_int_swigregister = _runtime_swig.RPC_get_int_swigregister
RPC_get_int_swigregister(RPC_get_int)

class RPC_get_float(object):
    """Proxy of C++ pycallback_object<(float)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(pycallback_object<(float)> self, std::string name, std::string functionbase, std::string units, std::string desc, 
            float min, float max, float deflt, DisplayType dtype) -> RPC_get_float
        """
        this = _runtime_swig.new_RPC_get_float(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def add_rpc_variable(self, *args, **kwargs):
        """add_rpc_variable(RPC_get_float self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_float_add_rpc_variable(self, *args, **kwargs)

    def get(self):
        """get(RPC_get_float self) -> float"""
        return _runtime_swig.RPC_get_float_get(self)

    def set_callback(self, *args, **kwargs):
        """set_callback(RPC_get_float self, PyObject * cb)"""
        return _runtime_swig.RPC_get_float_set_callback(self, *args, **kwargs)

    def setup_rpc(self):
        """setup_rpc(RPC_get_float self)"""
        return _runtime_swig.RPC_get_float_setup_rpc(self)

    def activate(self, *args, **kwargs):
        """activate(RPC_get_float self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_float_activate(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_RPC_get_float
    __del__ = lambda self : None;
RPC_get_float_swigregister = _runtime_swig.RPC_get_float_swigregister
RPC_get_float_swigregister(RPC_get_float)

class RPC_get_double(object):
    """Proxy of C++ pycallback_object<(double)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(pycallback_object<(double)> self, std::string name, std::string functionbase, std::string units, std::string desc, 
            double min, double max, double deflt, DisplayType dtype) -> RPC_get_double
        """
        this = _runtime_swig.new_RPC_get_double(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def add_rpc_variable(self, *args, **kwargs):
        """add_rpc_variable(RPC_get_double self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_double_add_rpc_variable(self, *args, **kwargs)

    def get(self):
        """get(RPC_get_double self) -> double"""
        return _runtime_swig.RPC_get_double_get(self)

    def set_callback(self, *args, **kwargs):
        """set_callback(RPC_get_double self, PyObject * cb)"""
        return _runtime_swig.RPC_get_double_set_callback(self, *args, **kwargs)

    def setup_rpc(self):
        """setup_rpc(RPC_get_double self)"""
        return _runtime_swig.RPC_get_double_setup_rpc(self)

    def activate(self, *args, **kwargs):
        """activate(RPC_get_double self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_double_activate(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_RPC_get_double
    __del__ = lambda self : None;
RPC_get_double_swigregister = _runtime_swig.RPC_get_double_swigregister
RPC_get_double_swigregister(RPC_get_double)

class RPC_get_complex(object):
    """Proxy of C++ pycallback_object<(gr_complex)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(pycallback_object<(gr_complex)> self, std::string name, std::string functionbase, std::string units, std::string desc, 
            std::complex< float > min, std::complex< float > max, std::complex< float > deflt, 
            DisplayType dtype) -> RPC_get_complex
        """
        this = _runtime_swig.new_RPC_get_complex(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def add_rpc_variable(self, *args, **kwargs):
        """add_rpc_variable(RPC_get_complex self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_complex_add_rpc_variable(self, *args, **kwargs)

    def get(self):
        """get(RPC_get_complex self) -> std::complex< float >"""
        return _runtime_swig.RPC_get_complex_get(self)

    def set_callback(self, *args, **kwargs):
        """set_callback(RPC_get_complex self, PyObject * cb)"""
        return _runtime_swig.RPC_get_complex_set_callback(self, *args, **kwargs)

    def setup_rpc(self):
        """setup_rpc(RPC_get_complex self)"""
        return _runtime_swig.RPC_get_complex_setup_rpc(self)

    def activate(self, *args, **kwargs):
        """activate(RPC_get_complex self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_complex_activate(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_RPC_get_complex
    __del__ = lambda self : None;
RPC_get_complex_swigregister = _runtime_swig.RPC_get_complex_swigregister
RPC_get_complex_swigregister(RPC_get_complex)

class RPC_get_complexd(object):
    """Proxy of C++ pycallback_object<(gr_complexd)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(pycallback_object<(gr_complexd)> self, std::string name, std::string functionbase, std::string units, std::string desc, 
            std::complex< double > min, std::complex< double > max, std::complex< double > deflt, 
            DisplayType dtype) -> RPC_get_complexd
        """
        this = _runtime_swig.new_RPC_get_complexd(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def add_rpc_variable(self, *args, **kwargs):
        """add_rpc_variable(RPC_get_complexd self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_complexd_add_rpc_variable(self, *args, **kwargs)

    def get(self):
        """get(RPC_get_complexd self) -> std::complex< double >"""
        return _runtime_swig.RPC_get_complexd_get(self)

    def set_callback(self, *args, **kwargs):
        """set_callback(RPC_get_complexd self, PyObject * cb)"""
        return _runtime_swig.RPC_get_complexd_set_callback(self, *args, **kwargs)

    def setup_rpc(self):
        """setup_rpc(RPC_get_complexd self)"""
        return _runtime_swig.RPC_get_complexd_setup_rpc(self)

    def activate(self, *args, **kwargs):
        """activate(RPC_get_complexd self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_complexd_activate(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_RPC_get_complexd
    __del__ = lambda self : None;
RPC_get_complexd_swigregister = _runtime_swig.RPC_get_complexd_swigregister
RPC_get_complexd_swigregister(RPC_get_complexd)

class RPC_get_vector_float(object):
    """Proxy of C++ pycallback_object<(std::vector<(float)>)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(pycallback_object<(std::vector<(float)>)> self, std::string name, std::string functionbase, std::string units, std::string desc, 
            std::vector< float,std::allocator< float > > min, std::vector< float,std::allocator< float > > max, 
            std::vector< float,std::allocator< float > > deflt, 
            DisplayType dtype) -> RPC_get_vector_float
        """
        this = _runtime_swig.new_RPC_get_vector_float(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def add_rpc_variable(self, *args, **kwargs):
        """add_rpc_variable(RPC_get_vector_float self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_vector_float_add_rpc_variable(self, *args, **kwargs)

    def get(self):
        """get(RPC_get_vector_float self) -> std::vector< float,std::allocator< float > >"""
        return _runtime_swig.RPC_get_vector_float_get(self)

    def set_callback(self, *args, **kwargs):
        """set_callback(RPC_get_vector_float self, PyObject * cb)"""
        return _runtime_swig.RPC_get_vector_float_set_callback(self, *args, **kwargs)

    def setup_rpc(self):
        """setup_rpc(RPC_get_vector_float self)"""
        return _runtime_swig.RPC_get_vector_float_setup_rpc(self)

    def activate(self, *args, **kwargs):
        """activate(RPC_get_vector_float self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_vector_float_activate(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_RPC_get_vector_float
    __del__ = lambda self : None;
RPC_get_vector_float_swigregister = _runtime_swig.RPC_get_vector_float_swigregister
RPC_get_vector_float_swigregister(RPC_get_vector_float)

class RPC_get_vector_gr_complex(object):
    """Proxy of C++ pycallback_object<(std::vector<(gr_complex)>)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(pycallback_object<(std::vector<(gr_complex)>)> self, std::string name, std::string functionbase, std::string units, std::string desc, 
            std::vector< std::complex< float >,std::allocator< std::complex< float > > > min, 
            std::vector< std::complex< float >,std::allocator< std::complex< float > > > max, 
            std::vector< std::complex< float >,std::allocator< std::complex< float > > > deflt, 
            DisplayType dtype) -> RPC_get_vector_gr_complex
        """
        this = _runtime_swig.new_RPC_get_vector_gr_complex(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    def add_rpc_variable(self, *args, **kwargs):
        """add_rpc_variable(RPC_get_vector_gr_complex self, rpcbasic_sptr s)"""
        return _runtime_swig.RPC_get_vector_gr_complex_add_rpc_variable(self, *args, **kwargs)

    def get(self):
        """get(RPC_get_vector_gr_complex self) -> std::vector< std::complex< float >,std::allocator< std::complex< float > > >"""
        return _runtime_swig.RPC_get_vector_gr_complex_get(self)

    def set_callback(self, *args, **kwargs):
        """set_callback(RPC_get_vector_gr_complex self, PyObject * cb)"""
        return _runtime_swig.RPC_get_vector_gr_complex_set_callback(self, *args, **kwargs)

    def setup_rpc(self):
        """setup_rpc(RPC_get_vector_gr_complex self)"""
        return _runtime_swig.RPC_get_vector_gr_complex_setup_rpc(self)

    def activate(self, *args, **kwargs):
        """activate(RPC_get_vector_gr_complex self, PyObject * pyfunc)"""
        return _runtime_swig.RPC_get_vector_gr_complex_activate(self, *args, **kwargs)

    __swig_destroy__ = _runtime_swig.delete_RPC_get_vector_gr_complex
    __del__ = lambda self : None;
RPC_get_vector_gr_complex_swigregister = _runtime_swig.RPC_get_vector_gr_complex_swigregister
RPC_get_vector_gr_complex_swigregister(RPC_get_vector_gr_complex)


def is_power_of_2(*args, **kwargs):
  """is_power_of_2(long x) -> bool"""
  return _runtime_swig.is_power_of_2(*args, **kwargs)

def fast_atan2f(*args):
  """
    fast_atan2f(float y, float x) -> float
    fast_atan2f(gr_complex z) -> float

    Fast arc tangent using table lookup and linear interpolation.

    This function calculates the angle of the vector (x,y) based on a table lookup and linear interpolation. The table uses a 256 point table covering -45 to +45 degrees and uses symmetry to determine the final angle value in the range of -180 to 180 degrees. Note that this function uses the small angle approximation for values close to zero. This routine calculates the arc tangent with an average error of +/- 0.045 degrees.
    """
  return _runtime_swig.fast_atan2f(*args)

def branchless_clip(*args, **kwargs):
  """branchless_clip(float x, float clip) -> float"""
  return _runtime_swig.branchless_clip(*args, **kwargs)

def clip(*args, **kwargs):
  """clip(float x, float clip) -> float"""
  return _runtime_swig.clip(*args, **kwargs)

def binary_slicer(*args, **kwargs):
  """binary_slicer(float x) -> unsigned int"""
  return _runtime_swig.binary_slicer(*args, **kwargs)

def quad_45deg_slicer(*args):
  """
    quad_45deg_slicer(float r, float i) -> unsigned int
    quad_45deg_slicer(gr_complex x) -> unsigned int
    """
  return _runtime_swig.quad_45deg_slicer(*args)

def quad_0deg_slicer(*args):
  """
    quad_0deg_slicer(float r, float i) -> unsigned int
    quad_0deg_slicer(gr_complex x) -> unsigned int
    """
  return _runtime_swig.quad_0deg_slicer(*args)

def branchless_binary_slicer(*args, **kwargs):
  """branchless_binary_slicer(float x) -> unsigned int"""
  return _runtime_swig.branchless_binary_slicer(*args, **kwargs)

def branchless_quad_0deg_slicer(*args):
  """
    branchless_quad_0deg_slicer(float r, float i) -> unsigned int
    branchless_quad_0deg_slicer(gr_complex x) -> unsigned int
    """
  return _runtime_swig.branchless_quad_0deg_slicer(*args)

def branchless_quad_45deg_slicer(*args):
  """
    branchless_quad_45deg_slicer(float r, float i) -> unsigned int
    branchless_quad_45deg_slicer(gr_complex x) -> unsigned int
    """
  return _runtime_swig.branchless_quad_45deg_slicer(*args)

def p2_round_down(*args, **kwargs):
  """p2_round_down(size_t x, size_t pow2) -> size_t"""
  return _runtime_swig.p2_round_down(*args, **kwargs)

def p2_round_up(*args, **kwargs):
  """p2_round_up(size_t x, size_t pow2) -> size_t"""
  return _runtime_swig.p2_round_up(*args, **kwargs)

def p2_modulo(*args, **kwargs):
  """p2_modulo(size_t x, size_t pow2) -> size_t"""
  return _runtime_swig.p2_modulo(*args, **kwargs)

def p2_modulo_neg(*args, **kwargs):
  """p2_modulo_neg(size_t x, size_t pow2) -> size_t"""
  return _runtime_swig.p2_modulo_neg(*args, **kwargs)
class random(object):
    """pseudo random number generator"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, seed=0, min_integer=0, max_integer=2): 
        """__init__(gr::random self, unsigned int seed=0, int min_integer=0, int max_integer=2) -> random"""
        this = _runtime_swig.new_random(seed, min_integer, max_integer)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _runtime_swig.delete_random
    __del__ = lambda self : None;
    def reseed(self, *args, **kwargs):
        """
        reseed(random self, unsigned int seed)

        Change the seed for the initialized number generator. seed = 0 initializes the random number generator with the system time. Note that a fast initialization of various instances can result in the same seed.
        """
        return _runtime_swig.random_reseed(self, *args, **kwargs)

    def set_integer_limits(self, *args, **kwargs):
        """
        set_integer_limits(random self, int const minimum, int const maximum)

        set minimum and maximum for integer random number generator. Limits are [minimum, maximum) Default: [0, std::numeric_limits< IntType >::max)]
        """
        return _runtime_swig.random_set_integer_limits(self, *args, **kwargs)

    def ran_int(self):
        """
        ran_int(random self) -> int

        Uniform random integers in the range set by 'set_integer_limits' [min, max).
        """
        return _runtime_swig.random_ran_int(self)

    def ran1(self):
        """
        ran1(random self) -> float

        Uniform random numbers in the range [0.0, 1.0)
        """
        return _runtime_swig.random_ran1(self)

    def gasdev(self):
        """
        gasdev(random self) -> float

        Normally distributed random numbers (Gaussian distribution with zero mean and variance 1)
        """
        return _runtime_swig.random_gasdev(self)

    def laplacian(self):
        """
        laplacian(random self) -> float

        Laplacian distributed random numbers with zero mean and variance 1.
        """
        return _runtime_swig.random_laplacian(self)

    def rayleigh(self):
        """
        rayleigh(random self) -> float

        Rayleigh distributed random numbers (zero mean and variance 1 for the underlying Gaussian distributions)
        """
        return _runtime_swig.random_rayleigh(self)

    def impulse(self, *args, **kwargs):
        """
        impulse(random self, float factor) -> float

        FIXME: add description.
        """
        return _runtime_swig.random_impulse(self, *args, **kwargs)

    def rayleigh_complex(self):
        """
        rayleigh_complex(random self) -> gr_complex

        Normally distributed random numbers with zero mean and variance 1 on real and imaginary part. This results in a Rayleigh distribution for the amplitude and an uniform distribution for the phase.
        """
        return _runtime_swig.random_rayleigh_complex(self)

random_swigregister = _runtime_swig.random_swigregister
random_swigregister(random)



