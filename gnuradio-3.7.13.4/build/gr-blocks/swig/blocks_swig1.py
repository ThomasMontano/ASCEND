# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_blocks_swig1', [dirname(__file__)])
        except ImportError:
            import _blocks_swig1
            return _blocks_swig1
        if fp is not None:
            try:
                _mod = imp.load_module('_blocks_swig1', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _blocks_swig1 = swig_import_helper()
    del swig_import_helper
else:
    import _blocks_swig1
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def high_res_timer_now():
  """high_res_timer_now() -> gr::high_res_timer_type"""
  return _blocks_swig1.high_res_timer_now()

def high_res_timer_now_perfmon():
  """high_res_timer_now_perfmon() -> gr::high_res_timer_type"""
  return _blocks_swig1.high_res_timer_now_perfmon()

def high_res_timer_tps():
  """high_res_timer_tps() -> gr::high_res_timer_type"""
  return _blocks_swig1.high_res_timer_tps()

def high_res_timer_epoch():
  """high_res_timer_epoch() -> gr::high_res_timer_type"""
  return _blocks_swig1.high_res_timer_epoch()
class vector_map(object):
    """
    Maps elements from a set of input vectors to a set of output vectors.

    If in[i] is the input vector in the i'th stream then the output vector in the j'th stream is:

    out[j][k] = in[mapping[j][k][0]][mapping[j][k][1]]

    That is mapping is of the form (out_stream1_mapping, out_stream2_mapping, ...) and out_stream1_mapping is of the form (element1_mapping, element2_mapping, ...) and element1_mapping is of the form (in_stream, in_element).

    Constructor Specific Documentation:

    Build a vector map block.

    Args:
        item_size : (integer) size of vector elements
        in_vlens : (vector of integers) number of elements in each input vector
        mapping : (vector of vectors of vectors of integers) how to map elements from input to output vectors
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(size_t item_size, gr_vsize_t in_vlens, gr_vvvsize_t mapping) -> vector_map_sptr

        Maps elements from a set of input vectors to a set of output vectors.

        If in[i] is the input vector in the i'th stream then the output vector in the j'th stream is:

        out[j][k] = in[mapping[j][k][0]][mapping[j][k][1]]

        That is mapping is of the form (out_stream1_mapping, out_stream2_mapping, ...) and out_stream1_mapping is of the form (element1_mapping, element2_mapping, ...) and element1_mapping is of the form (in_stream, in_element).

        Constructor Specific Documentation:

        Build a vector map block.

        Args:
            item_size : (integer) size of vector elements
            in_vlens : (vector of integers) number of elements in each input vector
            mapping : (vector of vectors of vectors of integers) how to map elements from input to output vectors
        """
        return _blocks_swig1.vector_map_make(*args, **kwargs)

    make = staticmethod(make)
    def set_mapping(self, *args, **kwargs):
        """set_mapping(vector_map self, gr_vvvsize_t mapping)"""
        return _blocks_swig1.vector_map_set_mapping(self, *args, **kwargs)

    __swig_destroy__ = _blocks_swig1.delete_vector_map
    __del__ = lambda self : None;
vector_map_swigregister = _blocks_swig1.vector_map_swigregister
vector_map_swigregister(vector_map)

def vector_map_make(*args, **kwargs):
  """
    vector_map_make(size_t item_size, gr_vsize_t in_vlens, gr_vvvsize_t mapping) -> vector_map_sptr

    Maps elements from a set of input vectors to a set of output vectors.

    If in[i] is the input vector in the i'th stream then the output vector in the j'th stream is:

    out[j][k] = in[mapping[j][k][0]][mapping[j][k][1]]

    That is mapping is of the form (out_stream1_mapping, out_stream2_mapping, ...) and out_stream1_mapping is of the form (element1_mapping, element2_mapping, ...) and element1_mapping is of the form (in_stream, in_element).

    Constructor Specific Documentation:

    Build a vector map block.

    Args:
        item_size : (integer) size of vector elements
        in_vlens : (vector of integers) number of elements in each input vector
        mapping : (vector of vectors of vectors of integers) how to map elements from input to output vectors
    """
  return _blocks_swig1.vector_map_make(*args, **kwargs)

class vector_to_stream(object):
    """
    convert a stream of gnuradio/blocks of nitems_per_block items into a stream of items

    Constructor Specific Documentation:

    Make vector-to-stream block

    Args:
        itemsize : the item size of the stream
        nitems_per_block : number of items per vector (vector size)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(size_t itemsize, size_t nitems_per_block) -> vector_to_stream_sptr

        convert a stream of gnuradio/blocks of nitems_per_block items into a stream of items

        Constructor Specific Documentation:

        Make vector-to-stream block

        Args:
            itemsize : the item size of the stream
            nitems_per_block : number of items per vector (vector size)
        """
        return _blocks_swig1.vector_to_stream_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _blocks_swig1.delete_vector_to_stream
    __del__ = lambda self : None;
vector_to_stream_swigregister = _blocks_swig1.vector_to_stream_swigregister
vector_to_stream_swigregister(vector_to_stream)

def vector_to_stream_make(*args, **kwargs):
  """
    vector_to_stream_make(size_t itemsize, size_t nitems_per_block) -> vector_to_stream_sptr

    convert a stream of gnuradio/blocks of nitems_per_block items into a stream of items

    Constructor Specific Documentation:

    Make vector-to-stream block

    Args:
        itemsize : the item size of the stream
        nitems_per_block : number of items per vector (vector size)
    """
  return _blocks_swig1.vector_to_stream_make(*args, **kwargs)

class vector_to_streams(object):
    """
    Convert 1 stream of vectors of length N to N streams of items.

    Constructor Specific Documentation:

    Make vector-to-streams block

    Args:
        itemsize : the item size of the stream
        nstreams : number of items per vector (vector size and number of streams produced)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(size_t itemsize, size_t nstreams) -> vector_to_streams_sptr

        Convert 1 stream of vectors of length N to N streams of items.

        Constructor Specific Documentation:

        Make vector-to-streams block

        Args:
            itemsize : the item size of the stream
            nstreams : number of items per vector (vector size and number of streams produced)
        """
        return _blocks_swig1.vector_to_streams_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _blocks_swig1.delete_vector_to_streams
    __del__ = lambda self : None;
vector_to_streams_swigregister = _blocks_swig1.vector_to_streams_swigregister
vector_to_streams_swigregister(vector_to_streams)

def vector_to_streams_make(*args, **kwargs):
  """
    vector_to_streams_make(size_t itemsize, size_t nstreams) -> vector_to_streams_sptr

    Convert 1 stream of vectors of length N to N streams of items.

    Constructor Specific Documentation:

    Make vector-to-streams block

    Args:
        itemsize : the item size of the stream
        nstreams : number of items per vector (vector size and number of streams produced)
    """
  return _blocks_swig1.vector_to_streams_make(*args, **kwargs)

class vector_insert_b(object):
    """
    source of unsigned char's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< unsigned char,std::allocator< unsigned char > > const & data, int periodicity, 
            int offset=0) -> vector_insert_b_sptr

        source of unsigned char's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_b_make(*args, **kwargs)

    make = staticmethod(make)
    def rewind(self):
        """rewind(vector_insert_b self)"""
        return _blocks_swig1.vector_insert_b_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_insert_b self, std::vector< unsigned char,std::allocator< unsigned char > > const & data)"""
        return _blocks_swig1.vector_insert_b_set_data(self, *args, **kwargs)

    __swig_destroy__ = _blocks_swig1.delete_vector_insert_b
    __del__ = lambda self : None;
vector_insert_b_swigregister = _blocks_swig1.vector_insert_b_swigregister
vector_insert_b_swigregister(vector_insert_b)

def vector_insert_b_make(*args, **kwargs):
  """
    vector_insert_b_make(std::vector< unsigned char,std::allocator< unsigned char > > const & data, int periodicity, 
        int offset=0) -> vector_insert_b_sptr

    source of unsigned char's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
  return _blocks_swig1.vector_insert_b_make(*args, **kwargs)

class vector_insert_s(object):
    """
    source of short's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< short,std::allocator< short > > const & data, int periodicity, int offset=0) -> vector_insert_s_sptr

        source of short's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_s_make(*args, **kwargs)

    make = staticmethod(make)
    def rewind(self):
        """rewind(vector_insert_s self)"""
        return _blocks_swig1.vector_insert_s_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_insert_s self, std::vector< short,std::allocator< short > > const & data)"""
        return _blocks_swig1.vector_insert_s_set_data(self, *args, **kwargs)

    __swig_destroy__ = _blocks_swig1.delete_vector_insert_s
    __del__ = lambda self : None;
vector_insert_s_swigregister = _blocks_swig1.vector_insert_s_swigregister
vector_insert_s_swigregister(vector_insert_s)

def vector_insert_s_make(*args, **kwargs):
  """
    vector_insert_s_make(std::vector< short,std::allocator< short > > const & data, int periodicity, int offset=0) -> vector_insert_s_sptr

    source of short's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
  return _blocks_swig1.vector_insert_s_make(*args, **kwargs)

class vector_insert_i(object):
    """
    source of int's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< int,std::allocator< int > > const & data, int periodicity, int offset=0) -> vector_insert_i_sptr

        source of int's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_i_make(*args, **kwargs)

    make = staticmethod(make)
    def rewind(self):
        """rewind(vector_insert_i self)"""
        return _blocks_swig1.vector_insert_i_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_insert_i self, std::vector< int,std::allocator< int > > const & data)"""
        return _blocks_swig1.vector_insert_i_set_data(self, *args, **kwargs)

    __swig_destroy__ = _blocks_swig1.delete_vector_insert_i
    __del__ = lambda self : None;
vector_insert_i_swigregister = _blocks_swig1.vector_insert_i_swigregister
vector_insert_i_swigregister(vector_insert_i)

def vector_insert_i_make(*args, **kwargs):
  """
    vector_insert_i_make(std::vector< int,std::allocator< int > > const & data, int periodicity, int offset=0) -> vector_insert_i_sptr

    source of int's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
  return _blocks_swig1.vector_insert_i_make(*args, **kwargs)

class vector_insert_f(object):
    """
    source of float's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_float data, int periodicity, int offset=0) -> vector_insert_f_sptr

        source of float's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_f_make(*args, **kwargs)

    make = staticmethod(make)
    def rewind(self):
        """rewind(vector_insert_f self)"""
        return _blocks_swig1.vector_insert_f_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_insert_f self, pmt_vector_float data)"""
        return _blocks_swig1.vector_insert_f_set_data(self, *args, **kwargs)

    __swig_destroy__ = _blocks_swig1.delete_vector_insert_f
    __del__ = lambda self : None;
vector_insert_f_swigregister = _blocks_swig1.vector_insert_f_swigregister
vector_insert_f_swigregister(vector_insert_f)

def vector_insert_f_make(*args, **kwargs):
  """
    vector_insert_f_make(pmt_vector_float data, int periodicity, int offset=0) -> vector_insert_f_sptr

    source of float's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
  return _blocks_swig1.vector_insert_f_make(*args, **kwargs)

class vector_insert_c(object):
    """
    source of gr_complex's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat data, int periodicity, int offset=0) -> vector_insert_c_sptr

        source of gr_complex's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_c_make(*args, **kwargs)

    make = staticmethod(make)
    def rewind(self):
        """rewind(vector_insert_c self)"""
        return _blocks_swig1.vector_insert_c_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_insert_c self, pmt_vector_cfloat data)"""
        return _blocks_swig1.vector_insert_c_set_data(self, *args, **kwargs)

    __swig_destroy__ = _blocks_swig1.delete_vector_insert_c
    __del__ = lambda self : None;
vector_insert_c_swigregister = _blocks_swig1.vector_insert_c_swigregister
vector_insert_c_swigregister(vector_insert_c)

def vector_insert_c_make(*args, **kwargs):
  """
    vector_insert_c_make(pmt_vector_cfloat data, int periodicity, int offset=0) -> vector_insert_c_sptr

    source of gr_complex's that gets its data from a vector

    Constructor Specific Documentation:

    Make vector insert block.

    Args:
        data : vector of data to insert
        periodicity : number of samples between when to send
        offset : initial item offset of first insert
    """
  return _blocks_swig1.vector_insert_c_make(*args, **kwargs)

class vector_sink_b(object):
    """
    unsigned char sink that writes to a vector

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(vlen=1, reserve_items=1024):
        """
        make(int const vlen=1, int const reserve_items=1024) -> vector_sink_b_sptr

        unsigned char sink that writes to a vector

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_b_make(vlen, reserve_items)

    make = staticmethod(make)
    def reset(self):
        """
        reset(vector_sink_b self)

        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_b_reset(self)

    def data(self):
        """data(vector_sink_b self) -> std::vector< unsigned char,std::allocator< unsigned char > >"""
        return _blocks_swig1.vector_sink_b_data(self)

    def tags(self):
        """tags(vector_sink_b self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_b_tags(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_sink_b
    __del__ = lambda self : None;
vector_sink_b_swigregister = _blocks_swig1.vector_sink_b_swigregister
vector_sink_b_swigregister(vector_sink_b)

def vector_sink_b_make(vlen=1, reserve_items=1024):
  """
    vector_sink_b_make(int const vlen=1, int const reserve_items=1024) -> vector_sink_b_sptr

    unsigned char sink that writes to a vector

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
  return _blocks_swig1.vector_sink_b_make(vlen, reserve_items)

class vector_sink_s(object):
    """
    short sink that writes to a vector

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(vlen=1, reserve_items=1024):
        """
        make(int const vlen=1, int const reserve_items=1024) -> vector_sink_s_sptr

        short sink that writes to a vector

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_s_make(vlen, reserve_items)

    make = staticmethod(make)
    def reset(self):
        """
        reset(vector_sink_s self)

        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_s_reset(self)

    def data(self):
        """data(vector_sink_s self) -> std::vector< short,std::allocator< short > >"""
        return _blocks_swig1.vector_sink_s_data(self)

    def tags(self):
        """tags(vector_sink_s self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_s_tags(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_sink_s
    __del__ = lambda self : None;
vector_sink_s_swigregister = _blocks_swig1.vector_sink_s_swigregister
vector_sink_s_swigregister(vector_sink_s)

def vector_sink_s_make(vlen=1, reserve_items=1024):
  """
    vector_sink_s_make(int const vlen=1, int const reserve_items=1024) -> vector_sink_s_sptr

    short sink that writes to a vector

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
  return _blocks_swig1.vector_sink_s_make(vlen, reserve_items)

class vector_sink_i(object):
    """
    int sink that writes to a vector

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(vlen=1, reserve_items=1024):
        """
        make(int const vlen=1, int const reserve_items=1024) -> vector_sink_i_sptr

        int sink that writes to a vector

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_i_make(vlen, reserve_items)

    make = staticmethod(make)
    def reset(self):
        """
        reset(vector_sink_i self)

        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_i_reset(self)

    def data(self):
        """data(vector_sink_i self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_sink_i_data(self)

    def tags(self):
        """tags(vector_sink_i self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_i_tags(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_sink_i
    __del__ = lambda self : None;
vector_sink_i_swigregister = _blocks_swig1.vector_sink_i_swigregister
vector_sink_i_swigregister(vector_sink_i)

def vector_sink_i_make(vlen=1, reserve_items=1024):
  """
    vector_sink_i_make(int const vlen=1, int const reserve_items=1024) -> vector_sink_i_sptr

    int sink that writes to a vector

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
  return _blocks_swig1.vector_sink_i_make(vlen, reserve_items)

class vector_sink_f(object):
    """
    float sink that writes to a vector

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(vlen=1, reserve_items=1024):
        """
        make(int const vlen=1, int const reserve_items=1024) -> vector_sink_f_sptr

        float sink that writes to a vector

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_f_make(vlen, reserve_items)

    make = staticmethod(make)
    def reset(self):
        """
        reset(vector_sink_f self)

        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_f_reset(self)

    def data(self):
        """data(vector_sink_f self) -> pmt_vector_float"""
        return _blocks_swig1.vector_sink_f_data(self)

    def tags(self):
        """tags(vector_sink_f self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_f_tags(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_sink_f
    __del__ = lambda self : None;
vector_sink_f_swigregister = _blocks_swig1.vector_sink_f_swigregister
vector_sink_f_swigregister(vector_sink_f)

def vector_sink_f_make(vlen=1, reserve_items=1024):
  """
    vector_sink_f_make(int const vlen=1, int const reserve_items=1024) -> vector_sink_f_sptr

    float sink that writes to a vector

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
  return _blocks_swig1.vector_sink_f_make(vlen, reserve_items)

class vector_sink_c(object):
    """
    gr_complex sink that writes to a vector

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(vlen=1, reserve_items=1024):
        """
        make(int const vlen=1, int const reserve_items=1024) -> vector_sink_c_sptr

        gr_complex sink that writes to a vector

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_c_make(vlen, reserve_items)

    make = staticmethod(make)
    def reset(self):
        """
        reset(vector_sink_c self)

        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_c_reset(self)

    def data(self):
        """data(vector_sink_c self) -> pmt_vector_cfloat"""
        return _blocks_swig1.vector_sink_c_data(self)

    def tags(self):
        """tags(vector_sink_c self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_c_tags(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_sink_c
    __del__ = lambda self : None;
vector_sink_c_swigregister = _blocks_swig1.vector_sink_c_swigregister
vector_sink_c_swigregister(vector_sink_c)

def vector_sink_c_make(vlen=1, reserve_items=1024):
  """
    vector_sink_c_make(int const vlen=1, int const reserve_items=1024) -> vector_sink_c_sptr

    gr_complex sink that writes to a vector

    Constructor Specific Documentation:

    Make a new instance of the vector source, and return a shared pointer to it.

    Args:
        vlen : length of vector items
        reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
    """
  return _blocks_swig1.vector_sink_c_make(vlen, reserve_items)

class vector_source_b(object):
    """
    Source that streams unsigned char items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<unsigned char>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< unsigned char,std::allocator< unsigned char > > const & data, bool repeat=False, 
            int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_b_sptr

        Source that streams unsigned char items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<unsigned char>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_b_make(*args, **kwargs)

    make = staticmethod(make)
    def rewind(self):
        """rewind(vector_source_b self)"""
        return _blocks_swig1.vector_source_b_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_source_b self, std::vector< unsigned char,std::allocator< unsigned char > > const & data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_b_set_data(self, *args, **kwargs)

    def set_repeat(self, *args, **kwargs):
        """set_repeat(vector_source_b self, bool repeat)"""
        return _blocks_swig1.vector_source_b_set_repeat(self, *args, **kwargs)

    __swig_destroy__ = _blocks_swig1.delete_vector_source_b
    __del__ = lambda self : None;
vector_source_b_swigregister = _blocks_swig1.vector_source_b_swigregister
vector_source_b_swigregister(vector_source_b)

def vector_source_b_make(*args, **kwargs):
  """
    vector_source_b_make(std::vector< unsigned char,std::allocator< unsigned char > > const & data, bool repeat=False, 
        int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_b_sptr

    Source that streams unsigned char items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<unsigned char>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
  return _blocks_swig1.vector_source_b_make(*args, **kwargs)

class vector_source_s(object):
    """
    Source that streams short items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<short>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< short,std::allocator< short > > const & data, bool repeat=False, int vlen=1, 
            tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_s_sptr

        Source that streams short items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<short>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_s_make(*args, **kwargs)

    make = staticmethod(make)
    def rewind(self):
        """rewind(vector_source_s self)"""
        return _blocks_swig1.vector_source_s_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_source_s self, std::vector< short,std::allocator< short > > const & data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_s_set_data(self, *args, **kwargs)

    def set_repeat(self, *args, **kwargs):
        """set_repeat(vector_source_s self, bool repeat)"""
        return _blocks_swig1.vector_source_s_set_repeat(self, *args, **kwargs)

    __swig_destroy__ = _blocks_swig1.delete_vector_source_s
    __del__ = lambda self : None;
vector_source_s_swigregister = _blocks_swig1.vector_source_s_swigregister
vector_source_s_swigregister(vector_source_s)

def vector_source_s_make(*args, **kwargs):
  """
    vector_source_s_make(std::vector< short,std::allocator< short > > const & data, bool repeat=False, int vlen=1, 
        tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_s_sptr

    Source that streams short items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<short>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
  return _blocks_swig1.vector_source_s_make(*args, **kwargs)

class vector_source_i(object):
    """
    Source that streams int items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<int>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< int,std::allocator< int > > const & data, bool repeat=False, int vlen=1, 
            tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_i_sptr

        Source that streams int items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<int>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_i_make(*args, **kwargs)

    make = staticmethod(make)
    def rewind(self):
        """rewind(vector_source_i self)"""
        return _blocks_swig1.vector_source_i_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_source_i self, std::vector< int,std::allocator< int > > const & data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_i_set_data(self, *args, **kwargs)

    def set_repeat(self, *args, **kwargs):
        """set_repeat(vector_source_i self, bool repeat)"""
        return _blocks_swig1.vector_source_i_set_repeat(self, *args, **kwargs)

    __swig_destroy__ = _blocks_swig1.delete_vector_source_i
    __del__ = lambda self : None;
vector_source_i_swigregister = _blocks_swig1.vector_source_i_swigregister
vector_source_i_swigregister(vector_source_i)

def vector_source_i_make(*args, **kwargs):
  """
    vector_source_i_make(std::vector< int,std::allocator< int > > const & data, bool repeat=False, int vlen=1, 
        tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_i_sptr

    Source that streams int items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<int>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
  return _blocks_swig1.vector_source_i_make(*args, **kwargs)

class vector_source_f(object):
    """
    Source that streams float items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<float>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_float data, bool repeat=False, int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_f_sptr

        Source that streams float items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<float>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_f_make(*args, **kwargs)

    make = staticmethod(make)
    def rewind(self):
        """rewind(vector_source_f self)"""
        return _blocks_swig1.vector_source_f_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_source_f self, pmt_vector_float data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_f_set_data(self, *args, **kwargs)

    def set_repeat(self, *args, **kwargs):
        """set_repeat(vector_source_f self, bool repeat)"""
        return _blocks_swig1.vector_source_f_set_repeat(self, *args, **kwargs)

    __swig_destroy__ = _blocks_swig1.delete_vector_source_f
    __del__ = lambda self : None;
vector_source_f_swigregister = _blocks_swig1.vector_source_f_swigregister
vector_source_f_swigregister(vector_source_f)

def vector_source_f_make(*args, **kwargs):
  """
    vector_source_f_make(pmt_vector_float data, bool repeat=False, int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_f_sptr

    Source that streams float items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<float>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
  return _blocks_swig1.vector_source_f_make(*args, **kwargs)

class vector_source_c(object):
    """
    Source that streams gr_complex items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<gr_complex>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(pmt_vector_cfloat data, bool repeat=False, int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_c_sptr

        Source that streams gr_complex items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<gr_complex>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_c_make(*args, **kwargs)

    make = staticmethod(make)
    def rewind(self):
        """rewind(vector_source_c self)"""
        return _blocks_swig1.vector_source_c_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_source_c self, pmt_vector_cfloat data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_c_set_data(self, *args, **kwargs)

    def set_repeat(self, *args, **kwargs):
        """set_repeat(vector_source_c self, bool repeat)"""
        return _blocks_swig1.vector_source_c_set_repeat(self, *args, **kwargs)

    __swig_destroy__ = _blocks_swig1.delete_vector_source_c
    __del__ = lambda self : None;
vector_source_c_swigregister = _blocks_swig1.vector_source_c_swigregister
vector_source_c_swigregister(vector_source_c)

def vector_source_c_make(*args, **kwargs):
  """
    vector_source_c_make(pmt_vector_cfloat data, bool repeat=False, int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_c_sptr

    Source that streams gr_complex items based on the input  vector.

    This block produces a stream of samples based on an input vector. In C++, this is a std::vector<gr_complex>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

    The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

    GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

    We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

    When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

    Constructor Specific Documentation:



    Args:
        data : 
        repeat : 
        vlen : 
        tags : 
    """
  return _blocks_swig1.vector_source_c_make(*args, **kwargs)

class wavfile_sink(object):
    """
    Write stream to a Microsoft PCM (.wav) file.

    Values must be floats within [-1;1]. Check gr_make_wavfile_sink() for extra info.

    Constructor Specific Documentation:



    Args:
        filename : 
        n_channels : 
        sample_rate : 
        bits_per_sample : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(char const * filename, int n_channels, unsigned int sample_rate, int bits_per_sample=16) -> wavfile_sink_sptr

        Write stream to a Microsoft PCM (.wav) file.

        Values must be floats within [-1;1]. Check gr_make_wavfile_sink() for extra info.

        Constructor Specific Documentation:



        Args:
            filename : 
            n_channels : 
            sample_rate : 
            bits_per_sample : 
        """
        return _blocks_swig1.wavfile_sink_make(*args, **kwargs)

    make = staticmethod(make)
    def open(self, *args, **kwargs):
        """
        open(wavfile_sink self, char const * filename) -> bool

        Opens a new file and writes a WAV header. Thread-safe.
        """
        return _blocks_swig1.wavfile_sink_open(self, *args, **kwargs)

    def close(self):
        """
        close(wavfile_sink self)

        Closes the currently active file and completes the WAV header. Thread-safe.
        """
        return _blocks_swig1.wavfile_sink_close(self)

    def set_sample_rate(self, *args, **kwargs):
        """
        set_sample_rate(wavfile_sink self, unsigned int sample_rate)

        Set the sample rate. This will not affect the WAV file currently opened. Any following open() calls will use this new sample rate.
        """
        return _blocks_swig1.wavfile_sink_set_sample_rate(self, *args, **kwargs)

    def set_bits_per_sample(self, *args, **kwargs):
        """
        set_bits_per_sample(wavfile_sink self, int bits_per_sample)

        Set bits per sample. This will not affect the WAV file currently opened (see set_sample_rate()). If the value is neither 8 nor 16, the call is ignored and the current value is kept.
        """
        return _blocks_swig1.wavfile_sink_set_bits_per_sample(self, *args, **kwargs)

    __swig_destroy__ = _blocks_swig1.delete_wavfile_sink
    __del__ = lambda self : None;
wavfile_sink_swigregister = _blocks_swig1.wavfile_sink_swigregister
wavfile_sink_swigregister(wavfile_sink)

def wavfile_sink_make(*args, **kwargs):
  """
    wavfile_sink_make(char const * filename, int n_channels, unsigned int sample_rate, int bits_per_sample=16) -> wavfile_sink_sptr

    Write stream to a Microsoft PCM (.wav) file.

    Values must be floats within [-1;1]. Check gr_make_wavfile_sink() for extra info.

    Constructor Specific Documentation:



    Args:
        filename : 
        n_channels : 
        sample_rate : 
        bits_per_sample : 
    """
  return _blocks_swig1.wavfile_sink_make(*args, **kwargs)

class wavfile_source(object):
    """
    Read stream from a Microsoft PCM (.wav) file, output floats.

    Unless otherwise called, values are within [-1;1]. Check gr_make_wavfile_source() for extra info.

    Constructor Specific Documentation:



    Args:
        filename : 
        repeat : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(char const * filename, bool repeat=False) -> wavfile_source_sptr

        Read stream from a Microsoft PCM (.wav) file, output floats.

        Unless otherwise called, values are within [-1;1]. Check gr_make_wavfile_source() for extra info.

        Constructor Specific Documentation:



        Args:
            filename : 
            repeat : 
        """
        return _blocks_swig1.wavfile_source_make(*args, **kwargs)

    make = staticmethod(make)
    def sample_rate(self):
        """
        sample_rate(wavfile_source self) -> unsigned int

        Read the sample rate as specified in the wav file header.
        """
        return _blocks_swig1.wavfile_source_sample_rate(self)

    def bits_per_sample(self):
        """
        bits_per_sample(wavfile_source self) -> int

        Return the number of bits per sample as specified in the wav file header. Only 8 or 16 bit are supported here.
        """
        return _blocks_swig1.wavfile_source_bits_per_sample(self)

    def channels(self):
        """
        channels(wavfile_source self) -> int

        Return the number of channels in the wav file as specified in the wav file header. This is also the max number of outputs you can have.
        """
        return _blocks_swig1.wavfile_source_channels(self)

    __swig_destroy__ = _blocks_swig1.delete_wavfile_source
    __del__ = lambda self : None;
wavfile_source_swigregister = _blocks_swig1.wavfile_source_swigregister
wavfile_source_swigregister(wavfile_source)

def wavfile_source_make(*args, **kwargs):
  """
    wavfile_source_make(char const * filename, bool repeat=False) -> wavfile_source_sptr

    Read stream from a Microsoft PCM (.wav) file, output floats.

    Unless otherwise called, values are within [-1;1]. Check gr_make_wavfile_source() for extra info.

    Constructor Specific Documentation:



    Args:
        filename : 
        repeat : 
    """
  return _blocks_swig1.wavfile_source_make(*args, **kwargs)

class vector_map_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_map)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_map)> self) -> vector_map_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_map)> self, vector_map p) -> vector_map_sptr
        """
        this = _blocks_swig1.new_vector_map_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_map_sptr self) -> vector_map"""
        return _blocks_swig1.vector_map_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_map_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_map_sptr self, size_t item_size, gr_vsize_t in_vlens, gr_vvvsize_t mapping) -> vector_map_sptr

        Maps elements from a set of input vectors to a set of output vectors.

        If in[i] is the input vector in the i'th stream then the output vector in the j'th stream is:

        out[j][k] = in[mapping[j][k][0]][mapping[j][k][1]]

        That is mapping is of the form (out_stream1_mapping, out_stream2_mapping, ...) and out_stream1_mapping is of the form (element1_mapping, element2_mapping, ...) and element1_mapping is of the form (in_stream, in_element).

        Constructor Specific Documentation:

        Build a vector map block.

        Args:
            item_size : (integer) size of vector elements
            in_vlens : (vector of integers) number of elements in each input vector
            mapping : (vector of vectors of vectors of integers) how to map elements from input to output vectors
        """
        return _blocks_swig1.vector_map_sptr_make(self, *args, **kwargs)

    def set_mapping(self, *args, **kwargs):
        """set_mapping(vector_map_sptr self, gr_vvvsize_t mapping)"""
        return _blocks_swig1.vector_map_sptr_set_mapping(self, *args, **kwargs)

    def history(self):
        """history(vector_map_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_map_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_map_sptr self, int which, int delay)
        declare_sample_delay(vector_map_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_map_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_map_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_map_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_map_sptr self) -> int"""
        return _blocks_swig1.vector_map_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_map_sptr self) -> double"""
        return _blocks_swig1.vector_map_sptr_relative_rate(self)

    def start(self):
        """start(vector_map_sptr self) -> bool"""
        return _blocks_swig1.vector_map_sptr_start(self)

    def stop(self):
        """stop(vector_map_sptr self) -> bool"""
        return _blocks_swig1.vector_map_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_map_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_map_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_map_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_map_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_map_sptr self) -> int"""
        return _blocks_swig1.vector_map_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_map_sptr self, int m)"""
        return _blocks_swig1.vector_map_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_map_sptr self)"""
        return _blocks_swig1.vector_map_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_map_sptr self) -> bool"""
        return _blocks_swig1.vector_map_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_map_sptr self, int m)"""
        return _blocks_swig1.vector_map_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_map_sptr self) -> int"""
        return _blocks_swig1.vector_map_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_map_sptr self, int i) -> long"""
        return _blocks_swig1.vector_map_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_map_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_map_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_map_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_map_sptr self, int i) -> long"""
        return _blocks_swig1.vector_map_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_map_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_map_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_map_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_map_sptr self, int which) -> float
        pc_input_buffers_full(vector_map_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_map_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_map_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_map_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_map_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_map_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_map_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_map_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_map_sptr self, int which) -> float
        pc_output_buffers_full(vector_map_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_map_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_map_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_map_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_map_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_map_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_map_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_map_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_map_sptr self) -> float"""
        return _blocks_swig1.vector_map_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_map_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_map_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_map_sptr self)"""
        return _blocks_swig1.vector_map_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_map_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_map_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_map_sptr self) -> int"""
        return _blocks_swig1.vector_map_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_map_sptr self) -> int"""
        return _blocks_swig1.vector_map_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_map_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_map_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_map_sptr self) -> std::string"""
        return _blocks_swig1.vector_map_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_map_sptr self) -> std::string"""
        return _blocks_swig1.vector_map_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_map_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_map_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_map_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_map_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_map_sptr self) -> long"""
        return _blocks_swig1.vector_map_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_map_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_map_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_map_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_map_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_map_sptr self) -> std::string"""
        return _blocks_swig1.vector_map_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_map_sptr self, std::string name)"""
        return _blocks_swig1.vector_map_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_map_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_map_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_map_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_map_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_map_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_map_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_map_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_map_sptr_message_subscribers(self, *args, **kwargs)

vector_map_sptr_swigregister = _blocks_swig1.vector_map_sptr_swigregister
vector_map_sptr_swigregister(vector_map_sptr)

vector_map_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_map = vector_map.make;

class vector_to_stream_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_to_stream)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_to_stream)> self) -> vector_to_stream_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_to_stream)> self, vector_to_stream p) -> vector_to_stream_sptr
        """
        this = _blocks_swig1.new_vector_to_stream_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_to_stream_sptr self) -> vector_to_stream"""
        return _blocks_swig1.vector_to_stream_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_to_stream_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_to_stream_sptr self, size_t itemsize, size_t nitems_per_block) -> vector_to_stream_sptr

        convert a stream of gnuradio/blocks of nitems_per_block items into a stream of items

        Constructor Specific Documentation:

        Make vector-to-stream block

        Args:
            itemsize : the item size of the stream
            nitems_per_block : number of items per vector (vector size)
        """
        return _blocks_swig1.vector_to_stream_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(vector_to_stream_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_to_stream_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_to_stream_sptr self, int which, int delay)
        declare_sample_delay(vector_to_stream_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_to_stream_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_to_stream_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_to_stream_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_to_stream_sptr self) -> int"""
        return _blocks_swig1.vector_to_stream_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_to_stream_sptr self) -> double"""
        return _blocks_swig1.vector_to_stream_sptr_relative_rate(self)

    def start(self):
        """start(vector_to_stream_sptr self) -> bool"""
        return _blocks_swig1.vector_to_stream_sptr_start(self)

    def stop(self):
        """stop(vector_to_stream_sptr self) -> bool"""
        return _blocks_swig1.vector_to_stream_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_to_stream_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_to_stream_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_to_stream_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_to_stream_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_to_stream_sptr self) -> int"""
        return _blocks_swig1.vector_to_stream_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_to_stream_sptr self, int m)"""
        return _blocks_swig1.vector_to_stream_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_to_stream_sptr self)"""
        return _blocks_swig1.vector_to_stream_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_to_stream_sptr self) -> bool"""
        return _blocks_swig1.vector_to_stream_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_to_stream_sptr self, int m)"""
        return _blocks_swig1.vector_to_stream_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_to_stream_sptr self) -> int"""
        return _blocks_swig1.vector_to_stream_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_to_stream_sptr self, int i) -> long"""
        return _blocks_swig1.vector_to_stream_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_to_stream_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_to_stream_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_to_stream_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_to_stream_sptr self, int i) -> long"""
        return _blocks_swig1.vector_to_stream_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_to_stream_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_to_stream_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_to_stream_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_to_stream_sptr self, int which) -> float
        pc_input_buffers_full(vector_to_stream_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_stream_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_to_stream_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_to_stream_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_stream_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_to_stream_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_to_stream_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_stream_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_to_stream_sptr self, int which) -> float
        pc_output_buffers_full(vector_to_stream_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_stream_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_to_stream_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_to_stream_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_stream_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_to_stream_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_to_stream_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_stream_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_to_stream_sptr self) -> float"""
        return _blocks_swig1.vector_to_stream_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_to_stream_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_to_stream_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_to_stream_sptr self)"""
        return _blocks_swig1.vector_to_stream_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_to_stream_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_to_stream_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_to_stream_sptr self) -> int"""
        return _blocks_swig1.vector_to_stream_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_to_stream_sptr self) -> int"""
        return _blocks_swig1.vector_to_stream_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_to_stream_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_to_stream_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_to_stream_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_stream_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_to_stream_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_stream_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_to_stream_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_to_stream_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_to_stream_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_to_stream_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_to_stream_sptr self) -> long"""
        return _blocks_swig1.vector_to_stream_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_to_stream_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_to_stream_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_to_stream_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_to_stream_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_to_stream_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_stream_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_to_stream_sptr self, std::string name)"""
        return _blocks_swig1.vector_to_stream_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_to_stream_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_to_stream_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_to_stream_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_to_stream_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_to_stream_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_to_stream_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_to_stream_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_to_stream_sptr_message_subscribers(self, *args, **kwargs)

vector_to_stream_sptr_swigregister = _blocks_swig1.vector_to_stream_sptr_swigregister
vector_to_stream_sptr_swigregister(vector_to_stream_sptr)

vector_to_stream_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_to_stream = vector_to_stream.make;

class vector_to_streams_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_to_streams)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_to_streams)> self) -> vector_to_streams_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_to_streams)> self, vector_to_streams p) -> vector_to_streams_sptr
        """
        this = _blocks_swig1.new_vector_to_streams_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_to_streams_sptr self) -> vector_to_streams"""
        return _blocks_swig1.vector_to_streams_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_to_streams_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_to_streams_sptr self, size_t itemsize, size_t nstreams) -> vector_to_streams_sptr

        Convert 1 stream of vectors of length N to N streams of items.

        Constructor Specific Documentation:

        Make vector-to-streams block

        Args:
            itemsize : the item size of the stream
            nstreams : number of items per vector (vector size and number of streams produced)
        """
        return _blocks_swig1.vector_to_streams_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(vector_to_streams_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_to_streams_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_to_streams_sptr self, int which, int delay)
        declare_sample_delay(vector_to_streams_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_to_streams_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_to_streams_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_to_streams_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_to_streams_sptr self) -> int"""
        return _blocks_swig1.vector_to_streams_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_to_streams_sptr self) -> double"""
        return _blocks_swig1.vector_to_streams_sptr_relative_rate(self)

    def start(self):
        """start(vector_to_streams_sptr self) -> bool"""
        return _blocks_swig1.vector_to_streams_sptr_start(self)

    def stop(self):
        """stop(vector_to_streams_sptr self) -> bool"""
        return _blocks_swig1.vector_to_streams_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_to_streams_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_to_streams_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_to_streams_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_to_streams_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_to_streams_sptr self) -> int"""
        return _blocks_swig1.vector_to_streams_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_to_streams_sptr self, int m)"""
        return _blocks_swig1.vector_to_streams_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_to_streams_sptr self)"""
        return _blocks_swig1.vector_to_streams_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_to_streams_sptr self) -> bool"""
        return _blocks_swig1.vector_to_streams_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_to_streams_sptr self, int m)"""
        return _blocks_swig1.vector_to_streams_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_to_streams_sptr self) -> int"""
        return _blocks_swig1.vector_to_streams_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_to_streams_sptr self, int i) -> long"""
        return _blocks_swig1.vector_to_streams_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_to_streams_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_to_streams_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_to_streams_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_to_streams_sptr self, int i) -> long"""
        return _blocks_swig1.vector_to_streams_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_to_streams_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_to_streams_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_to_streams_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_to_streams_sptr self, int which) -> float
        pc_input_buffers_full(vector_to_streams_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_streams_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_to_streams_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_to_streams_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_streams_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_to_streams_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_to_streams_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_streams_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_to_streams_sptr self, int which) -> float
        pc_output_buffers_full(vector_to_streams_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_streams_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_to_streams_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_to_streams_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_streams_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_to_streams_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_to_streams_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_to_streams_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_to_streams_sptr self) -> float"""
        return _blocks_swig1.vector_to_streams_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_to_streams_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_to_streams_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_to_streams_sptr self)"""
        return _blocks_swig1.vector_to_streams_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_to_streams_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_to_streams_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_to_streams_sptr self) -> int"""
        return _blocks_swig1.vector_to_streams_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_to_streams_sptr self) -> int"""
        return _blocks_swig1.vector_to_streams_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_to_streams_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_to_streams_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_to_streams_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_streams_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_to_streams_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_streams_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_to_streams_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_to_streams_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_to_streams_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_to_streams_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_to_streams_sptr self) -> long"""
        return _blocks_swig1.vector_to_streams_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_to_streams_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_to_streams_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_to_streams_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_to_streams_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_to_streams_sptr self) -> std::string"""
        return _blocks_swig1.vector_to_streams_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_to_streams_sptr self, std::string name)"""
        return _blocks_swig1.vector_to_streams_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_to_streams_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_to_streams_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_to_streams_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_to_streams_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_to_streams_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_to_streams_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_to_streams_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_to_streams_sptr_message_subscribers(self, *args, **kwargs)

vector_to_streams_sptr_swigregister = _blocks_swig1.vector_to_streams_sptr_swigregister
vector_to_streams_sptr_swigregister(vector_to_streams_sptr)

vector_to_streams_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_to_streams = vector_to_streams.make;

class vector_insert_b_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_insert_b)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_insert_b)> self) -> vector_insert_b_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_insert_b)> self, vector_insert_b p) -> vector_insert_b_sptr
        """
        this = _blocks_swig1.new_vector_insert_b_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_insert_b_sptr self) -> vector_insert_b"""
        return _blocks_swig1.vector_insert_b_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_insert_b_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_insert_b_sptr self, std::vector< unsigned char,std::allocator< unsigned char > > const & data, int periodicity, 
            int offset=0) -> vector_insert_b_sptr

        source of unsigned char's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_b_sptr_make(self, *args, **kwargs)

    def rewind(self):
        """rewind(vector_insert_b_sptr self)"""
        return _blocks_swig1.vector_insert_b_sptr_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_insert_b_sptr self, std::vector< unsigned char,std::allocator< unsigned char > > const & data)"""
        return _blocks_swig1.vector_insert_b_sptr_set_data(self, *args, **kwargs)

    def history(self):
        """history(vector_insert_b_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_insert_b_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_insert_b_sptr self, int which, int delay)
        declare_sample_delay(vector_insert_b_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_insert_b_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_insert_b_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_insert_b_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_insert_b_sptr self) -> int"""
        return _blocks_swig1.vector_insert_b_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_insert_b_sptr self) -> double"""
        return _blocks_swig1.vector_insert_b_sptr_relative_rate(self)

    def start(self):
        """start(vector_insert_b_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_b_sptr_start(self)

    def stop(self):
        """stop(vector_insert_b_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_b_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_insert_b_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_insert_b_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_insert_b_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_insert_b_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_insert_b_sptr self) -> int"""
        return _blocks_swig1.vector_insert_b_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_insert_b_sptr self, int m)"""
        return _blocks_swig1.vector_insert_b_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_insert_b_sptr self)"""
        return _blocks_swig1.vector_insert_b_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_insert_b_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_b_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_insert_b_sptr self, int m)"""
        return _blocks_swig1.vector_insert_b_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_insert_b_sptr self) -> int"""
        return _blocks_swig1.vector_insert_b_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_insert_b_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_b_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_insert_b_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_insert_b_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_insert_b_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_insert_b_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_b_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_insert_b_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_insert_b_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_insert_b_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_insert_b_sptr self, int which) -> float
        pc_input_buffers_full(vector_insert_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_b_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_insert_b_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_insert_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_b_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_insert_b_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_insert_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_b_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_insert_b_sptr self, int which) -> float
        pc_output_buffers_full(vector_insert_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_b_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_insert_b_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_insert_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_b_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_insert_b_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_insert_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_b_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_insert_b_sptr self) -> float"""
        return _blocks_swig1.vector_insert_b_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_insert_b_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_insert_b_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_insert_b_sptr self)"""
        return _blocks_swig1.vector_insert_b_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_insert_b_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_insert_b_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_insert_b_sptr self) -> int"""
        return _blocks_swig1.vector_insert_b_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_insert_b_sptr self) -> int"""
        return _blocks_swig1.vector_insert_b_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_insert_b_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_insert_b_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_insert_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_b_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_insert_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_b_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_insert_b_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_b_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_insert_b_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_b_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_insert_b_sptr self) -> long"""
        return _blocks_swig1.vector_insert_b_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_insert_b_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_insert_b_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_insert_b_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_insert_b_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_insert_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_b_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_insert_b_sptr self, std::string name)"""
        return _blocks_swig1.vector_insert_b_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_insert_b_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_insert_b_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_insert_b_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_b_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_insert_b_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_b_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_insert_b_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_b_sptr_message_subscribers(self, *args, **kwargs)

vector_insert_b_sptr_swigregister = _blocks_swig1.vector_insert_b_sptr_swigregister
vector_insert_b_sptr_swigregister(vector_insert_b_sptr)

vector_insert_b_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_insert_b = vector_insert_b.make;

class vector_insert_s_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_insert_s)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_insert_s)> self) -> vector_insert_s_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_insert_s)> self, vector_insert_s p) -> vector_insert_s_sptr
        """
        this = _blocks_swig1.new_vector_insert_s_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_insert_s_sptr self) -> vector_insert_s"""
        return _blocks_swig1.vector_insert_s_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_insert_s_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_insert_s_sptr self, std::vector< short,std::allocator< short > > const & data, int periodicity, int offset=0) -> vector_insert_s_sptr

        source of short's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_s_sptr_make(self, *args, **kwargs)

    def rewind(self):
        """rewind(vector_insert_s_sptr self)"""
        return _blocks_swig1.vector_insert_s_sptr_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_insert_s_sptr self, std::vector< short,std::allocator< short > > const & data)"""
        return _blocks_swig1.vector_insert_s_sptr_set_data(self, *args, **kwargs)

    def history(self):
        """history(vector_insert_s_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_insert_s_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_insert_s_sptr self, int which, int delay)
        declare_sample_delay(vector_insert_s_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_insert_s_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_insert_s_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_insert_s_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_insert_s_sptr self) -> int"""
        return _blocks_swig1.vector_insert_s_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_insert_s_sptr self) -> double"""
        return _blocks_swig1.vector_insert_s_sptr_relative_rate(self)

    def start(self):
        """start(vector_insert_s_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_s_sptr_start(self)

    def stop(self):
        """stop(vector_insert_s_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_s_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_insert_s_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_insert_s_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_insert_s_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_insert_s_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_insert_s_sptr self) -> int"""
        return _blocks_swig1.vector_insert_s_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_insert_s_sptr self, int m)"""
        return _blocks_swig1.vector_insert_s_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_insert_s_sptr self)"""
        return _blocks_swig1.vector_insert_s_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_insert_s_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_s_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_insert_s_sptr self, int m)"""
        return _blocks_swig1.vector_insert_s_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_insert_s_sptr self) -> int"""
        return _blocks_swig1.vector_insert_s_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_insert_s_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_s_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_insert_s_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_insert_s_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_insert_s_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_insert_s_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_s_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_insert_s_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_insert_s_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_insert_s_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_insert_s_sptr self, int which) -> float
        pc_input_buffers_full(vector_insert_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_s_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_insert_s_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_insert_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_s_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_insert_s_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_insert_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_s_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_insert_s_sptr self, int which) -> float
        pc_output_buffers_full(vector_insert_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_s_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_insert_s_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_insert_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_s_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_insert_s_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_insert_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_s_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_insert_s_sptr self) -> float"""
        return _blocks_swig1.vector_insert_s_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_insert_s_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_insert_s_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_insert_s_sptr self)"""
        return _blocks_swig1.vector_insert_s_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_insert_s_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_insert_s_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_insert_s_sptr self) -> int"""
        return _blocks_swig1.vector_insert_s_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_insert_s_sptr self) -> int"""
        return _blocks_swig1.vector_insert_s_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_insert_s_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_insert_s_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_insert_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_s_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_insert_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_s_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_insert_s_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_s_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_insert_s_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_s_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_insert_s_sptr self) -> long"""
        return _blocks_swig1.vector_insert_s_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_insert_s_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_insert_s_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_insert_s_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_insert_s_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_insert_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_s_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_insert_s_sptr self, std::string name)"""
        return _blocks_swig1.vector_insert_s_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_insert_s_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_insert_s_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_insert_s_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_s_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_insert_s_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_s_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_insert_s_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_s_sptr_message_subscribers(self, *args, **kwargs)

vector_insert_s_sptr_swigregister = _blocks_swig1.vector_insert_s_sptr_swigregister
vector_insert_s_sptr_swigregister(vector_insert_s_sptr)

vector_insert_s_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_insert_s = vector_insert_s.make;

class vector_insert_i_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_insert_i)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_insert_i)> self) -> vector_insert_i_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_insert_i)> self, vector_insert_i p) -> vector_insert_i_sptr
        """
        this = _blocks_swig1.new_vector_insert_i_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_insert_i_sptr self) -> vector_insert_i"""
        return _blocks_swig1.vector_insert_i_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_insert_i_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_insert_i_sptr self, std::vector< int,std::allocator< int > > const & data, int periodicity, int offset=0) -> vector_insert_i_sptr

        source of int's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_i_sptr_make(self, *args, **kwargs)

    def rewind(self):
        """rewind(vector_insert_i_sptr self)"""
        return _blocks_swig1.vector_insert_i_sptr_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_insert_i_sptr self, std::vector< int,std::allocator< int > > const & data)"""
        return _blocks_swig1.vector_insert_i_sptr_set_data(self, *args, **kwargs)

    def history(self):
        """history(vector_insert_i_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_insert_i_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_insert_i_sptr self, int which, int delay)
        declare_sample_delay(vector_insert_i_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_insert_i_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_insert_i_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_insert_i_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_insert_i_sptr self) -> int"""
        return _blocks_swig1.vector_insert_i_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_insert_i_sptr self) -> double"""
        return _blocks_swig1.vector_insert_i_sptr_relative_rate(self)

    def start(self):
        """start(vector_insert_i_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_i_sptr_start(self)

    def stop(self):
        """stop(vector_insert_i_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_i_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_insert_i_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_insert_i_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_insert_i_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_insert_i_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_insert_i_sptr self) -> int"""
        return _blocks_swig1.vector_insert_i_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_insert_i_sptr self, int m)"""
        return _blocks_swig1.vector_insert_i_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_insert_i_sptr self)"""
        return _blocks_swig1.vector_insert_i_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_insert_i_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_i_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_insert_i_sptr self, int m)"""
        return _blocks_swig1.vector_insert_i_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_insert_i_sptr self) -> int"""
        return _blocks_swig1.vector_insert_i_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_insert_i_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_i_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_insert_i_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_insert_i_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_insert_i_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_insert_i_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_i_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_insert_i_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_insert_i_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_insert_i_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_insert_i_sptr self, int which) -> float
        pc_input_buffers_full(vector_insert_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_i_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_insert_i_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_insert_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_i_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_insert_i_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_insert_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_i_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_insert_i_sptr self, int which) -> float
        pc_output_buffers_full(vector_insert_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_i_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_insert_i_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_insert_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_i_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_insert_i_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_insert_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_i_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_insert_i_sptr self) -> float"""
        return _blocks_swig1.vector_insert_i_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_insert_i_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_insert_i_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_insert_i_sptr self)"""
        return _blocks_swig1.vector_insert_i_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_insert_i_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_insert_i_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_insert_i_sptr self) -> int"""
        return _blocks_swig1.vector_insert_i_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_insert_i_sptr self) -> int"""
        return _blocks_swig1.vector_insert_i_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_insert_i_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_insert_i_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_insert_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_i_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_insert_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_i_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_insert_i_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_i_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_insert_i_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_i_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_insert_i_sptr self) -> long"""
        return _blocks_swig1.vector_insert_i_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_insert_i_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_insert_i_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_insert_i_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_insert_i_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_insert_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_i_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_insert_i_sptr self, std::string name)"""
        return _blocks_swig1.vector_insert_i_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_insert_i_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_insert_i_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_insert_i_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_i_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_insert_i_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_i_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_insert_i_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_i_sptr_message_subscribers(self, *args, **kwargs)

vector_insert_i_sptr_swigregister = _blocks_swig1.vector_insert_i_sptr_swigregister
vector_insert_i_sptr_swigregister(vector_insert_i_sptr)

vector_insert_i_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_insert_i = vector_insert_i.make;

class vector_insert_f_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_insert_f)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_insert_f)> self) -> vector_insert_f_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_insert_f)> self, vector_insert_f p) -> vector_insert_f_sptr
        """
        this = _blocks_swig1.new_vector_insert_f_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_insert_f_sptr self) -> vector_insert_f"""
        return _blocks_swig1.vector_insert_f_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_insert_f_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_insert_f_sptr self, pmt_vector_float data, int periodicity, int offset=0) -> vector_insert_f_sptr

        source of float's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_f_sptr_make(self, *args, **kwargs)

    def rewind(self):
        """rewind(vector_insert_f_sptr self)"""
        return _blocks_swig1.vector_insert_f_sptr_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_insert_f_sptr self, pmt_vector_float data)"""
        return _blocks_swig1.vector_insert_f_sptr_set_data(self, *args, **kwargs)

    def history(self):
        """history(vector_insert_f_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_insert_f_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_insert_f_sptr self, int which, int delay)
        declare_sample_delay(vector_insert_f_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_insert_f_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_insert_f_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_insert_f_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_insert_f_sptr self) -> int"""
        return _blocks_swig1.vector_insert_f_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_insert_f_sptr self) -> double"""
        return _blocks_swig1.vector_insert_f_sptr_relative_rate(self)

    def start(self):
        """start(vector_insert_f_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_f_sptr_start(self)

    def stop(self):
        """stop(vector_insert_f_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_f_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_insert_f_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_insert_f_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_insert_f_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_insert_f_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_insert_f_sptr self) -> int"""
        return _blocks_swig1.vector_insert_f_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_insert_f_sptr self, int m)"""
        return _blocks_swig1.vector_insert_f_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_insert_f_sptr self)"""
        return _blocks_swig1.vector_insert_f_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_insert_f_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_f_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_insert_f_sptr self, int m)"""
        return _blocks_swig1.vector_insert_f_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_insert_f_sptr self) -> int"""
        return _blocks_swig1.vector_insert_f_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_insert_f_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_f_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_insert_f_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_insert_f_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_insert_f_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_insert_f_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_f_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_insert_f_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_insert_f_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_insert_f_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_insert_f_sptr self, int which) -> float
        pc_input_buffers_full(vector_insert_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_f_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_insert_f_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_insert_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_f_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_insert_f_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_insert_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_f_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_insert_f_sptr self, int which) -> float
        pc_output_buffers_full(vector_insert_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_f_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_insert_f_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_insert_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_f_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_insert_f_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_insert_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_f_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_insert_f_sptr self) -> float"""
        return _blocks_swig1.vector_insert_f_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_insert_f_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_insert_f_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_insert_f_sptr self)"""
        return _blocks_swig1.vector_insert_f_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_insert_f_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_insert_f_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_insert_f_sptr self) -> int"""
        return _blocks_swig1.vector_insert_f_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_insert_f_sptr self) -> int"""
        return _blocks_swig1.vector_insert_f_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_insert_f_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_insert_f_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_insert_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_f_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_insert_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_f_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_insert_f_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_f_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_insert_f_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_f_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_insert_f_sptr self) -> long"""
        return _blocks_swig1.vector_insert_f_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_insert_f_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_insert_f_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_insert_f_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_insert_f_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_insert_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_f_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_insert_f_sptr self, std::string name)"""
        return _blocks_swig1.vector_insert_f_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_insert_f_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_insert_f_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_insert_f_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_f_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_insert_f_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_f_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_insert_f_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_f_sptr_message_subscribers(self, *args, **kwargs)

vector_insert_f_sptr_swigregister = _blocks_swig1.vector_insert_f_sptr_swigregister
vector_insert_f_sptr_swigregister(vector_insert_f_sptr)

vector_insert_f_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_insert_f = vector_insert_f.make;

class vector_insert_c_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_insert_c)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_insert_c)> self) -> vector_insert_c_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_insert_c)> self, vector_insert_c p) -> vector_insert_c_sptr
        """
        this = _blocks_swig1.new_vector_insert_c_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_insert_c_sptr self) -> vector_insert_c"""
        return _blocks_swig1.vector_insert_c_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_insert_c_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_insert_c_sptr self, pmt_vector_cfloat data, int periodicity, int offset=0) -> vector_insert_c_sptr

        source of gr_complex's that gets its data from a vector

        Constructor Specific Documentation:

        Make vector insert block.

        Args:
            data : vector of data to insert
            periodicity : number of samples between when to send
            offset : initial item offset of first insert
        """
        return _blocks_swig1.vector_insert_c_sptr_make(self, *args, **kwargs)

    def rewind(self):
        """rewind(vector_insert_c_sptr self)"""
        return _blocks_swig1.vector_insert_c_sptr_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_insert_c_sptr self, pmt_vector_cfloat data)"""
        return _blocks_swig1.vector_insert_c_sptr_set_data(self, *args, **kwargs)

    def history(self):
        """history(vector_insert_c_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_insert_c_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_insert_c_sptr self, int which, int delay)
        declare_sample_delay(vector_insert_c_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_insert_c_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_insert_c_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_insert_c_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_insert_c_sptr self) -> int"""
        return _blocks_swig1.vector_insert_c_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_insert_c_sptr self) -> double"""
        return _blocks_swig1.vector_insert_c_sptr_relative_rate(self)

    def start(self):
        """start(vector_insert_c_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_c_sptr_start(self)

    def stop(self):
        """stop(vector_insert_c_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_c_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_insert_c_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_insert_c_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_insert_c_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_insert_c_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_insert_c_sptr self) -> int"""
        return _blocks_swig1.vector_insert_c_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_insert_c_sptr self, int m)"""
        return _blocks_swig1.vector_insert_c_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_insert_c_sptr self)"""
        return _blocks_swig1.vector_insert_c_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_insert_c_sptr self) -> bool"""
        return _blocks_swig1.vector_insert_c_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_insert_c_sptr self, int m)"""
        return _blocks_swig1.vector_insert_c_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_insert_c_sptr self) -> int"""
        return _blocks_swig1.vector_insert_c_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_insert_c_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_c_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_insert_c_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_insert_c_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_insert_c_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_insert_c_sptr self, int i) -> long"""
        return _blocks_swig1.vector_insert_c_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_insert_c_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_insert_c_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_insert_c_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_insert_c_sptr self, int which) -> float
        pc_input_buffers_full(vector_insert_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_c_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_insert_c_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_insert_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_c_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_insert_c_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_insert_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_c_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_insert_c_sptr self, int which) -> float
        pc_output_buffers_full(vector_insert_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_c_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_insert_c_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_insert_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_c_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_insert_c_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_insert_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_insert_c_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_insert_c_sptr self) -> float"""
        return _blocks_swig1.vector_insert_c_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_insert_c_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_insert_c_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_insert_c_sptr self)"""
        return _blocks_swig1.vector_insert_c_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_insert_c_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_insert_c_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_insert_c_sptr self) -> int"""
        return _blocks_swig1.vector_insert_c_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_insert_c_sptr self) -> int"""
        return _blocks_swig1.vector_insert_c_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_insert_c_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_insert_c_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_insert_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_c_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_insert_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_c_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_insert_c_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_c_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_insert_c_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_insert_c_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_insert_c_sptr self) -> long"""
        return _blocks_swig1.vector_insert_c_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_insert_c_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_insert_c_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_insert_c_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_insert_c_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_insert_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_insert_c_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_insert_c_sptr self, std::string name)"""
        return _blocks_swig1.vector_insert_c_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_insert_c_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_insert_c_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_insert_c_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_c_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_insert_c_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_c_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_insert_c_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_insert_c_sptr_message_subscribers(self, *args, **kwargs)

vector_insert_c_sptr_swigregister = _blocks_swig1.vector_insert_c_sptr_swigregister
vector_insert_c_sptr_swigregister(vector_insert_c_sptr)

vector_insert_c_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_insert_c = vector_insert_c.make;

class vector_sink_b_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_sink_b)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_sink_b)> self) -> vector_sink_b_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_sink_b)> self, vector_sink_b p) -> vector_sink_b_sptr
        """
        this = _blocks_swig1.new_vector_sink_b_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_sink_b_sptr self) -> vector_sink_b"""
        return _blocks_swig1.vector_sink_b_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_sink_b_sptr
    __del__ = lambda self : None;
    def make(self, vlen=1, reserve_items=1024):
        """
        make(vector_sink_b_sptr self, int const vlen=1, int const reserve_items=1024) -> vector_sink_b_sptr

        unsigned char sink that writes to a vector

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_b_sptr_make(self, vlen, reserve_items)

    def reset(self):
        """
        reset(vector_sink_b_sptr self)

        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_b_sptr_reset(self)

    def data(self):
        """data(vector_sink_b_sptr self) -> std::vector< unsigned char,std::allocator< unsigned char > >"""
        return _blocks_swig1.vector_sink_b_sptr_data(self)

    def tags(self):
        """tags(vector_sink_b_sptr self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_b_sptr_tags(self)

    def history(self):
        """history(vector_sink_b_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_sink_b_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_sink_b_sptr self, int which, int delay)
        declare_sample_delay(vector_sink_b_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_sink_b_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_sink_b_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_sink_b_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_sink_b_sptr self) -> int"""
        return _blocks_swig1.vector_sink_b_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_sink_b_sptr self) -> double"""
        return _blocks_swig1.vector_sink_b_sptr_relative_rate(self)

    def start(self):
        """start(vector_sink_b_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_b_sptr_start(self)

    def stop(self):
        """stop(vector_sink_b_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_b_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_sink_b_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_sink_b_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_sink_b_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_sink_b_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_sink_b_sptr self) -> int"""
        return _blocks_swig1.vector_sink_b_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_sink_b_sptr self, int m)"""
        return _blocks_swig1.vector_sink_b_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_sink_b_sptr self)"""
        return _blocks_swig1.vector_sink_b_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_sink_b_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_b_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_sink_b_sptr self, int m)"""
        return _blocks_swig1.vector_sink_b_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_sink_b_sptr self) -> int"""
        return _blocks_swig1.vector_sink_b_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_sink_b_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_b_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_sink_b_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_sink_b_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_sink_b_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_sink_b_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_b_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_sink_b_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_sink_b_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_sink_b_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_sink_b_sptr self, int which) -> float
        pc_input_buffers_full(vector_sink_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_b_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_sink_b_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_sink_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_b_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_sink_b_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_sink_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_b_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_sink_b_sptr self, int which) -> float
        pc_output_buffers_full(vector_sink_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_b_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_sink_b_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_sink_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_b_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_sink_b_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_sink_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_b_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_sink_b_sptr self) -> float"""
        return _blocks_swig1.vector_sink_b_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_sink_b_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_sink_b_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_sink_b_sptr self)"""
        return _blocks_swig1.vector_sink_b_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_sink_b_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_sink_b_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_sink_b_sptr self) -> int"""
        return _blocks_swig1.vector_sink_b_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_sink_b_sptr self) -> int"""
        return _blocks_swig1.vector_sink_b_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_sink_b_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_sink_b_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_sink_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_b_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_sink_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_b_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_sink_b_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_b_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_sink_b_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_b_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_sink_b_sptr self) -> long"""
        return _blocks_swig1.vector_sink_b_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_sink_b_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_sink_b_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_sink_b_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_sink_b_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_sink_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_b_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_sink_b_sptr self, std::string name)"""
        return _blocks_swig1.vector_sink_b_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_sink_b_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_sink_b_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_sink_b_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_b_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_sink_b_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_b_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_sink_b_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_b_sptr_message_subscribers(self, *args, **kwargs)

vector_sink_b_sptr_swigregister = _blocks_swig1.vector_sink_b_sptr_swigregister
vector_sink_b_sptr_swigregister(vector_sink_b_sptr)

vector_sink_b_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_sink_b = vector_sink_b.make;

class vector_sink_s_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_sink_s)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_sink_s)> self) -> vector_sink_s_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_sink_s)> self, vector_sink_s p) -> vector_sink_s_sptr
        """
        this = _blocks_swig1.new_vector_sink_s_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_sink_s_sptr self) -> vector_sink_s"""
        return _blocks_swig1.vector_sink_s_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_sink_s_sptr
    __del__ = lambda self : None;
    def make(self, vlen=1, reserve_items=1024):
        """
        make(vector_sink_s_sptr self, int const vlen=1, int const reserve_items=1024) -> vector_sink_s_sptr

        short sink that writes to a vector

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_s_sptr_make(self, vlen, reserve_items)

    def reset(self):
        """
        reset(vector_sink_s_sptr self)

        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_s_sptr_reset(self)

    def data(self):
        """data(vector_sink_s_sptr self) -> std::vector< short,std::allocator< short > >"""
        return _blocks_swig1.vector_sink_s_sptr_data(self)

    def tags(self):
        """tags(vector_sink_s_sptr self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_s_sptr_tags(self)

    def history(self):
        """history(vector_sink_s_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_sink_s_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_sink_s_sptr self, int which, int delay)
        declare_sample_delay(vector_sink_s_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_sink_s_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_sink_s_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_sink_s_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_sink_s_sptr self) -> int"""
        return _blocks_swig1.vector_sink_s_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_sink_s_sptr self) -> double"""
        return _blocks_swig1.vector_sink_s_sptr_relative_rate(self)

    def start(self):
        """start(vector_sink_s_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_s_sptr_start(self)

    def stop(self):
        """stop(vector_sink_s_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_s_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_sink_s_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_sink_s_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_sink_s_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_sink_s_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_sink_s_sptr self) -> int"""
        return _blocks_swig1.vector_sink_s_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_sink_s_sptr self, int m)"""
        return _blocks_swig1.vector_sink_s_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_sink_s_sptr self)"""
        return _blocks_swig1.vector_sink_s_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_sink_s_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_s_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_sink_s_sptr self, int m)"""
        return _blocks_swig1.vector_sink_s_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_sink_s_sptr self) -> int"""
        return _blocks_swig1.vector_sink_s_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_sink_s_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_s_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_sink_s_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_sink_s_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_sink_s_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_sink_s_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_s_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_sink_s_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_sink_s_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_sink_s_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_sink_s_sptr self, int which) -> float
        pc_input_buffers_full(vector_sink_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_s_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_sink_s_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_sink_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_s_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_sink_s_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_sink_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_s_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_sink_s_sptr self, int which) -> float
        pc_output_buffers_full(vector_sink_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_s_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_sink_s_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_sink_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_s_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_sink_s_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_sink_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_s_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_sink_s_sptr self) -> float"""
        return _blocks_swig1.vector_sink_s_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_sink_s_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_sink_s_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_sink_s_sptr self)"""
        return _blocks_swig1.vector_sink_s_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_sink_s_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_sink_s_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_sink_s_sptr self) -> int"""
        return _blocks_swig1.vector_sink_s_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_sink_s_sptr self) -> int"""
        return _blocks_swig1.vector_sink_s_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_sink_s_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_sink_s_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_sink_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_s_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_sink_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_s_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_sink_s_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_s_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_sink_s_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_s_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_sink_s_sptr self) -> long"""
        return _blocks_swig1.vector_sink_s_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_sink_s_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_sink_s_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_sink_s_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_sink_s_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_sink_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_s_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_sink_s_sptr self, std::string name)"""
        return _blocks_swig1.vector_sink_s_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_sink_s_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_sink_s_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_sink_s_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_s_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_sink_s_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_s_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_sink_s_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_s_sptr_message_subscribers(self, *args, **kwargs)

vector_sink_s_sptr_swigregister = _blocks_swig1.vector_sink_s_sptr_swigregister
vector_sink_s_sptr_swigregister(vector_sink_s_sptr)

vector_sink_s_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_sink_s = vector_sink_s.make;

class vector_sink_i_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_sink_i)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_sink_i)> self) -> vector_sink_i_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_sink_i)> self, vector_sink_i p) -> vector_sink_i_sptr
        """
        this = _blocks_swig1.new_vector_sink_i_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_sink_i_sptr self) -> vector_sink_i"""
        return _blocks_swig1.vector_sink_i_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_sink_i_sptr
    __del__ = lambda self : None;
    def make(self, vlen=1, reserve_items=1024):
        """
        make(vector_sink_i_sptr self, int const vlen=1, int const reserve_items=1024) -> vector_sink_i_sptr

        int sink that writes to a vector

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_i_sptr_make(self, vlen, reserve_items)

    def reset(self):
        """
        reset(vector_sink_i_sptr self)

        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_i_sptr_reset(self)

    def data(self):
        """data(vector_sink_i_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_sink_i_sptr_data(self)

    def tags(self):
        """tags(vector_sink_i_sptr self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_i_sptr_tags(self)

    def history(self):
        """history(vector_sink_i_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_sink_i_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_sink_i_sptr self, int which, int delay)
        declare_sample_delay(vector_sink_i_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_sink_i_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_sink_i_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_sink_i_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_sink_i_sptr self) -> int"""
        return _blocks_swig1.vector_sink_i_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_sink_i_sptr self) -> double"""
        return _blocks_swig1.vector_sink_i_sptr_relative_rate(self)

    def start(self):
        """start(vector_sink_i_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_i_sptr_start(self)

    def stop(self):
        """stop(vector_sink_i_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_i_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_sink_i_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_sink_i_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_sink_i_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_sink_i_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_sink_i_sptr self) -> int"""
        return _blocks_swig1.vector_sink_i_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_sink_i_sptr self, int m)"""
        return _blocks_swig1.vector_sink_i_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_sink_i_sptr self)"""
        return _blocks_swig1.vector_sink_i_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_sink_i_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_i_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_sink_i_sptr self, int m)"""
        return _blocks_swig1.vector_sink_i_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_sink_i_sptr self) -> int"""
        return _blocks_swig1.vector_sink_i_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_sink_i_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_i_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_sink_i_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_sink_i_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_sink_i_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_sink_i_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_i_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_sink_i_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_sink_i_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_sink_i_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_sink_i_sptr self, int which) -> float
        pc_input_buffers_full(vector_sink_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_i_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_sink_i_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_sink_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_i_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_sink_i_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_sink_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_i_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_sink_i_sptr self, int which) -> float
        pc_output_buffers_full(vector_sink_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_i_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_sink_i_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_sink_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_i_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_sink_i_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_sink_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_i_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_sink_i_sptr self) -> float"""
        return _blocks_swig1.vector_sink_i_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_sink_i_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_sink_i_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_sink_i_sptr self)"""
        return _blocks_swig1.vector_sink_i_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_sink_i_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_sink_i_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_sink_i_sptr self) -> int"""
        return _blocks_swig1.vector_sink_i_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_sink_i_sptr self) -> int"""
        return _blocks_swig1.vector_sink_i_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_sink_i_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_sink_i_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_sink_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_i_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_sink_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_i_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_sink_i_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_i_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_sink_i_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_i_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_sink_i_sptr self) -> long"""
        return _blocks_swig1.vector_sink_i_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_sink_i_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_sink_i_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_sink_i_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_sink_i_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_sink_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_i_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_sink_i_sptr self, std::string name)"""
        return _blocks_swig1.vector_sink_i_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_sink_i_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_sink_i_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_sink_i_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_i_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_sink_i_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_i_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_sink_i_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_i_sptr_message_subscribers(self, *args, **kwargs)

vector_sink_i_sptr_swigregister = _blocks_swig1.vector_sink_i_sptr_swigregister
vector_sink_i_sptr_swigregister(vector_sink_i_sptr)

vector_sink_i_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_sink_i = vector_sink_i.make;

class vector_sink_f_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_sink_f)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_sink_f)> self) -> vector_sink_f_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_sink_f)> self, vector_sink_f p) -> vector_sink_f_sptr
        """
        this = _blocks_swig1.new_vector_sink_f_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_sink_f_sptr self) -> vector_sink_f"""
        return _blocks_swig1.vector_sink_f_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_sink_f_sptr
    __del__ = lambda self : None;
    def make(self, vlen=1, reserve_items=1024):
        """
        make(vector_sink_f_sptr self, int const vlen=1, int const reserve_items=1024) -> vector_sink_f_sptr

        float sink that writes to a vector

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_f_sptr_make(self, vlen, reserve_items)

    def reset(self):
        """
        reset(vector_sink_f_sptr self)

        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_f_sptr_reset(self)

    def data(self):
        """data(vector_sink_f_sptr self) -> pmt_vector_float"""
        return _blocks_swig1.vector_sink_f_sptr_data(self)

    def tags(self):
        """tags(vector_sink_f_sptr self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_f_sptr_tags(self)

    def history(self):
        """history(vector_sink_f_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_sink_f_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_sink_f_sptr self, int which, int delay)
        declare_sample_delay(vector_sink_f_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_sink_f_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_sink_f_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_sink_f_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_sink_f_sptr self) -> int"""
        return _blocks_swig1.vector_sink_f_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_sink_f_sptr self) -> double"""
        return _blocks_swig1.vector_sink_f_sptr_relative_rate(self)

    def start(self):
        """start(vector_sink_f_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_f_sptr_start(self)

    def stop(self):
        """stop(vector_sink_f_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_f_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_sink_f_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_sink_f_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_sink_f_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_sink_f_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_sink_f_sptr self) -> int"""
        return _blocks_swig1.vector_sink_f_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_sink_f_sptr self, int m)"""
        return _blocks_swig1.vector_sink_f_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_sink_f_sptr self)"""
        return _blocks_swig1.vector_sink_f_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_sink_f_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_f_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_sink_f_sptr self, int m)"""
        return _blocks_swig1.vector_sink_f_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_sink_f_sptr self) -> int"""
        return _blocks_swig1.vector_sink_f_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_sink_f_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_f_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_sink_f_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_sink_f_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_sink_f_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_sink_f_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_f_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_sink_f_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_sink_f_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_sink_f_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_sink_f_sptr self, int which) -> float
        pc_input_buffers_full(vector_sink_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_f_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_sink_f_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_sink_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_f_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_sink_f_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_sink_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_f_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_sink_f_sptr self, int which) -> float
        pc_output_buffers_full(vector_sink_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_f_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_sink_f_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_sink_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_f_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_sink_f_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_sink_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_f_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_sink_f_sptr self) -> float"""
        return _blocks_swig1.vector_sink_f_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_sink_f_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_sink_f_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_sink_f_sptr self)"""
        return _blocks_swig1.vector_sink_f_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_sink_f_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_sink_f_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_sink_f_sptr self) -> int"""
        return _blocks_swig1.vector_sink_f_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_sink_f_sptr self) -> int"""
        return _blocks_swig1.vector_sink_f_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_sink_f_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_sink_f_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_sink_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_f_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_sink_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_f_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_sink_f_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_f_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_sink_f_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_f_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_sink_f_sptr self) -> long"""
        return _blocks_swig1.vector_sink_f_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_sink_f_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_sink_f_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_sink_f_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_sink_f_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_sink_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_f_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_sink_f_sptr self, std::string name)"""
        return _blocks_swig1.vector_sink_f_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_sink_f_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_sink_f_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_sink_f_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_f_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_sink_f_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_f_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_sink_f_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_f_sptr_message_subscribers(self, *args, **kwargs)

vector_sink_f_sptr_swigregister = _blocks_swig1.vector_sink_f_sptr_swigregister
vector_sink_f_sptr_swigregister(vector_sink_f_sptr)

vector_sink_f_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_sink_f = vector_sink_f.make;

class vector_sink_c_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_sink_c)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_sink_c)> self) -> vector_sink_c_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_sink_c)> self, vector_sink_c p) -> vector_sink_c_sptr
        """
        this = _blocks_swig1.new_vector_sink_c_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_sink_c_sptr self) -> vector_sink_c"""
        return _blocks_swig1.vector_sink_c_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_sink_c_sptr
    __del__ = lambda self : None;
    def make(self, vlen=1, reserve_items=1024):
        """
        make(vector_sink_c_sptr self, int const vlen=1, int const reserve_items=1024) -> vector_sink_c_sptr

        gr_complex sink that writes to a vector

        Constructor Specific Documentation:

        Make a new instance of the vector source, and return a shared pointer to it.

        Args:
            vlen : length of vector items
            reserve_items : reserve space in the internal storage for this many items; the internal storage will still grow to accommodate more item if necessary, but setting this to a realistic value can avoid memory allocations during runtime, especially if you know a priori how many items you're going to store.
        """
        return _blocks_swig1.vector_sink_c_sptr_make(self, vlen, reserve_items)

    def reset(self):
        """
        reset(vector_sink_c_sptr self)

        Clear the data and tags containers.
        """
        return _blocks_swig1.vector_sink_c_sptr_reset(self)

    def data(self):
        """data(vector_sink_c_sptr self) -> pmt_vector_cfloat"""
        return _blocks_swig1.vector_sink_c_sptr_data(self)

    def tags(self):
        """tags(vector_sink_c_sptr self) -> tags_vector_t"""
        return _blocks_swig1.vector_sink_c_sptr_tags(self)

    def history(self):
        """history(vector_sink_c_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_sink_c_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_sink_c_sptr self, int which, int delay)
        declare_sample_delay(vector_sink_c_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_sink_c_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_sink_c_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_sink_c_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_sink_c_sptr self) -> int"""
        return _blocks_swig1.vector_sink_c_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_sink_c_sptr self) -> double"""
        return _blocks_swig1.vector_sink_c_sptr_relative_rate(self)

    def start(self):
        """start(vector_sink_c_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_c_sptr_start(self)

    def stop(self):
        """stop(vector_sink_c_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_c_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_sink_c_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_sink_c_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_sink_c_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_sink_c_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_sink_c_sptr self) -> int"""
        return _blocks_swig1.vector_sink_c_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_sink_c_sptr self, int m)"""
        return _blocks_swig1.vector_sink_c_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_sink_c_sptr self)"""
        return _blocks_swig1.vector_sink_c_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_sink_c_sptr self) -> bool"""
        return _blocks_swig1.vector_sink_c_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_sink_c_sptr self, int m)"""
        return _blocks_swig1.vector_sink_c_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_sink_c_sptr self) -> int"""
        return _blocks_swig1.vector_sink_c_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_sink_c_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_c_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_sink_c_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_sink_c_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_sink_c_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_sink_c_sptr self, int i) -> long"""
        return _blocks_swig1.vector_sink_c_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_sink_c_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_sink_c_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_sink_c_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_sink_c_sptr self, int which) -> float
        pc_input_buffers_full(vector_sink_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_c_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_sink_c_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_sink_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_c_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_sink_c_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_sink_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_c_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_sink_c_sptr self, int which) -> float
        pc_output_buffers_full(vector_sink_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_c_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_sink_c_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_sink_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_c_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_sink_c_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_sink_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_sink_c_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_sink_c_sptr self) -> float"""
        return _blocks_swig1.vector_sink_c_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_sink_c_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_sink_c_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_sink_c_sptr self)"""
        return _blocks_swig1.vector_sink_c_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_sink_c_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_sink_c_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_sink_c_sptr self) -> int"""
        return _blocks_swig1.vector_sink_c_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_sink_c_sptr self) -> int"""
        return _blocks_swig1.vector_sink_c_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_sink_c_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_sink_c_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_sink_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_c_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_sink_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_c_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_sink_c_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_c_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_sink_c_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_sink_c_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_sink_c_sptr self) -> long"""
        return _blocks_swig1.vector_sink_c_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_sink_c_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_sink_c_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_sink_c_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_sink_c_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_sink_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_sink_c_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_sink_c_sptr self, std::string name)"""
        return _blocks_swig1.vector_sink_c_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_sink_c_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_sink_c_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_sink_c_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_c_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_sink_c_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_c_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_sink_c_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_sink_c_sptr_message_subscribers(self, *args, **kwargs)

vector_sink_c_sptr_swigregister = _blocks_swig1.vector_sink_c_sptr_swigregister
vector_sink_c_sptr_swigregister(vector_sink_c_sptr)

vector_sink_c_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_sink_c = vector_sink_c.make;

class vector_source_b_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_source_b)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_source_b)> self) -> vector_source_b_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_source_b)> self, vector_source_b p) -> vector_source_b_sptr
        """
        this = _blocks_swig1.new_vector_source_b_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_source_b_sptr self) -> vector_source_b"""
        return _blocks_swig1.vector_source_b_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_source_b_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_source_b_sptr self, std::vector< unsigned char,std::allocator< unsigned char > > const & data, bool repeat=False, 
            int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_b_sptr

        Source that streams unsigned char items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<unsigned char>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_b_sptr_make(self, *args, **kwargs)

    def rewind(self):
        """rewind(vector_source_b_sptr self)"""
        return _blocks_swig1.vector_source_b_sptr_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_source_b_sptr self, std::vector< unsigned char,std::allocator< unsigned char > > const & data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_b_sptr_set_data(self, *args, **kwargs)

    def set_repeat(self, *args, **kwargs):
        """set_repeat(vector_source_b_sptr self, bool repeat)"""
        return _blocks_swig1.vector_source_b_sptr_set_repeat(self, *args, **kwargs)

    def history(self):
        """history(vector_source_b_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_source_b_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_source_b_sptr self, int which, int delay)
        declare_sample_delay(vector_source_b_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_source_b_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_source_b_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_source_b_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_source_b_sptr self) -> int"""
        return _blocks_swig1.vector_source_b_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_source_b_sptr self) -> double"""
        return _blocks_swig1.vector_source_b_sptr_relative_rate(self)

    def start(self):
        """start(vector_source_b_sptr self) -> bool"""
        return _blocks_swig1.vector_source_b_sptr_start(self)

    def stop(self):
        """stop(vector_source_b_sptr self) -> bool"""
        return _blocks_swig1.vector_source_b_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_source_b_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_source_b_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_source_b_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_source_b_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_source_b_sptr self) -> int"""
        return _blocks_swig1.vector_source_b_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_source_b_sptr self, int m)"""
        return _blocks_swig1.vector_source_b_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_source_b_sptr self)"""
        return _blocks_swig1.vector_source_b_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_source_b_sptr self) -> bool"""
        return _blocks_swig1.vector_source_b_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_source_b_sptr self, int m)"""
        return _blocks_swig1.vector_source_b_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_source_b_sptr self) -> int"""
        return _blocks_swig1.vector_source_b_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_source_b_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_b_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_source_b_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_source_b_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_source_b_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_source_b_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_b_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_source_b_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_source_b_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_source_b_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_source_b_sptr self, int which) -> float
        pc_input_buffers_full(vector_source_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_b_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_source_b_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_source_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_b_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_source_b_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_source_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_b_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_source_b_sptr self, int which) -> float
        pc_output_buffers_full(vector_source_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_b_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_source_b_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_source_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_b_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_source_b_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_source_b_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_b_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_source_b_sptr self) -> float"""
        return _blocks_swig1.vector_source_b_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_source_b_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_source_b_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_source_b_sptr self)"""
        return _blocks_swig1.vector_source_b_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_source_b_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_source_b_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_source_b_sptr self) -> int"""
        return _blocks_swig1.vector_source_b_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_source_b_sptr self) -> int"""
        return _blocks_swig1.vector_source_b_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_source_b_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_source_b_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_source_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_b_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_source_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_b_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_source_b_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_b_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_source_b_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_b_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_source_b_sptr self) -> long"""
        return _blocks_swig1.vector_source_b_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_source_b_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_source_b_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_source_b_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_source_b_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_source_b_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_b_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_source_b_sptr self, std::string name)"""
        return _blocks_swig1.vector_source_b_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_source_b_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_source_b_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_source_b_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_b_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_source_b_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_b_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_source_b_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_b_sptr_message_subscribers(self, *args, **kwargs)

vector_source_b_sptr_swigregister = _blocks_swig1.vector_source_b_sptr_swigregister
vector_source_b_sptr_swigregister(vector_source_b_sptr)

vector_source_b_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_source_b = vector_source_b.make;

class vector_source_s_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_source_s)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_source_s)> self) -> vector_source_s_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_source_s)> self, vector_source_s p) -> vector_source_s_sptr
        """
        this = _blocks_swig1.new_vector_source_s_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_source_s_sptr self) -> vector_source_s"""
        return _blocks_swig1.vector_source_s_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_source_s_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_source_s_sptr self, std::vector< short,std::allocator< short > > const & data, bool repeat=False, int vlen=1, 
            tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_s_sptr

        Source that streams short items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<short>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_s_sptr_make(self, *args, **kwargs)

    def rewind(self):
        """rewind(vector_source_s_sptr self)"""
        return _blocks_swig1.vector_source_s_sptr_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_source_s_sptr self, std::vector< short,std::allocator< short > > const & data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_s_sptr_set_data(self, *args, **kwargs)

    def set_repeat(self, *args, **kwargs):
        """set_repeat(vector_source_s_sptr self, bool repeat)"""
        return _blocks_swig1.vector_source_s_sptr_set_repeat(self, *args, **kwargs)

    def history(self):
        """history(vector_source_s_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_source_s_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_source_s_sptr self, int which, int delay)
        declare_sample_delay(vector_source_s_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_source_s_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_source_s_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_source_s_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_source_s_sptr self) -> int"""
        return _blocks_swig1.vector_source_s_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_source_s_sptr self) -> double"""
        return _blocks_swig1.vector_source_s_sptr_relative_rate(self)

    def start(self):
        """start(vector_source_s_sptr self) -> bool"""
        return _blocks_swig1.vector_source_s_sptr_start(self)

    def stop(self):
        """stop(vector_source_s_sptr self) -> bool"""
        return _blocks_swig1.vector_source_s_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_source_s_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_source_s_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_source_s_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_source_s_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_source_s_sptr self) -> int"""
        return _blocks_swig1.vector_source_s_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_source_s_sptr self, int m)"""
        return _blocks_swig1.vector_source_s_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_source_s_sptr self)"""
        return _blocks_swig1.vector_source_s_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_source_s_sptr self) -> bool"""
        return _blocks_swig1.vector_source_s_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_source_s_sptr self, int m)"""
        return _blocks_swig1.vector_source_s_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_source_s_sptr self) -> int"""
        return _blocks_swig1.vector_source_s_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_source_s_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_s_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_source_s_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_source_s_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_source_s_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_source_s_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_s_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_source_s_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_source_s_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_source_s_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_source_s_sptr self, int which) -> float
        pc_input_buffers_full(vector_source_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_s_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_source_s_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_source_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_s_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_source_s_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_source_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_s_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_source_s_sptr self, int which) -> float
        pc_output_buffers_full(vector_source_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_s_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_source_s_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_source_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_s_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_source_s_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_source_s_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_s_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_source_s_sptr self) -> float"""
        return _blocks_swig1.vector_source_s_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_source_s_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_source_s_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_source_s_sptr self)"""
        return _blocks_swig1.vector_source_s_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_source_s_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_source_s_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_source_s_sptr self) -> int"""
        return _blocks_swig1.vector_source_s_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_source_s_sptr self) -> int"""
        return _blocks_swig1.vector_source_s_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_source_s_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_source_s_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_source_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_s_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_source_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_s_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_source_s_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_s_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_source_s_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_s_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_source_s_sptr self) -> long"""
        return _blocks_swig1.vector_source_s_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_source_s_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_source_s_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_source_s_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_source_s_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_source_s_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_s_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_source_s_sptr self, std::string name)"""
        return _blocks_swig1.vector_source_s_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_source_s_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_source_s_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_source_s_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_s_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_source_s_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_s_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_source_s_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_s_sptr_message_subscribers(self, *args, **kwargs)

vector_source_s_sptr_swigregister = _blocks_swig1.vector_source_s_sptr_swigregister
vector_source_s_sptr_swigregister(vector_source_s_sptr)

vector_source_s_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_source_s = vector_source_s.make;

class vector_source_i_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_source_i)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_source_i)> self) -> vector_source_i_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_source_i)> self, vector_source_i p) -> vector_source_i_sptr
        """
        this = _blocks_swig1.new_vector_source_i_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_source_i_sptr self) -> vector_source_i"""
        return _blocks_swig1.vector_source_i_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_source_i_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_source_i_sptr self, std::vector< int,std::allocator< int > > const & data, bool repeat=False, int vlen=1, 
            tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_i_sptr

        Source that streams int items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<int>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_i_sptr_make(self, *args, **kwargs)

    def rewind(self):
        """rewind(vector_source_i_sptr self)"""
        return _blocks_swig1.vector_source_i_sptr_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_source_i_sptr self, std::vector< int,std::allocator< int > > const & data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_i_sptr_set_data(self, *args, **kwargs)

    def set_repeat(self, *args, **kwargs):
        """set_repeat(vector_source_i_sptr self, bool repeat)"""
        return _blocks_swig1.vector_source_i_sptr_set_repeat(self, *args, **kwargs)

    def history(self):
        """history(vector_source_i_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_source_i_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_source_i_sptr self, int which, int delay)
        declare_sample_delay(vector_source_i_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_source_i_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_source_i_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_source_i_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_source_i_sptr self) -> int"""
        return _blocks_swig1.vector_source_i_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_source_i_sptr self) -> double"""
        return _blocks_swig1.vector_source_i_sptr_relative_rate(self)

    def start(self):
        """start(vector_source_i_sptr self) -> bool"""
        return _blocks_swig1.vector_source_i_sptr_start(self)

    def stop(self):
        """stop(vector_source_i_sptr self) -> bool"""
        return _blocks_swig1.vector_source_i_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_source_i_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_source_i_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_source_i_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_source_i_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_source_i_sptr self) -> int"""
        return _blocks_swig1.vector_source_i_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_source_i_sptr self, int m)"""
        return _blocks_swig1.vector_source_i_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_source_i_sptr self)"""
        return _blocks_swig1.vector_source_i_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_source_i_sptr self) -> bool"""
        return _blocks_swig1.vector_source_i_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_source_i_sptr self, int m)"""
        return _blocks_swig1.vector_source_i_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_source_i_sptr self) -> int"""
        return _blocks_swig1.vector_source_i_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_source_i_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_i_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_source_i_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_source_i_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_source_i_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_source_i_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_i_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_source_i_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_source_i_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_source_i_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_source_i_sptr self, int which) -> float
        pc_input_buffers_full(vector_source_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_i_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_source_i_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_source_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_i_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_source_i_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_source_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_i_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_source_i_sptr self, int which) -> float
        pc_output_buffers_full(vector_source_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_i_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_source_i_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_source_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_i_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_source_i_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_source_i_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_i_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_source_i_sptr self) -> float"""
        return _blocks_swig1.vector_source_i_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_source_i_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_source_i_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_source_i_sptr self)"""
        return _blocks_swig1.vector_source_i_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_source_i_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_source_i_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_source_i_sptr self) -> int"""
        return _blocks_swig1.vector_source_i_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_source_i_sptr self) -> int"""
        return _blocks_swig1.vector_source_i_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_source_i_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_source_i_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_source_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_i_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_source_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_i_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_source_i_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_i_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_source_i_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_i_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_source_i_sptr self) -> long"""
        return _blocks_swig1.vector_source_i_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_source_i_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_source_i_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_source_i_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_source_i_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_source_i_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_i_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_source_i_sptr self, std::string name)"""
        return _blocks_swig1.vector_source_i_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_source_i_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_source_i_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_source_i_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_i_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_source_i_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_i_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_source_i_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_i_sptr_message_subscribers(self, *args, **kwargs)

vector_source_i_sptr_swigregister = _blocks_swig1.vector_source_i_sptr_swigregister
vector_source_i_sptr_swigregister(vector_source_i_sptr)

vector_source_i_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_source_i = vector_source_i.make;

class vector_source_f_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_source_f)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_source_f)> self) -> vector_source_f_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_source_f)> self, vector_source_f p) -> vector_source_f_sptr
        """
        this = _blocks_swig1.new_vector_source_f_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_source_f_sptr self) -> vector_source_f"""
        return _blocks_swig1.vector_source_f_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_source_f_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_source_f_sptr self, pmt_vector_float data, bool repeat=False, int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_f_sptr

        Source that streams float items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<float>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_f_sptr_make(self, *args, **kwargs)

    def rewind(self):
        """rewind(vector_source_f_sptr self)"""
        return _blocks_swig1.vector_source_f_sptr_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_source_f_sptr self, pmt_vector_float data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_f_sptr_set_data(self, *args, **kwargs)

    def set_repeat(self, *args, **kwargs):
        """set_repeat(vector_source_f_sptr self, bool repeat)"""
        return _blocks_swig1.vector_source_f_sptr_set_repeat(self, *args, **kwargs)

    def history(self):
        """history(vector_source_f_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_source_f_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_source_f_sptr self, int which, int delay)
        declare_sample_delay(vector_source_f_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_source_f_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_source_f_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_source_f_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_source_f_sptr self) -> int"""
        return _blocks_swig1.vector_source_f_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_source_f_sptr self) -> double"""
        return _blocks_swig1.vector_source_f_sptr_relative_rate(self)

    def start(self):
        """start(vector_source_f_sptr self) -> bool"""
        return _blocks_swig1.vector_source_f_sptr_start(self)

    def stop(self):
        """stop(vector_source_f_sptr self) -> bool"""
        return _blocks_swig1.vector_source_f_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_source_f_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_source_f_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_source_f_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_source_f_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_source_f_sptr self) -> int"""
        return _blocks_swig1.vector_source_f_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_source_f_sptr self, int m)"""
        return _blocks_swig1.vector_source_f_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_source_f_sptr self)"""
        return _blocks_swig1.vector_source_f_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_source_f_sptr self) -> bool"""
        return _blocks_swig1.vector_source_f_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_source_f_sptr self, int m)"""
        return _blocks_swig1.vector_source_f_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_source_f_sptr self) -> int"""
        return _blocks_swig1.vector_source_f_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_source_f_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_f_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_source_f_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_source_f_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_source_f_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_source_f_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_f_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_source_f_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_source_f_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_source_f_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_source_f_sptr self, int which) -> float
        pc_input_buffers_full(vector_source_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_f_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_source_f_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_source_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_f_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_source_f_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_source_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_f_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_source_f_sptr self, int which) -> float
        pc_output_buffers_full(vector_source_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_f_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_source_f_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_source_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_f_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_source_f_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_source_f_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_f_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_source_f_sptr self) -> float"""
        return _blocks_swig1.vector_source_f_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_source_f_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_source_f_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_source_f_sptr self)"""
        return _blocks_swig1.vector_source_f_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_source_f_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_source_f_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_source_f_sptr self) -> int"""
        return _blocks_swig1.vector_source_f_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_source_f_sptr self) -> int"""
        return _blocks_swig1.vector_source_f_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_source_f_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_source_f_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_source_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_f_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_source_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_f_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_source_f_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_f_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_source_f_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_f_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_source_f_sptr self) -> long"""
        return _blocks_swig1.vector_source_f_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_source_f_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_source_f_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_source_f_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_source_f_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_source_f_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_f_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_source_f_sptr self, std::string name)"""
        return _blocks_swig1.vector_source_f_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_source_f_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_source_f_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_source_f_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_f_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_source_f_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_f_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_source_f_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_f_sptr_message_subscribers(self, *args, **kwargs)

vector_source_f_sptr_swigregister = _blocks_swig1.vector_source_f_sptr_swigregister
vector_source_f_sptr_swigregister(vector_source_f_sptr)

vector_source_f_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_source_f = vector_source_f.make;

class vector_source_c_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::vector_source_c)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::vector_source_c)> self) -> vector_source_c_sptr
        __init__(boost::shared_ptr<(gr::blocks::vector_source_c)> self, vector_source_c p) -> vector_source_c_sptr
        """
        this = _blocks_swig1.new_vector_source_c_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(vector_source_c_sptr self) -> vector_source_c"""
        return _blocks_swig1.vector_source_c_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_vector_source_c_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(vector_source_c_sptr self, pmt_vector_cfloat data, bool repeat=False, int vlen=1, tags_vector_t tags=std::vector< gr::tag_t >()) -> vector_source_c_sptr

        Source that streams gr_complex items based on the input  vector.

        This block produces a stream of samples based on an input vector. In C++, this is a std::vector<gr_complex>, and in Python, this is either a list or tuple. The data can repeat infinitely until the flowgraph is terminated by some other event or, the default, run the data once and stop.

        The vector source can also produce stream tags with the data. Pass in a vector of gr::tag_t objects and they will be emitted based on the specified offset of the tag.

        GNU Radio provides a utility Python module in gr.tag_utils to convert between tags and Python objects: gr.tag_utils.python_to_tag.

        We can create tags as Python lists (or tuples) using the list structure [int offset, pmt key, pmt value, pmt srcid]. It is important to define the list/tuple with the values in the correct order and with the correct data type. A python dictionary can also be used using the keys: "offset", "key", "value", and "srcid" with the same data types as for the lists.

        When given a list of tags, the vector source will emit the tags repeatedly by updating the offset relative to the vector stream length. That is, if the vector has 500 items and a tag has an offset of 0, that tag will be placed on item 0, 500, 1000, 1500, etc.

        Constructor Specific Documentation:



        Args:
            data : 
            repeat : 
            vlen : 
            tags : 
        """
        return _blocks_swig1.vector_source_c_sptr_make(self, *args, **kwargs)

    def rewind(self):
        """rewind(vector_source_c_sptr self)"""
        return _blocks_swig1.vector_source_c_sptr_rewind(self)

    def set_data(self, *args, **kwargs):
        """set_data(vector_source_c_sptr self, pmt_vector_cfloat data, tags_vector_t tags=std::vector< gr::tag_t >())"""
        return _blocks_swig1.vector_source_c_sptr_set_data(self, *args, **kwargs)

    def set_repeat(self, *args, **kwargs):
        """set_repeat(vector_source_c_sptr self, bool repeat)"""
        return _blocks_swig1.vector_source_c_sptr_set_repeat(self, *args, **kwargs)

    def history(self):
        """history(vector_source_c_sptr self) -> unsigned int"""
        return _blocks_swig1.vector_source_c_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(vector_source_c_sptr self, int which, int delay)
        declare_sample_delay(vector_source_c_sptr self, unsigned int delay)
        """
        return _blocks_swig1.vector_source_c_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(vector_source_c_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.vector_source_c_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(vector_source_c_sptr self) -> int"""
        return _blocks_swig1.vector_source_c_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(vector_source_c_sptr self) -> double"""
        return _blocks_swig1.vector_source_c_sptr_relative_rate(self)

    def start(self):
        """start(vector_source_c_sptr self) -> bool"""
        return _blocks_swig1.vector_source_c_sptr_start(self)

    def stop(self):
        """stop(vector_source_c_sptr self) -> bool"""
        return _blocks_swig1.vector_source_c_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(vector_source_c_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.vector_source_c_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(vector_source_c_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.vector_source_c_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(vector_source_c_sptr self) -> int"""
        return _blocks_swig1.vector_source_c_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(vector_source_c_sptr self, int m)"""
        return _blocks_swig1.vector_source_c_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(vector_source_c_sptr self)"""
        return _blocks_swig1.vector_source_c_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(vector_source_c_sptr self) -> bool"""
        return _blocks_swig1.vector_source_c_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(vector_source_c_sptr self, int m)"""
        return _blocks_swig1.vector_source_c_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(vector_source_c_sptr self) -> int"""
        return _blocks_swig1.vector_source_c_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(vector_source_c_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_c_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(vector_source_c_sptr self, long max_output_buffer)
        set_max_output_buffer(vector_source_c_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.vector_source_c_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(vector_source_c_sptr self, int i) -> long"""
        return _blocks_swig1.vector_source_c_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(vector_source_c_sptr self, long min_output_buffer)
        set_min_output_buffer(vector_source_c_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.vector_source_c_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(vector_source_c_sptr self, int which) -> float
        pc_input_buffers_full(vector_source_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_c_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(vector_source_c_sptr self, int which) -> float
        pc_input_buffers_full_avg(vector_source_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_c_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(vector_source_c_sptr self, int which) -> float
        pc_input_buffers_full_var(vector_source_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_c_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(vector_source_c_sptr self, int which) -> float
        pc_output_buffers_full(vector_source_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_c_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(vector_source_c_sptr self, int which) -> float
        pc_output_buffers_full_avg(vector_source_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_c_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(vector_source_c_sptr self, int which) -> float
        pc_output_buffers_full_var(vector_source_c_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.vector_source_c_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(vector_source_c_sptr self) -> float"""
        return _blocks_swig1.vector_source_c_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(vector_source_c_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.vector_source_c_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(vector_source_c_sptr self)"""
        return _blocks_swig1.vector_source_c_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(vector_source_c_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.vector_source_c_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(vector_source_c_sptr self) -> int"""
        return _blocks_swig1.vector_source_c_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(vector_source_c_sptr self) -> int"""
        return _blocks_swig1.vector_source_c_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(vector_source_c_sptr self, int priority) -> int"""
        return _blocks_swig1.vector_source_c_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(vector_source_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_c_sptr_name(self)

    def symbol_name(self):
        """symbol_name(vector_source_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_c_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(vector_source_c_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_c_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(vector_source_c_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.vector_source_c_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(vector_source_c_sptr self) -> long"""
        return _blocks_swig1.vector_source_c_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(vector_source_c_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.vector_source_c_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(vector_source_c_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.vector_source_c_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(vector_source_c_sptr self) -> std::string"""
        return _blocks_swig1.vector_source_c_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(vector_source_c_sptr self, std::string name)"""
        return _blocks_swig1.vector_source_c_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(vector_source_c_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.vector_source_c_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(vector_source_c_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_c_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(vector_source_c_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_c_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(vector_source_c_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.vector_source_c_sptr_message_subscribers(self, *args, **kwargs)

vector_source_c_sptr_swigregister = _blocks_swig1.vector_source_c_sptr_swigregister
vector_source_c_sptr_swigregister(vector_source_c_sptr)

vector_source_c_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
vector_source_c = vector_source_c.make;

class wavfile_sink_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::wavfile_sink)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::wavfile_sink)> self) -> wavfile_sink_sptr
        __init__(boost::shared_ptr<(gr::blocks::wavfile_sink)> self, wavfile_sink p) -> wavfile_sink_sptr
        """
        this = _blocks_swig1.new_wavfile_sink_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(wavfile_sink_sptr self) -> wavfile_sink"""
        return _blocks_swig1.wavfile_sink_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_wavfile_sink_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(wavfile_sink_sptr self, char const * filename, int n_channels, unsigned int sample_rate, int bits_per_sample=16) -> wavfile_sink_sptr

        Write stream to a Microsoft PCM (.wav) file.

        Values must be floats within [-1;1]. Check gr_make_wavfile_sink() for extra info.

        Constructor Specific Documentation:



        Args:
            filename : 
            n_channels : 
            sample_rate : 
            bits_per_sample : 
        """
        return _blocks_swig1.wavfile_sink_sptr_make(self, *args, **kwargs)

    def open(self, *args, **kwargs):
        """
        open(wavfile_sink_sptr self, char const * filename) -> bool

        Opens a new file and writes a WAV header. Thread-safe.
        """
        return _blocks_swig1.wavfile_sink_sptr_open(self, *args, **kwargs)

    def close(self):
        """
        close(wavfile_sink_sptr self)

        Closes the currently active file and completes the WAV header. Thread-safe.
        """
        return _blocks_swig1.wavfile_sink_sptr_close(self)

    def set_sample_rate(self, *args, **kwargs):
        """
        set_sample_rate(wavfile_sink_sptr self, unsigned int sample_rate)

        Set the sample rate. This will not affect the WAV file currently opened. Any following open() calls will use this new sample rate.
        """
        return _blocks_swig1.wavfile_sink_sptr_set_sample_rate(self, *args, **kwargs)

    def set_bits_per_sample(self, *args, **kwargs):
        """
        set_bits_per_sample(wavfile_sink_sptr self, int bits_per_sample)

        Set bits per sample. This will not affect the WAV file currently opened (see set_sample_rate()). If the value is neither 8 nor 16, the call is ignored and the current value is kept.
        """
        return _blocks_swig1.wavfile_sink_sptr_set_bits_per_sample(self, *args, **kwargs)

    def history(self):
        """history(wavfile_sink_sptr self) -> unsigned int"""
        return _blocks_swig1.wavfile_sink_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(wavfile_sink_sptr self, int which, int delay)
        declare_sample_delay(wavfile_sink_sptr self, unsigned int delay)
        """
        return _blocks_swig1.wavfile_sink_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(wavfile_sink_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.wavfile_sink_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(wavfile_sink_sptr self) -> int"""
        return _blocks_swig1.wavfile_sink_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(wavfile_sink_sptr self) -> double"""
        return _blocks_swig1.wavfile_sink_sptr_relative_rate(self)

    def start(self):
        """start(wavfile_sink_sptr self) -> bool"""
        return _blocks_swig1.wavfile_sink_sptr_start(self)

    def stop(self):
        """stop(wavfile_sink_sptr self) -> bool"""
        return _blocks_swig1.wavfile_sink_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(wavfile_sink_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.wavfile_sink_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(wavfile_sink_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.wavfile_sink_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(wavfile_sink_sptr self) -> int"""
        return _blocks_swig1.wavfile_sink_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(wavfile_sink_sptr self, int m)"""
        return _blocks_swig1.wavfile_sink_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(wavfile_sink_sptr self)"""
        return _blocks_swig1.wavfile_sink_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(wavfile_sink_sptr self) -> bool"""
        return _blocks_swig1.wavfile_sink_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(wavfile_sink_sptr self, int m)"""
        return _blocks_swig1.wavfile_sink_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(wavfile_sink_sptr self) -> int"""
        return _blocks_swig1.wavfile_sink_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(wavfile_sink_sptr self, int i) -> long"""
        return _blocks_swig1.wavfile_sink_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(wavfile_sink_sptr self, long max_output_buffer)
        set_max_output_buffer(wavfile_sink_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.wavfile_sink_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(wavfile_sink_sptr self, int i) -> long"""
        return _blocks_swig1.wavfile_sink_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(wavfile_sink_sptr self, long min_output_buffer)
        set_min_output_buffer(wavfile_sink_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.wavfile_sink_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(wavfile_sink_sptr self, int which) -> float
        pc_input_buffers_full(wavfile_sink_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_sink_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(wavfile_sink_sptr self, int which) -> float
        pc_input_buffers_full_avg(wavfile_sink_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_sink_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(wavfile_sink_sptr self, int which) -> float
        pc_input_buffers_full_var(wavfile_sink_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_sink_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(wavfile_sink_sptr self, int which) -> float
        pc_output_buffers_full(wavfile_sink_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_sink_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(wavfile_sink_sptr self, int which) -> float
        pc_output_buffers_full_avg(wavfile_sink_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_sink_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(wavfile_sink_sptr self, int which) -> float
        pc_output_buffers_full_var(wavfile_sink_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_sink_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(wavfile_sink_sptr self) -> float"""
        return _blocks_swig1.wavfile_sink_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(wavfile_sink_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.wavfile_sink_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(wavfile_sink_sptr self)"""
        return _blocks_swig1.wavfile_sink_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(wavfile_sink_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.wavfile_sink_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(wavfile_sink_sptr self) -> int"""
        return _blocks_swig1.wavfile_sink_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(wavfile_sink_sptr self) -> int"""
        return _blocks_swig1.wavfile_sink_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(wavfile_sink_sptr self, int priority) -> int"""
        return _blocks_swig1.wavfile_sink_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(wavfile_sink_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_sink_sptr_name(self)

    def symbol_name(self):
        """symbol_name(wavfile_sink_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_sink_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(wavfile_sink_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.wavfile_sink_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(wavfile_sink_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.wavfile_sink_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(wavfile_sink_sptr self) -> long"""
        return _blocks_swig1.wavfile_sink_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(wavfile_sink_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.wavfile_sink_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(wavfile_sink_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.wavfile_sink_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(wavfile_sink_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_sink_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(wavfile_sink_sptr self, std::string name)"""
        return _blocks_swig1.wavfile_sink_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(wavfile_sink_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.wavfile_sink_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(wavfile_sink_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.wavfile_sink_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(wavfile_sink_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.wavfile_sink_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(wavfile_sink_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.wavfile_sink_sptr_message_subscribers(self, *args, **kwargs)

wavfile_sink_sptr_swigregister = _blocks_swig1.wavfile_sink_sptr_swigregister
wavfile_sink_sptr_swigregister(wavfile_sink_sptr)

wavfile_sink_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
wavfile_sink = wavfile_sink.make;

class wavfile_source_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::blocks::wavfile_source)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::blocks::wavfile_source)> self) -> wavfile_source_sptr
        __init__(boost::shared_ptr<(gr::blocks::wavfile_source)> self, wavfile_source p) -> wavfile_source_sptr
        """
        this = _blocks_swig1.new_wavfile_source_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(wavfile_source_sptr self) -> wavfile_source"""
        return _blocks_swig1.wavfile_source_sptr___deref__(self)

    __swig_destroy__ = _blocks_swig1.delete_wavfile_source_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(wavfile_source_sptr self, char const * filename, bool repeat=False) -> wavfile_source_sptr

        Read stream from a Microsoft PCM (.wav) file, output floats.

        Unless otherwise called, values are within [-1;1]. Check gr_make_wavfile_source() for extra info.

        Constructor Specific Documentation:



        Args:
            filename : 
            repeat : 
        """
        return _blocks_swig1.wavfile_source_sptr_make(self, *args, **kwargs)

    def sample_rate(self):
        """
        sample_rate(wavfile_source_sptr self) -> unsigned int

        Read the sample rate as specified in the wav file header.
        """
        return _blocks_swig1.wavfile_source_sptr_sample_rate(self)

    def bits_per_sample(self):
        """
        bits_per_sample(wavfile_source_sptr self) -> int

        Return the number of bits per sample as specified in the wav file header. Only 8 or 16 bit are supported here.
        """
        return _blocks_swig1.wavfile_source_sptr_bits_per_sample(self)

    def channels(self):
        """
        channels(wavfile_source_sptr self) -> int

        Return the number of channels in the wav file as specified in the wav file header. This is also the max number of outputs you can have.
        """
        return _blocks_swig1.wavfile_source_sptr_channels(self)

    def history(self):
        """history(wavfile_source_sptr self) -> unsigned int"""
        return _blocks_swig1.wavfile_source_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(wavfile_source_sptr self, int which, int delay)
        declare_sample_delay(wavfile_source_sptr self, unsigned int delay)
        """
        return _blocks_swig1.wavfile_source_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(wavfile_source_sptr self, int which) -> unsigned int"""
        return _blocks_swig1.wavfile_source_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(wavfile_source_sptr self) -> int"""
        return _blocks_swig1.wavfile_source_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(wavfile_source_sptr self) -> double"""
        return _blocks_swig1.wavfile_source_sptr_relative_rate(self)

    def start(self):
        """start(wavfile_source_sptr self) -> bool"""
        return _blocks_swig1.wavfile_source_sptr_start(self)

    def stop(self):
        """stop(wavfile_source_sptr self) -> bool"""
        return _blocks_swig1.wavfile_source_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(wavfile_source_sptr self, unsigned int which_input) -> uint64_t"""
        return _blocks_swig1.wavfile_source_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(wavfile_source_sptr self, unsigned int which_output) -> uint64_t"""
        return _blocks_swig1.wavfile_source_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(wavfile_source_sptr self) -> int"""
        return _blocks_swig1.wavfile_source_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(wavfile_source_sptr self, int m)"""
        return _blocks_swig1.wavfile_source_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(wavfile_source_sptr self)"""
        return _blocks_swig1.wavfile_source_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(wavfile_source_sptr self) -> bool"""
        return _blocks_swig1.wavfile_source_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(wavfile_source_sptr self, int m)"""
        return _blocks_swig1.wavfile_source_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(wavfile_source_sptr self) -> int"""
        return _blocks_swig1.wavfile_source_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(wavfile_source_sptr self, int i) -> long"""
        return _blocks_swig1.wavfile_source_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(wavfile_source_sptr self, long max_output_buffer)
        set_max_output_buffer(wavfile_source_sptr self, int port, long max_output_buffer)
        """
        return _blocks_swig1.wavfile_source_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(wavfile_source_sptr self, int i) -> long"""
        return _blocks_swig1.wavfile_source_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(wavfile_source_sptr self, long min_output_buffer)
        set_min_output_buffer(wavfile_source_sptr self, int port, long min_output_buffer)
        """
        return _blocks_swig1.wavfile_source_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(wavfile_source_sptr self, int which) -> float
        pc_input_buffers_full(wavfile_source_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_source_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(wavfile_source_sptr self, int which) -> float
        pc_input_buffers_full_avg(wavfile_source_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_source_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(wavfile_source_sptr self, int which) -> float
        pc_input_buffers_full_var(wavfile_source_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_source_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(wavfile_source_sptr self, int which) -> float
        pc_output_buffers_full(wavfile_source_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_source_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(wavfile_source_sptr self, int which) -> float
        pc_output_buffers_full_avg(wavfile_source_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_source_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(wavfile_source_sptr self, int which) -> float
        pc_output_buffers_full_var(wavfile_source_sptr self) -> pmt_vector_float
        """
        return _blocks_swig1.wavfile_source_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(wavfile_source_sptr self) -> float"""
        return _blocks_swig1.wavfile_source_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(wavfile_source_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _blocks_swig1.wavfile_source_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(wavfile_source_sptr self)"""
        return _blocks_swig1.wavfile_source_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(wavfile_source_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _blocks_swig1.wavfile_source_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(wavfile_source_sptr self) -> int"""
        return _blocks_swig1.wavfile_source_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(wavfile_source_sptr self) -> int"""
        return _blocks_swig1.wavfile_source_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(wavfile_source_sptr self, int priority) -> int"""
        return _blocks_swig1.wavfile_source_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(wavfile_source_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_source_sptr_name(self)

    def symbol_name(self):
        """symbol_name(wavfile_source_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_source_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(wavfile_source_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.wavfile_source_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(wavfile_source_sptr self) -> io_signature_sptr"""
        return _blocks_swig1.wavfile_source_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(wavfile_source_sptr self) -> long"""
        return _blocks_swig1.wavfile_source_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(wavfile_source_sptr self) -> basic_block_sptr"""
        return _blocks_swig1.wavfile_source_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(wavfile_source_sptr self, int ninputs, int noutputs) -> bool"""
        return _blocks_swig1.wavfile_source_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(wavfile_source_sptr self) -> std::string"""
        return _blocks_swig1.wavfile_source_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(wavfile_source_sptr self, std::string name)"""
        return _blocks_swig1.wavfile_source_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(wavfile_source_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _blocks_swig1.wavfile_source_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(wavfile_source_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.wavfile_source_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(wavfile_source_sptr self) -> swig_int_ptr"""
        return _blocks_swig1.wavfile_source_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(wavfile_source_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _blocks_swig1.wavfile_source_sptr_message_subscribers(self, *args, **kwargs)

wavfile_source_sptr_swigregister = _blocks_swig1.wavfile_source_sptr_swigregister
wavfile_source_sptr_swigregister(wavfile_source_sptr)

wavfile_source_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
wavfile_source = wavfile_source.make;



