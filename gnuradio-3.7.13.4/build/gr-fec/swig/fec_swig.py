# This file was automatically generated by SWIG (http://www.swig.org).
# Version 2.0.11
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.





from sys import version_info
if version_info >= (2,6,0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_fec_swig', [dirname(__file__)])
        except ImportError:
            import _fec_swig
            return _fec_swig
        if fp is not None:
            try:
                _mod = imp.load_module('_fec_swig', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _fec_swig = swig_import_helper()
    del swig_import_helper
else:
    import _fec_swig
del version_info
try:
    _swig_property = property
except NameError:
    pass # Python < 2.2 doesn't have 'property'.
def _swig_setattr_nondynamic(self,class_type,name,value,static=1):
    if (name == "thisown"): return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name,None)
    if method: return method(self,value)
    if (not static):
        self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)

def _swig_setattr(self,class_type,name,value):
    return _swig_setattr_nondynamic(self,class_type,name,value,0)

def _swig_getattr(self,class_type,name):
    if (name == "thisown"): return self.this.own()
    method = class_type.__swig_getmethods__.get(name,None)
    if method: return method(self)
    raise AttributeError(name)

def _swig_repr(self):
    try: strthis = "proxy of " + self.this.__repr__()
    except: strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except AttributeError:
    class _object : pass
    _newclass = 0


def _swig_setattr_nondynamic_method(set):
    def set_attr(self,name,value):
        if (name == "thisown"): return self.this.own(value)
        if hasattr(self,name) or (name == "this"):
            set(self,name,value)
        else:
            raise AttributeError("You cannot add attributes to %s" % self)
    return set_attr



def high_res_timer_now():
  """high_res_timer_now() -> gr::high_res_timer_type"""
  return _fec_swig.high_res_timer_now()

def high_res_timer_now_perfmon():
  """high_res_timer_now_perfmon() -> gr::high_res_timer_type"""
  return _fec_swig.high_res_timer_now_perfmon()

def high_res_timer_tps():
  """high_res_timer_tps() -> gr::high_res_timer_type"""
  return _fec_swig.high_res_timer_tps()

def high_res_timer_epoch():
  """high_res_timer_epoch() -> gr::high_res_timer_type"""
  return _fec_swig.high_res_timer_epoch()
CC_STREAMING = _fec_swig.CC_STREAMING
CC_TERMINATED = _fec_swig.CC_TERMINATED
CC_TRUNCATED = _fec_swig.CC_TRUNCATED
CC_TAILBITING = _fec_swig.CC_TAILBITING
class decision_t(object):
    """Proxy of C++ decision_t class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    t = _swig_property(_fec_swig.decision_t_t_get, _fec_swig.decision_t_t_set)
    w = _swig_property(_fec_swig.decision_t_w_get, _fec_swig.decision_t_w_set)
    s = _swig_property(_fec_swig.decision_t_s_get, _fec_swig.decision_t_s_set)
    c = _swig_property(_fec_swig.decision_t_c_get, _fec_swig.decision_t_c_set)
    def __init__(self): 
        """__init__(decision_t self) -> decision_t"""
        this = _fec_swig.new_decision_t()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fec_swig.delete_decision_t
    __del__ = lambda self : None;
decision_t_swigregister = _fec_swig.decision_t_swigregister
decision_t_swigregister(decision_t)

class metric_t(object):
    """Proxy of C++ metric_t class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    t = _swig_property(_fec_swig.metric_t_t_get, _fec_swig.metric_t_t_set)
    def __init__(self): 
        """__init__(metric_t self) -> metric_t"""
        this = _fec_swig.new_metric_t()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fec_swig.delete_metric_t
    __del__ = lambda self : None;
metric_t_swigregister = _fec_swig.metric_t_swigregister
metric_t_swigregister(metric_t)

class v(object):
    """Proxy of C++ v class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    metrics = _swig_property(_fec_swig.v_metrics_get, _fec_swig.v_metrics_set)
    old_metrics = _swig_property(_fec_swig.v_old_metrics_get, _fec_swig.v_old_metrics_set)
    new_metrics = _swig_property(_fec_swig.v_new_metrics_get, _fec_swig.v_new_metrics_set)
    metrics1 = _swig_property(_fec_swig.v_metrics1_get, _fec_swig.v_metrics1_set)
    metrics2 = _swig_property(_fec_swig.v_metrics2_get, _fec_swig.v_metrics2_set)
    decisions = _swig_property(_fec_swig.v_decisions_get, _fec_swig.v_decisions_set)
    def __init__(self): 
        """__init__(v self) -> v"""
        this = _fec_swig.new_v()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fec_swig.delete_v
    __del__ = lambda self : None;
v_swigregister = _fec_swig.v_swigregister
v_swigregister(v)

class generic_encoder_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::generic_encoder)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::generic_encoder)> self) -> generic_encoder_sptr
        __init__(boost::shared_ptr<(gr::fec::generic_encoder)> self, generic_encoder p) -> generic_encoder_sptr
        """
        this = _fec_swig.new_generic_encoder_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(generic_encoder_sptr self) -> generic_encoder"""
        return _fec_swig.generic_encoder_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_generic_encoder_sptr
    __del__ = lambda self : None;
    def generic_work(self, *args, **kwargs):
        """generic_work(generic_encoder_sptr self, void * in_buffer, void * out_buffer)"""
        return _fec_swig.generic_encoder_sptr_generic_work(self, *args, **kwargs)

    base_unique_id = _swig_property(_fec_swig.generic_encoder_sptr_base_unique_id_get, _fec_swig.generic_encoder_sptr_base_unique_id_set)
    my_id = _swig_property(_fec_swig.generic_encoder_sptr_my_id_get, _fec_swig.generic_encoder_sptr_my_id_set)
    def unique_id(self):
        """unique_id(generic_encoder_sptr self) -> int"""
        return _fec_swig.generic_encoder_sptr_unique_id(self)

    d_name = _swig_property(_fec_swig.generic_encoder_sptr_d_name_get, _fec_swig.generic_encoder_sptr_d_name_set)
    def alias(self):
        """alias(generic_encoder_sptr self) -> std::string"""
        return _fec_swig.generic_encoder_sptr_alias(self)

    def rate(self):
        """
        rate(generic_encoder_sptr self) -> double

        Returns the rate of the code. For every 1 input bit, there are r output bits, so the rate is 1/r. Used for setting things like the encoder block's relative rate.

        This function MUST be reimplemented by the child class.
        """
        return _fec_swig.generic_encoder_sptr_rate(self)

    def get_input_size(self):
        """
        get_input_size(generic_encoder_sptr self) -> int

        Returns the input size in items that the encoder object uses to encode a full frame. Often, this number is the number of bits per frame if the input format is unpacked. If the block expects packed bytes, then this value should be the number of bytes (number of bits / 8) per input frame.

        The child class MUST implement this function.
        """
        return _fec_swig.generic_encoder_sptr_get_input_size(self)

    def get_output_size(self):
        """
        get_output_size(generic_encoder_sptr self) -> int

        Returns the output size in items that the encoder object produces after encoding a full frame. Often, this number is the number of bits in the outputted frame if the input format is unpacked. If the block produces packed bytes, then this value should be the number of bytes (number of bits / 8) per frame produced. This value is generally something like R*get_input_size() for a 1/R rate code.

        The child class MUST implement this function.
        """
        return _fec_swig.generic_encoder_sptr_get_output_size(self)

    def get_input_conversion(self):
        """
        get_input_conversion(generic_encoder_sptr self) -> char const *

        Set up a conversion type required to setup the data properly for this encoder. The encoder itself will not implement the conversion and expects an external wrapper (e.g., fec.extended_encoder) to read this value and "do the right
        thing" to format the data.

        The default behavior is 'none', which means no conversion is required. Whatever the get_input_item_size() value returns, the input is expected to conform directly to this. Generally, this means unpacked bytes.

        If 'pack', the block expects the inputs to be packed bytes. The wrapper should implement a gr::blocks::pack_k_bits_bb(8) block for this.

        The child class MAY implement this function. If not reimplemented, it returns "none".
        """
        return _fec_swig.generic_encoder_sptr_get_input_conversion(self)

    def get_output_conversion(self):
        """
        get_output_conversion(generic_encoder_sptr self) -> char const *

        Set up a conversion type required to understand the output style of this encoder. Generally an encoder will produce unpacked bytes with a bit set in the LSB.

        The default behavior is 'none', which means no conversion is required and the encoder produces unpacked bytes.

        If 'packed_bits', the block produces packed bits and the wrapper should unpack these (using, for instance, gr::block::unpack_k_bits_bb(8)).

        The child class MAY implement this function. If not reimplemented, it returns "none".
        """
        return _fec_swig.generic_encoder_sptr_get_output_conversion(self)

    def set_frame_size(self, *args, **kwargs):
        """
        set_frame_size(generic_encoder_sptr self, unsigned int frame_size) -> bool

        Updates the size of the frame to encode.

        The child class MUST implement this function and interpret how the  information affects the block's behavior. It should also provide bounds checks.
        """
        return _fec_swig.generic_encoder_sptr_set_frame_size(self, *args, **kwargs)

generic_encoder_sptr_swigregister = _fec_swig.generic_encoder_sptr_swigregister
generic_encoder_sptr_swigregister(generic_encoder_sptr)

class generic_decoder_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::generic_decoder)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::generic_decoder)> self) -> generic_decoder_sptr
        __init__(boost::shared_ptr<(gr::fec::generic_decoder)> self, generic_decoder p) -> generic_decoder_sptr
        """
        this = _fec_swig.new_generic_decoder_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(generic_decoder_sptr self) -> generic_decoder"""
        return _fec_swig.generic_decoder_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_generic_decoder_sptr
    __del__ = lambda self : None;
    def generic_work(self, *args, **kwargs):
        """generic_work(generic_decoder_sptr self, void * inbuffer, void * outbuffer)"""
        return _fec_swig.generic_decoder_sptr_generic_work(self, *args, **kwargs)

    base_unique_id = _swig_property(_fec_swig.generic_decoder_sptr_base_unique_id_get, _fec_swig.generic_decoder_sptr_base_unique_id_set)
    my_id = _swig_property(_fec_swig.generic_decoder_sptr_my_id_get, _fec_swig.generic_decoder_sptr_my_id_set)
    def unique_id(self):
        """unique_id(generic_decoder_sptr self) -> int"""
        return _fec_swig.generic_decoder_sptr_unique_id(self)

    d_name = _swig_property(_fec_swig.generic_decoder_sptr_d_name_get, _fec_swig.generic_decoder_sptr_d_name_set)
    def alias(self):
        """alias(generic_decoder_sptr self) -> std::string"""
        return _fec_swig.generic_decoder_sptr_alias(self)

    def rate(self):
        """
        rate(generic_decoder_sptr self) -> double

        Returns the rate of the code. For every r input bits, there is 1 output bit, so the rate is 1/r. Used for setting things like the encoder block's relative rate.

        This function MUST be reimplemented by the child class.
        """
        return _fec_swig.generic_decoder_sptr_rate(self)

    def get_input_size(self):
        """
        get_input_size(generic_decoder_sptr self) -> int

        Returns the input size in items that the decoder object uses to decode a full frame. Often, this number is the number of bits per frame if the input format is unpacked. If the block expects packed bytes, then this value should be the number of bytes (number of bits / 8) per input frame.

        The child class MUST implement this function.
        """
        return _fec_swig.generic_decoder_sptr_get_input_size(self)

    def get_output_size(self):
        """
        get_output_size(generic_decoder_sptr self) -> int

        Returns the output size in items that the decoder object produces after decoding a full frame. Often, this number is the number of bits in the outputted frame if the input format is unpacked. If the block produces packed bytes, then this value should be the number of bytes (number of bits / 8) per frame produced. This value is generally something like get_input_size()/R for a 1/R rate code.

        The child class MUST implement this function.
        """
        return _fec_swig.generic_decoder_sptr_get_output_size(self)

    def get_history(self):
        """
        get_history(generic_decoder_sptr self) -> int

        Sets up history for the decoder when the decoder is required to look ahead in the data stream in order to finish its processing.

        The child class MAY implement this function. If not reimplemented, it returns 0.
        """
        return _fec_swig.generic_decoder_sptr_get_history(self)

    def get_shift(self):
        """
        get_shift(generic_decoder_sptr self) -> float

        Some decoders require the input items to float around a particular soft value. We can set that floating value by setting this value to return some non-zero number.

        The fec.extended_decoder block will use this to create an add_const_ff block before the decoder block to adjust all input samples appropriately.

        The child class MAY implement this function. If not reimplemented, it returns 0.
        """
        return _fec_swig.generic_decoder_sptr_get_shift(self)

    def get_input_item_size(self):
        """
        get_input_item_size(generic_decoder_sptr self) -> int

        Sets the size of an input item, as in the size of a char or float item.

        The child class SHOULD implement this function. If not reimplemented, it returns sizeof(float) as the decoders typically expect floating point input types.
        """
        return _fec_swig.generic_decoder_sptr_get_input_item_size(self)

    def get_output_item_size(self):
        """
        get_output_item_size(generic_decoder_sptr self) -> int

        Sets the size of an output item, as in the size of a char or float item.

        The child class SHOULD implement this function. If not reimplemented, it returns sizeof(char) as the decoders typically expect to produce bits or bytes.
        """
        return _fec_swig.generic_decoder_sptr_get_output_item_size(self)

    def get_input_conversion(self):
        """
        get_input_conversion(generic_decoder_sptr self) -> char const *

        Set up a conversion type required to setup the data properly for this decoder. The decoder itself will not implement the conversion and expects an external wrapper (e.g., fec.extended_decoder) to read this value and "do the right
        thing" to format the data.

        The default behavior is 'none', which means no conversion is required. Whatever the get_input_item_size() value returns, the input is expected to conform directly to this.

        This may also return 'uchar', which indicates that the wrapper should convert the standard float samples to unsigned characters, either hard sliced or 8-bit soft symbols. See gr::fec::code::cc_decoder as an example decoder that uses this conversion format.

        If 'packed_bits', the block expects the inputs to be packed hard bits. Each input item is a unsigned char where each of the 8-bits is a hard bit value.

        The child class SHOULD implement this function. If not reimplemented, it returns "none".
        """
        return _fec_swig.generic_decoder_sptr_get_input_conversion(self)

    def get_output_conversion(self):
        """
        get_output_conversion(generic_decoder_sptr self) -> char const *

        Set up a conversion type required to understand the output style of this decoder. Generally, follow-on processing expects unpacked bits, so we specify the conversion type here to indicate what the wrapper (e.g., fec.extended_decoder) should do to convert the output samples from the decoder into unpacked bits.

        The default behavior is 'none', which means no conversion is required. This should mean that the output data is produced from this decoder as unpacked bit.

        If 'unpack', the block produces packed bytes that should be unpacked by the wrapper. See gr::fec::code::ccsds_decoder as an example of a decoder that produces packed bytes.

        The child class SHOULD implement this function. If not reimplemented, it returns "none".
        """
        return _fec_swig.generic_decoder_sptr_get_output_conversion(self)

    def set_frame_size(self, *args, **kwargs):
        """
        set_frame_size(generic_decoder_sptr self, unsigned int frame_size) -> bool

        Updates the size of a decoded frame.

        The child class MUST implement this function and interpret how the  information affects the block's behavior. It should also provide bounds checks.
        """
        return _fec_swig.generic_decoder_sptr_set_frame_size(self, *args, **kwargs)

    def get_iterations(self):
        """
        get_iterations(generic_decoder_sptr self) -> float

        Get repetitions to decode.

        The child class should implement this function and return the number of iterations required to decode.
        """
        return _fec_swig.generic_decoder_sptr_get_iterations(self)

generic_decoder_sptr_swigregister = _fec_swig.generic_decoder_sptr_swigregister
generic_decoder_sptr_swigregister(generic_decoder_sptr)

class generic_decoder(object):
    """
    Parent class for FECAPI objects.

    Parent of a decoder variable class for FECAPI that will fit into the gr::fec::decoder block to handle FEC decoding. This class provides the basic information required to fit into the FECAPI structure. It provides information about input and output data types, potential data conversions, and a few other parameters useful to establish the decoder's behavior.

    We create objects from FECAPI-derived classes to go into the actual GNU Radio decoder block. Each object contains its own state and so there should be a one-to-one mapping of an FECAPI object and a GR decoder block. Sharing these objects is not guaranteed to be thread-safe.

    This is a pure virtual class and must be derived from by a child class.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def generic_work(self, *args, **kwargs):
        """generic_work(generic_decoder self, void * inbuffer, void * outbuffer)"""
        return _fec_swig.generic_decoder_generic_work(self, *args, **kwargs)

    base_unique_id = _swig_property(_fec_swig.generic_decoder_base_unique_id_get, _fec_swig.generic_decoder_base_unique_id_set)
    my_id = _swig_property(_fec_swig.generic_decoder_my_id_get, _fec_swig.generic_decoder_my_id_set)
    def unique_id(self):
        """unique_id(generic_decoder self) -> int"""
        return _fec_swig.generic_decoder_unique_id(self)

    d_name = _swig_property(_fec_swig.generic_decoder_d_name_get, _fec_swig.generic_decoder_d_name_set)
    def alias(self):
        """alias(generic_decoder self) -> std::string"""
        return _fec_swig.generic_decoder_alias(self)

    __swig_destroy__ = _fec_swig.delete_generic_decoder
    __del__ = lambda self : None;
    def rate(self):
        """
        rate(generic_decoder self) -> double

        Returns the rate of the code. For every r input bits, there is 1 output bit, so the rate is 1/r. Used for setting things like the encoder block's relative rate.

        This function MUST be reimplemented by the child class.
        """
        return _fec_swig.generic_decoder_rate(self)

    def get_input_size(self):
        """
        get_input_size(generic_decoder self) -> int

        Returns the input size in items that the decoder object uses to decode a full frame. Often, this number is the number of bits per frame if the input format is unpacked. If the block expects packed bytes, then this value should be the number of bytes (number of bits / 8) per input frame.

        The child class MUST implement this function.
        """
        return _fec_swig.generic_decoder_get_input_size(self)

    def get_output_size(self):
        """
        get_output_size(generic_decoder self) -> int

        Returns the output size in items that the decoder object produces after decoding a full frame. Often, this number is the number of bits in the outputted frame if the input format is unpacked. If the block produces packed bytes, then this value should be the number of bytes (number of bits / 8) per frame produced. This value is generally something like get_input_size()/R for a 1/R rate code.

        The child class MUST implement this function.
        """
        return _fec_swig.generic_decoder_get_output_size(self)

    def get_history(self):
        """
        get_history(generic_decoder self) -> int

        Sets up history for the decoder when the decoder is required to look ahead in the data stream in order to finish its processing.

        The child class MAY implement this function. If not reimplemented, it returns 0.
        """
        return _fec_swig.generic_decoder_get_history(self)

    def get_shift(self):
        """
        get_shift(generic_decoder self) -> float

        Some decoders require the input items to float around a particular soft value. We can set that floating value by setting this value to return some non-zero number.

        The fec.extended_decoder block will use this to create an add_const_ff block before the decoder block to adjust all input samples appropriately.

        The child class MAY implement this function. If not reimplemented, it returns 0.
        """
        return _fec_swig.generic_decoder_get_shift(self)

    def get_input_item_size(self):
        """
        get_input_item_size(generic_decoder self) -> int

        Sets the size of an input item, as in the size of a char or float item.

        The child class SHOULD implement this function. If not reimplemented, it returns sizeof(float) as the decoders typically expect floating point input types.
        """
        return _fec_swig.generic_decoder_get_input_item_size(self)

    def get_output_item_size(self):
        """
        get_output_item_size(generic_decoder self) -> int

        Sets the size of an output item, as in the size of a char or float item.

        The child class SHOULD implement this function. If not reimplemented, it returns sizeof(char) as the decoders typically expect to produce bits or bytes.
        """
        return _fec_swig.generic_decoder_get_output_item_size(self)

    def get_input_conversion(self):
        """
        get_input_conversion(generic_decoder self) -> char const *

        Set up a conversion type required to setup the data properly for this decoder. The decoder itself will not implement the conversion and expects an external wrapper (e.g., fec.extended_decoder) to read this value and "do the right
        thing" to format the data.

        The default behavior is 'none', which means no conversion is required. Whatever the get_input_item_size() value returns, the input is expected to conform directly to this.

        This may also return 'uchar', which indicates that the wrapper should convert the standard float samples to unsigned characters, either hard sliced or 8-bit soft symbols. See gr::fec::code::cc_decoder as an example decoder that uses this conversion format.

        If 'packed_bits', the block expects the inputs to be packed hard bits. Each input item is a unsigned char where each of the 8-bits is a hard bit value.

        The child class SHOULD implement this function. If not reimplemented, it returns "none".
        """
        return _fec_swig.generic_decoder_get_input_conversion(self)

    def get_output_conversion(self):
        """
        get_output_conversion(generic_decoder self) -> char const *

        Set up a conversion type required to understand the output style of this decoder. Generally, follow-on processing expects unpacked bits, so we specify the conversion type here to indicate what the wrapper (e.g., fec.extended_decoder) should do to convert the output samples from the decoder into unpacked bits.

        The default behavior is 'none', which means no conversion is required. This should mean that the output data is produced from this decoder as unpacked bit.

        If 'unpack', the block produces packed bytes that should be unpacked by the wrapper. See gr::fec::code::ccsds_decoder as an example of a decoder that produces packed bytes.

        The child class SHOULD implement this function. If not reimplemented, it returns "none".
        """
        return _fec_swig.generic_decoder_get_output_conversion(self)

    def set_frame_size(self, *args, **kwargs):
        """
        set_frame_size(generic_decoder self, unsigned int frame_size) -> bool

        Updates the size of a decoded frame.

        The child class MUST implement this function and interpret how the  information affects the block's behavior. It should also provide bounds checks.
        """
        return _fec_swig.generic_decoder_set_frame_size(self, *args, **kwargs)

    def get_iterations(self):
        """
        get_iterations(generic_decoder self) -> float

        Get repetitions to decode.

        The child class should implement this function and return the number of iterations required to decode.
        """
        return _fec_swig.generic_decoder_get_iterations(self)

generic_decoder_swigregister = _fec_swig.generic_decoder_swigregister
generic_decoder_swigregister(generic_decoder)
cvar = _fec_swig.cvar


def get_decoder_output_size(*args, **kwargs):
  """
    get_decoder_output_size(generic_decoder_sptr my_decoder) -> int

    see generic_decoder::get_output_size()
    """
  return _fec_swig.get_decoder_output_size(*args, **kwargs)

def get_decoder_input_size(*args, **kwargs):
  """
    get_decoder_input_size(generic_decoder_sptr my_decoder) -> int

    see generic_decoder::get_input_size()
    """
  return _fec_swig.get_decoder_input_size(*args, **kwargs)

def get_shift(*args, **kwargs):
  """
    get_shift(generic_decoder_sptr my_decoder) -> float

    see generic_decoder::get_shift()
    """
  return _fec_swig.get_shift(*args, **kwargs)

def get_history(*args, **kwargs):
  """
    get_history(generic_decoder_sptr my_decoder) -> int

    see generic_decoder::get_history()
    """
  return _fec_swig.get_history(*args, **kwargs)

def get_decoder_input_item_size(*args, **kwargs):
  """
    get_decoder_input_item_size(generic_decoder_sptr my_decoder) -> int

    see generic_decoder::get_input_item_size()
    """
  return _fec_swig.get_decoder_input_item_size(*args, **kwargs)

def get_decoder_output_item_size(*args, **kwargs):
  """
    get_decoder_output_item_size(generic_decoder_sptr my_decoder) -> int

    see generic_decoder::get_output_item_size()
    """
  return _fec_swig.get_decoder_output_item_size(*args, **kwargs)

def get_decoder_input_conversion(*args, **kwargs):
  """
    get_decoder_input_conversion(generic_decoder_sptr my_decoder) -> char const *

    see generic_decoder::get_input_conversion()
    """
  return _fec_swig.get_decoder_input_conversion(*args, **kwargs)

def get_decoder_output_conversion(*args, **kwargs):
  """
    get_decoder_output_conversion(generic_decoder_sptr my_decoder) -> char const *

    see generic_decoder::get_output_conversion()
    """
  return _fec_swig.get_decoder_output_conversion(*args, **kwargs)
class generic_encoder(object):
    """Proxy of C++ gr::fec::generic_encoder class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def generic_work(self, *args, **kwargs):
        """generic_work(generic_encoder self, void * in_buffer, void * out_buffer)"""
        return _fec_swig.generic_encoder_generic_work(self, *args, **kwargs)

    base_unique_id = _swig_property(_fec_swig.generic_encoder_base_unique_id_get, _fec_swig.generic_encoder_base_unique_id_set)
    my_id = _swig_property(_fec_swig.generic_encoder_my_id_get, _fec_swig.generic_encoder_my_id_set)
    def unique_id(self):
        """unique_id(generic_encoder self) -> int"""
        return _fec_swig.generic_encoder_unique_id(self)

    d_name = _swig_property(_fec_swig.generic_encoder_d_name_get, _fec_swig.generic_encoder_d_name_set)
    def alias(self):
        """alias(generic_encoder self) -> std::string"""
        return _fec_swig.generic_encoder_alias(self)

    def rate(self):
        """
        rate(generic_encoder self) -> double

        Returns the rate of the code. For every 1 input bit, there are r output bits, so the rate is 1/r. Used for setting things like the encoder block's relative rate.

        This function MUST be reimplemented by the child class.
        """
        return _fec_swig.generic_encoder_rate(self)

    def get_input_size(self):
        """
        get_input_size(generic_encoder self) -> int

        Returns the input size in items that the encoder object uses to encode a full frame. Often, this number is the number of bits per frame if the input format is unpacked. If the block expects packed bytes, then this value should be the number of bytes (number of bits / 8) per input frame.

        The child class MUST implement this function.
        """
        return _fec_swig.generic_encoder_get_input_size(self)

    def get_output_size(self):
        """
        get_output_size(generic_encoder self) -> int

        Returns the output size in items that the encoder object produces after encoding a full frame. Often, this number is the number of bits in the outputted frame if the input format is unpacked. If the block produces packed bytes, then this value should be the number of bytes (number of bits / 8) per frame produced. This value is generally something like R*get_input_size() for a 1/R rate code.

        The child class MUST implement this function.
        """
        return _fec_swig.generic_encoder_get_output_size(self)

    def get_input_conversion(self):
        """
        get_input_conversion(generic_encoder self) -> char const *

        Set up a conversion type required to setup the data properly for this encoder. The encoder itself will not implement the conversion and expects an external wrapper (e.g., fec.extended_encoder) to read this value and "do the right
        thing" to format the data.

        The default behavior is 'none', which means no conversion is required. Whatever the get_input_item_size() value returns, the input is expected to conform directly to this. Generally, this means unpacked bytes.

        If 'pack', the block expects the inputs to be packed bytes. The wrapper should implement a gr::blocks::pack_k_bits_bb(8) block for this.

        The child class MAY implement this function. If not reimplemented, it returns "none".
        """
        return _fec_swig.generic_encoder_get_input_conversion(self)

    def get_output_conversion(self):
        """
        get_output_conversion(generic_encoder self) -> char const *

        Set up a conversion type required to understand the output style of this encoder. Generally an encoder will produce unpacked bytes with a bit set in the LSB.

        The default behavior is 'none', which means no conversion is required and the encoder produces unpacked bytes.

        If 'packed_bits', the block produces packed bits and the wrapper should unpack these (using, for instance, gr::block::unpack_k_bits_bb(8)).

        The child class MAY implement this function. If not reimplemented, it returns "none".
        """
        return _fec_swig.generic_encoder_get_output_conversion(self)

    def set_frame_size(self, *args, **kwargs):
        """
        set_frame_size(generic_encoder self, unsigned int frame_size) -> bool

        Updates the size of the frame to encode.

        The child class MUST implement this function and interpret how the  information affects the block's behavior. It should also provide bounds checks.
        """
        return _fec_swig.generic_encoder_set_frame_size(self, *args, **kwargs)

    __swig_destroy__ = _fec_swig.delete_generic_encoder
    __del__ = lambda self : None;
generic_encoder_swigregister = _fec_swig.generic_encoder_swigregister
generic_encoder_swigregister(generic_encoder)


def get_encoder_output_size(*args, **kwargs):
  """
    get_encoder_output_size(generic_encoder_sptr my_encoder) -> int

    see generic_encoder::get_output_size()
    """
  return _fec_swig.get_encoder_output_size(*args, **kwargs)

def get_encoder_input_size(*args, **kwargs):
  """
    get_encoder_input_size(generic_encoder_sptr my_encoder) -> int

    see generic_encoder::get_input_size()
    """
  return _fec_swig.get_encoder_input_size(*args, **kwargs)

def get_encoder_input_conversion(*args, **kwargs):
  """
    get_encoder_input_conversion(generic_encoder_sptr my_encoder) -> char const *

    see generic_encoder::get_input_conversion()
    """
  return _fec_swig.get_encoder_input_conversion(*args, **kwargs)

def get_encoder_output_conversion(*args, **kwargs):
  """
    get_encoder_output_conversion(generic_encoder_sptr my_encoder) -> char const *

    see generic_encoder::get_output_conversion()
    """
  return _fec_swig.get_encoder_output_conversion(*args, **kwargs)
class decoder(object):
    """
    General FEC decoding block that takes in a decoder variable object (derived from gr::fec::general_decoder) for use in a flowgraph.

    This block uses a decoder variable object (derived from gr::fec::generic_decoder) to decode data within a flowgraph. This block interacts with the general FECAPI architecture to handle all passing all input and output data in a flowgraph. The decoder variable takes care of understanding the requirements, data types and sizes, and boundary conditions of the specific FEC decoding algorithm.

    Generally, this block is used within the fec.extended_decoder Python block to handle some input/output formatting issues. In the FECAPI, the decoder variable sets properties like the input and output types and sizes and whether the output is packed or unpacked bytes. The fec.extended_decoder uses this information to set up an gr::hier_block2 structure to make sure the I/O to the variable is handled consistently, such as to make sure all inputs are floats with one soft symbol per item and the outputs are unpacked bytes with the bit in the LSB.

    See gr::fec::generic_decoder for detail on what information an FECAPI variable object can set if using this block directly and not as part of the fec.extended_decoder.

    Constructor Specific Documentation:

    Create the FEC decoder block by taking in the FECAPI decoder object as well as input and output sizes.

    Args:
        my_decoder : An FECAPI decoder object (See gr::fec::generic_decoder).
        input_item_size : The size of the input items (often the my_decoder object can tell us this).
        output_item_size : The size of the output items (often the my_decoder object can tell us this).
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(generic_decoder_sptr my_decoder, size_t input_item_size, size_t output_item_size) -> decoder_sptr

        General FEC decoding block that takes in a decoder variable object (derived from gr::fec::general_decoder) for use in a flowgraph.

        This block uses a decoder variable object (derived from gr::fec::generic_decoder) to decode data within a flowgraph. This block interacts with the general FECAPI architecture to handle all passing all input and output data in a flowgraph. The decoder variable takes care of understanding the requirements, data types and sizes, and boundary conditions of the specific FEC decoding algorithm.

        Generally, this block is used within the fec.extended_decoder Python block to handle some input/output formatting issues. In the FECAPI, the decoder variable sets properties like the input and output types and sizes and whether the output is packed or unpacked bytes. The fec.extended_decoder uses this information to set up an gr::hier_block2 structure to make sure the I/O to the variable is handled consistently, such as to make sure all inputs are floats with one soft symbol per item and the outputs are unpacked bytes with the bit in the LSB.

        See gr::fec::generic_decoder for detail on what information an FECAPI variable object can set if using this block directly and not as part of the fec.extended_decoder.

        Constructor Specific Documentation:

        Create the FEC decoder block by taking in the FECAPI decoder object as well as input and output sizes.

        Args:
            my_decoder : An FECAPI decoder object (See gr::fec::generic_decoder).
            input_item_size : The size of the input items (often the my_decoder object can tell us this).
            output_item_size : The size of the output items (often the my_decoder object can tell us this).
        """
        return _fec_swig.decoder_make(*args, **kwargs)

    make = staticmethod(make)
    def general_work(self, *args, **kwargs):
        """
        general_work(decoder self, int noutput_items, gr_vector_int & ninput_items, gr_vector_const_void_star & input_items, 
            gr_vector_void_star & output_items) -> int
        """
        return _fec_swig.decoder_general_work(self, *args, **kwargs)

    def fixed_rate_ninput_to_noutput(self, *args, **kwargs):
        """fixed_rate_ninput_to_noutput(decoder self, int ninput) -> int"""
        return _fec_swig.decoder_fixed_rate_ninput_to_noutput(self, *args, **kwargs)

    def fixed_rate_noutput_to_ninput(self, *args, **kwargs):
        """fixed_rate_noutput_to_ninput(decoder self, int noutput) -> int"""
        return _fec_swig.decoder_fixed_rate_noutput_to_ninput(self, *args, **kwargs)

    def forecast(self, *args, **kwargs):
        """forecast(decoder self, int noutput_items, gr_vector_int & ninput_items_required)"""
        return _fec_swig.decoder_forecast(self, *args, **kwargs)

    __swig_destroy__ = _fec_swig.delete_decoder
    __del__ = lambda self : None;
decoder_swigregister = _fec_swig.decoder_swigregister
decoder_swigregister(decoder)

def decoder_make(*args, **kwargs):
  """
    decoder_make(generic_decoder_sptr my_decoder, size_t input_item_size, size_t output_item_size) -> decoder_sptr

    General FEC decoding block that takes in a decoder variable object (derived from gr::fec::general_decoder) for use in a flowgraph.

    This block uses a decoder variable object (derived from gr::fec::generic_decoder) to decode data within a flowgraph. This block interacts with the general FECAPI architecture to handle all passing all input and output data in a flowgraph. The decoder variable takes care of understanding the requirements, data types and sizes, and boundary conditions of the specific FEC decoding algorithm.

    Generally, this block is used within the fec.extended_decoder Python block to handle some input/output formatting issues. In the FECAPI, the decoder variable sets properties like the input and output types and sizes and whether the output is packed or unpacked bytes. The fec.extended_decoder uses this information to set up an gr::hier_block2 structure to make sure the I/O to the variable is handled consistently, such as to make sure all inputs are floats with one soft symbol per item and the outputs are unpacked bytes with the bit in the LSB.

    See gr::fec::generic_decoder for detail on what information an FECAPI variable object can set if using this block directly and not as part of the fec.extended_decoder.

    Constructor Specific Documentation:

    Create the FEC decoder block by taking in the FECAPI decoder object as well as input and output sizes.

    Args:
        my_decoder : An FECAPI decoder object (See gr::fec::generic_decoder).
        input_item_size : The size of the input items (often the my_decoder object can tell us this).
        output_item_size : The size of the output items (often the my_decoder object can tell us this).
    """
  return _fec_swig.decoder_make(*args, **kwargs)

class encoder(object):
    """
    Creates the encoder block for use in GNU Radio flowgraphs from a given FECAPI object derived from the generic_encoder class.

    Generally, we would use the fec.extended_encoder Python implementation to instantiate this. The extended_encoder wraps up a few more details, like taking care of puncturing as well as the encoder itself.

    Constructor Specific Documentation:

    Build the FEC encoder block from an FECAPI encoder object.

    Args:
        my_encoder : An FECAPI encoder object child of the generic_encoder class.
        input_item_size : size of a block of data for the encoder.
        output_item_size : size of a block of data the encoder will produce.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(generic_encoder_sptr my_encoder, size_t input_item_size, size_t output_item_size) -> encoder_sptr

        Creates the encoder block for use in GNU Radio flowgraphs from a given FECAPI object derived from the generic_encoder class.

        Generally, we would use the fec.extended_encoder Python implementation to instantiate this. The extended_encoder wraps up a few more details, like taking care of puncturing as well as the encoder itself.

        Constructor Specific Documentation:

        Build the FEC encoder block from an FECAPI encoder object.

        Args:
            my_encoder : An FECAPI encoder object child of the generic_encoder class.
            input_item_size : size of a block of data for the encoder.
            output_item_size : size of a block of data the encoder will produce.
        """
        return _fec_swig.encoder_make(*args, **kwargs)

    make = staticmethod(make)
    def general_work(self, *args, **kwargs):
        """
        general_work(encoder self, int noutput_items, gr_vector_int & ninput_items, gr_vector_const_void_star & input_items, 
            gr_vector_void_star & output_items) -> int
        """
        return _fec_swig.encoder_general_work(self, *args, **kwargs)

    def fixed_rate_ninput_to_noutput(self, *args, **kwargs):
        """fixed_rate_ninput_to_noutput(encoder self, int ninput) -> int"""
        return _fec_swig.encoder_fixed_rate_ninput_to_noutput(self, *args, **kwargs)

    def fixed_rate_noutput_to_ninput(self, *args, **kwargs):
        """fixed_rate_noutput_to_ninput(encoder self, int noutput) -> int"""
        return _fec_swig.encoder_fixed_rate_noutput_to_ninput(self, *args, **kwargs)

    def forecast(self, *args, **kwargs):
        """forecast(encoder self, int noutput_items, gr_vector_int & ninput_items_required)"""
        return _fec_swig.encoder_forecast(self, *args, **kwargs)

    __swig_destroy__ = _fec_swig.delete_encoder
    __del__ = lambda self : None;
encoder_swigregister = _fec_swig.encoder_swigregister
encoder_swigregister(encoder)

def encoder_make(*args, **kwargs):
  """
    encoder_make(generic_encoder_sptr my_encoder, size_t input_item_size, size_t output_item_size) -> encoder_sptr

    Creates the encoder block for use in GNU Radio flowgraphs from a given FECAPI object derived from the generic_encoder class.

    Generally, we would use the fec.extended_encoder Python implementation to instantiate this. The extended_encoder wraps up a few more details, like taking care of puncturing as well as the encoder itself.

    Constructor Specific Documentation:

    Build the FEC encoder block from an FECAPI encoder object.

    Args:
        my_encoder : An FECAPI encoder object child of the generic_encoder class.
        input_item_size : size of a block of data for the encoder.
        output_item_size : size of a block of data the encoder will produce.
    """
  return _fec_swig.encoder_make(*args, **kwargs)

class tagged_decoder(object):
    """
    General FEC decoding block that takes in a decoder variable object (derived from gr::fec::general_decoder) for use in a flowgraph.

    This block uses a decoder variable object (derived from gr::fec::generic_decoder) to decode data within a flowgraph. This block interacts with the general FECAPI architecture to handle all passing all input and output data in a flowgraph. The decoder variable takes care of understanding the requirements, data types and sizes, and boundary conditions of the specific FEC decoding algorithm.

    Generally, this block is used within the fec.extended_decoder Python block to handle some input/output formatting issues. In the FECAPI, the decoder variable sets properties like the input and output types and sizes and whether the output is packed or unpacked bytes. The fec.extended_decoder uses this information to set up an gr::hier_block2 structure to make sure the I/O to the variable is handled consistently, such as to make sure all inputs are floats with one soft symbol per item and the outputs are unpacked bytes with the bit in the LSB.

    See gr::fec::generic_decoder for detail on what information an FECAPI variable object can set if using this block directly and not as part of the fec.extended_decoder.

    Constructor Specific Documentation:

    Create the FEC decoder block by taking in the FECAPI decoder object as well as input and output sizes.

    Args:
        my_decoder : An FECAPI decoder object (See gr::fec::generic_decoder).
        input_item_size : The size of the input items (often the my_decoder object can tell us this).
        output_item_size : The size of the output items (often the my_decoder object can tell us this).
        lengthtagname : Key name of the tagged stream frame size.
        mtu : The Maximum Transmission Unit (MTU) of the output frame that the block will be able to process. Specified in bytes and defaults to 1500.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(generic_decoder_sptr my_decoder, size_t input_item_size, size_t output_item_size, 
            std::string const & lengthtagname="packet_len", int mtu=1500) -> tagged_decoder_sptr

        General FEC decoding block that takes in a decoder variable object (derived from gr::fec::general_decoder) for use in a flowgraph.

        This block uses a decoder variable object (derived from gr::fec::generic_decoder) to decode data within a flowgraph. This block interacts with the general FECAPI architecture to handle all passing all input and output data in a flowgraph. The decoder variable takes care of understanding the requirements, data types and sizes, and boundary conditions of the specific FEC decoding algorithm.

        Generally, this block is used within the fec.extended_decoder Python block to handle some input/output formatting issues. In the FECAPI, the decoder variable sets properties like the input and output types and sizes and whether the output is packed or unpacked bytes. The fec.extended_decoder uses this information to set up an gr::hier_block2 structure to make sure the I/O to the variable is handled consistently, such as to make sure all inputs are floats with one soft symbol per item and the outputs are unpacked bytes with the bit in the LSB.

        See gr::fec::generic_decoder for detail on what information an FECAPI variable object can set if using this block directly and not as part of the fec.extended_decoder.

        Constructor Specific Documentation:

        Create the FEC decoder block by taking in the FECAPI decoder object as well as input and output sizes.

        Args:
            my_decoder : An FECAPI decoder object (See gr::fec::generic_decoder).
            input_item_size : The size of the input items (often the my_decoder object can tell us this).
            output_item_size : The size of the output items (often the my_decoder object can tell us this).
            lengthtagname : Key name of the tagged stream frame size.
            mtu : The Maximum Transmission Unit (MTU) of the output frame that the block will be able to process. Specified in bytes and defaults to 1500.
        """
        return _fec_swig.tagged_decoder_make(*args, **kwargs)

    make = staticmethod(make)
    def work(self, *args, **kwargs):
        """
        work(tagged_decoder self, int noutput_items, gr_vector_int & ninput_items, gr_vector_const_void_star & input_items, 
            gr_vector_void_star & output_items) -> int
        """
        return _fec_swig.tagged_decoder_work(self, *args, **kwargs)

    def calculate_output_stream_length(self, *args, **kwargs):
        """calculate_output_stream_length(tagged_decoder self, gr_vector_int const & ninput_items) -> int"""
        return _fec_swig.tagged_decoder_calculate_output_stream_length(self, *args, **kwargs)

    __swig_destroy__ = _fec_swig.delete_tagged_decoder
    __del__ = lambda self : None;
tagged_decoder_swigregister = _fec_swig.tagged_decoder_swigregister
tagged_decoder_swigregister(tagged_decoder)

def tagged_decoder_make(*args, **kwargs):
  """
    tagged_decoder_make(generic_decoder_sptr my_decoder, size_t input_item_size, size_t output_item_size, 
        std::string const & lengthtagname="packet_len", int mtu=1500) -> tagged_decoder_sptr

    General FEC decoding block that takes in a decoder variable object (derived from gr::fec::general_decoder) for use in a flowgraph.

    This block uses a decoder variable object (derived from gr::fec::generic_decoder) to decode data within a flowgraph. This block interacts with the general FECAPI architecture to handle all passing all input and output data in a flowgraph. The decoder variable takes care of understanding the requirements, data types and sizes, and boundary conditions of the specific FEC decoding algorithm.

    Generally, this block is used within the fec.extended_decoder Python block to handle some input/output formatting issues. In the FECAPI, the decoder variable sets properties like the input and output types and sizes and whether the output is packed or unpacked bytes. The fec.extended_decoder uses this information to set up an gr::hier_block2 structure to make sure the I/O to the variable is handled consistently, such as to make sure all inputs are floats with one soft symbol per item and the outputs are unpacked bytes with the bit in the LSB.

    See gr::fec::generic_decoder for detail on what information an FECAPI variable object can set if using this block directly and not as part of the fec.extended_decoder.

    Constructor Specific Documentation:

    Create the FEC decoder block by taking in the FECAPI decoder object as well as input and output sizes.

    Args:
        my_decoder : An FECAPI decoder object (See gr::fec::generic_decoder).
        input_item_size : The size of the input items (often the my_decoder object can tell us this).
        output_item_size : The size of the output items (often the my_decoder object can tell us this).
        lengthtagname : Key name of the tagged stream frame size.
        mtu : The Maximum Transmission Unit (MTU) of the output frame that the block will be able to process. Specified in bytes and defaults to 1500.
    """
  return _fec_swig.tagged_decoder_make(*args, **kwargs)

class tagged_encoder(object):
    """
    Creates the encoder block for use in GNU Radio flowgraphs from a given FECAPI object derived from the generic_encoder class.

    Generally, we would use the fec.extended_encoder Python implementation to instantiate this. The extended_encoder wraps up a few more details, like taking care of puncturing as well as the encoder itself.

    Constructor Specific Documentation:

    Build the FEC encoder block from an FECAPI encoder object.

    Args:
        my_encoder : An FECAPI encoder object child of the generic_encoder class.
        input_item_size : size of a block of data for the encoder.
        output_item_size : size of a block of data the encoder will produce.
        lengthtagname : Key name of the tagged stream frame size.
        mtu : The Maximum Transmission Unit (MTU) of the input frame that the block will be able to process. Specified in bytes and defaults to 1500.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(generic_encoder_sptr my_encoder, size_t input_item_size, size_t output_item_size, 
            std::string const & lengthtagname="packet_len", int mtu=1500) -> tagged_encoder_sptr

        Creates the encoder block for use in GNU Radio flowgraphs from a given FECAPI object derived from the generic_encoder class.

        Generally, we would use the fec.extended_encoder Python implementation to instantiate this. The extended_encoder wraps up a few more details, like taking care of puncturing as well as the encoder itself.

        Constructor Specific Documentation:

        Build the FEC encoder block from an FECAPI encoder object.

        Args:
            my_encoder : An FECAPI encoder object child of the generic_encoder class.
            input_item_size : size of a block of data for the encoder.
            output_item_size : size of a block of data the encoder will produce.
            lengthtagname : Key name of the tagged stream frame size.
            mtu : The Maximum Transmission Unit (MTU) of the input frame that the block will be able to process. Specified in bytes and defaults to 1500.
        """
        return _fec_swig.tagged_encoder_make(*args, **kwargs)

    make = staticmethod(make)
    def work(self, *args, **kwargs):
        """
        work(tagged_encoder self, int noutput_items, gr_vector_int & ninput_items, gr_vector_const_void_star & input_items, 
            gr_vector_void_star & output_items) -> int
        """
        return _fec_swig.tagged_encoder_work(self, *args, **kwargs)

    def calculate_output_stream_length(self, *args, **kwargs):
        """calculate_output_stream_length(tagged_encoder self, gr_vector_int const & ninput_items) -> int"""
        return _fec_swig.tagged_encoder_calculate_output_stream_length(self, *args, **kwargs)

    __swig_destroy__ = _fec_swig.delete_tagged_encoder
    __del__ = lambda self : None;
tagged_encoder_swigregister = _fec_swig.tagged_encoder_swigregister
tagged_encoder_swigregister(tagged_encoder)

def tagged_encoder_make(*args, **kwargs):
  """
    tagged_encoder_make(generic_encoder_sptr my_encoder, size_t input_item_size, size_t output_item_size, 
        std::string const & lengthtagname="packet_len", int mtu=1500) -> tagged_encoder_sptr

    Creates the encoder block for use in GNU Radio flowgraphs from a given FECAPI object derived from the generic_encoder class.

    Generally, we would use the fec.extended_encoder Python implementation to instantiate this. The extended_encoder wraps up a few more details, like taking care of puncturing as well as the encoder itself.

    Constructor Specific Documentation:

    Build the FEC encoder block from an FECAPI encoder object.

    Args:
        my_encoder : An FECAPI encoder object child of the generic_encoder class.
        input_item_size : size of a block of data for the encoder.
        output_item_size : size of a block of data the encoder will produce.
        lengthtagname : Key name of the tagged stream frame size.
        mtu : The Maximum Transmission Unit (MTU) of the input frame that the block will be able to process. Specified in bytes and defaults to 1500.
    """
  return _fec_swig.tagged_encoder_make(*args, **kwargs)

class async_decoder(object):
    """
    Creates the decoder block for use in GNU Radio flowgraphs from a given FEC API object derived from the generic_decoder class.

    Decodes frames received as async messages over a message port. This decoder deployment expects messages of soft decision symbols in and can produce either packed, PDU messages ( = True) or messages full of unpacked bits ( = False).

    This decoder works off a full message as one frame or block to decode. The message length is used to calculate the frame length. To support this, the decoder variable used will have had its frame_size set. This block treats that initial frame_size value as the maximum transmission unit (MTU) and will not process frames larger than that after being decoded.

    The packed PDU form of this deployment is designed to work well with other PDU-based blocks to operate within the processing flow of data packets or frames.

    Due to differences in how data is packed and processed, this block also offers the ability to change the direction of how bits are packed. All inputs messages are one soft decision per item. By default, the  mode is set to True. Using this setup allows the async block to behave with PDUs in the same operation and format as the tagged stream decoders. That is, putting the same data into both the tagged stream decoder deployment and this with the default setting should produce the same data.

    Because the block handles data as a full frame per message, this decoder deployment cannot work with any decoders that require history. For example, the gr::fec::code::cc_decoder decoder in streaming mode requires an extra rate*(K-1) bits to complete the decoding, so it would have to wait for the next message to come in and finish processing. Therefore, the streaming mode of the CC decoder is not allowed. The other three modes will work with this deployment since the frame is self-contained for decoding.

    Constructor Specific Documentation:

    Build the PDU-based FEC decoder block from an FECAPI decoder object.

    Args:
        my_decoder : An FECAPI decoder object child of the generic_decoder class.
        packed : Sets output to packed bytes if true; otherwise, 1 bit per byte.
        rev_pack : If packing bits, should they be reversed?
        mtu : The Maximum Transmission Unit (MTU) of the output frame that the block will be able to process. Specified in bytes and defaults to 1500.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(generic_decoder_sptr my_decoder, bool packed=False, bool rev_pack=True, int mtu=1500) -> async_decoder_sptr

        Creates the decoder block for use in GNU Radio flowgraphs from a given FEC API object derived from the generic_decoder class.

        Decodes frames received as async messages over a message port. This decoder deployment expects messages of soft decision symbols in and can produce either packed, PDU messages ( = True) or messages full of unpacked bits ( = False).

        This decoder works off a full message as one frame or block to decode. The message length is used to calculate the frame length. To support this, the decoder variable used will have had its frame_size set. This block treats that initial frame_size value as the maximum transmission unit (MTU) and will not process frames larger than that after being decoded.

        The packed PDU form of this deployment is designed to work well with other PDU-based blocks to operate within the processing flow of data packets or frames.

        Due to differences in how data is packed and processed, this block also offers the ability to change the direction of how bits are packed. All inputs messages are one soft decision per item. By default, the  mode is set to True. Using this setup allows the async block to behave with PDUs in the same operation and format as the tagged stream decoders. That is, putting the same data into both the tagged stream decoder deployment and this with the default setting should produce the same data.

        Because the block handles data as a full frame per message, this decoder deployment cannot work with any decoders that require history. For example, the gr::fec::code::cc_decoder decoder in streaming mode requires an extra rate*(K-1) bits to complete the decoding, so it would have to wait for the next message to come in and finish processing. Therefore, the streaming mode of the CC decoder is not allowed. The other three modes will work with this deployment since the frame is self-contained for decoding.

        Constructor Specific Documentation:

        Build the PDU-based FEC decoder block from an FECAPI decoder object.

        Args:
            my_decoder : An FECAPI decoder object child of the generic_decoder class.
            packed : Sets output to packed bytes if true; otherwise, 1 bit per byte.
            rev_pack : If packing bits, should they be reversed?
            mtu : The Maximum Transmission Unit (MTU) of the output frame that the block will be able to process. Specified in bytes and defaults to 1500.
        """
        return _fec_swig.async_decoder_make(*args, **kwargs)

    make = staticmethod(make)
    def general_work(self, *args, **kwargs):
        """
        general_work(async_decoder self, int noutput_items, gr_vector_int & ninput_items, gr_vector_const_void_star & input_items, 
            gr_vector_void_star & output_items) -> int
        """
        return _fec_swig.async_decoder_general_work(self, *args, **kwargs)

    __swig_destroy__ = _fec_swig.delete_async_decoder
    __del__ = lambda self : None;
async_decoder_swigregister = _fec_swig.async_decoder_swigregister
async_decoder_swigregister(async_decoder)

def async_decoder_make(*args, **kwargs):
  """
    async_decoder_make(generic_decoder_sptr my_decoder, bool packed=False, bool rev_pack=True, int mtu=1500) -> async_decoder_sptr

    Creates the decoder block for use in GNU Radio flowgraphs from a given FEC API object derived from the generic_decoder class.

    Decodes frames received as async messages over a message port. This decoder deployment expects messages of soft decision symbols in and can produce either packed, PDU messages ( = True) or messages full of unpacked bits ( = False).

    This decoder works off a full message as one frame or block to decode. The message length is used to calculate the frame length. To support this, the decoder variable used will have had its frame_size set. This block treats that initial frame_size value as the maximum transmission unit (MTU) and will not process frames larger than that after being decoded.

    The packed PDU form of this deployment is designed to work well with other PDU-based blocks to operate within the processing flow of data packets or frames.

    Due to differences in how data is packed and processed, this block also offers the ability to change the direction of how bits are packed. All inputs messages are one soft decision per item. By default, the  mode is set to True. Using this setup allows the async block to behave with PDUs in the same operation and format as the tagged stream decoders. That is, putting the same data into both the tagged stream decoder deployment and this with the default setting should produce the same data.

    Because the block handles data as a full frame per message, this decoder deployment cannot work with any decoders that require history. For example, the gr::fec::code::cc_decoder decoder in streaming mode requires an extra rate*(K-1) bits to complete the decoding, so it would have to wait for the next message to come in and finish processing. Therefore, the streaming mode of the CC decoder is not allowed. The other three modes will work with this deployment since the frame is self-contained for decoding.

    Constructor Specific Documentation:

    Build the PDU-based FEC decoder block from an FECAPI decoder object.

    Args:
        my_decoder : An FECAPI decoder object child of the generic_decoder class.
        packed : Sets output to packed bytes if true; otherwise, 1 bit per byte.
        rev_pack : If packing bits, should they be reversed?
        mtu : The Maximum Transmission Unit (MTU) of the output frame that the block will be able to process. Specified in bytes and defaults to 1500.
    """
  return _fec_swig.async_decoder_make(*args, **kwargs)

class async_encoder(object):
    """
    Creates the encoder block for use in GNU Radio flowgraphs with async message from a given FEC API object derived from the generic_encoder class.

    Encodes frames received as async messages or as a PDU over a message port. This encoder works off a full message as one frame or block to encode. The message length is used as the frame length. To support this, the encoder variable used will have had its frame_size set. This block treats that initial frame_size value as the maximum transmission unit (MTU) and will not process frames larger than that.

    This deployment works off messages and expects them to either be messages full of unpacked bits or PDU messages, which means full bytes of a frame from the higher layers, including things like headers, tails, CRC check bytes, etc. For handling PDUs, set the  option of this deployment block to True. The block will then use the FEC API to properly unpack the bits from the PDU, pass it through the encoder, and repack them to output the PDUs for the next stage of processing.

    The packed PDU form of this deployment is designed to work well with other PDU-based blocks to operate within the processing flow of data packets or frames.

    Due to differences in how data is packed and processed, this block also offers the ability to change the direction of how bits are unpacked and packed, where reading or writing from the LSB or MSB. By default, the  and  modes are set to True. Using this setup allows the async block to behave with PDUs in the same operation and format as the tagged stream encoders. That is, putting the same data into both the tagged stream encoder deployment and this with these default settings should produce the same data.

    Constructor Specific Documentation:

    Build the PDU-based FEC encoder block from an FECAPI encoder object.

    Args:
        my_encoder : An FECAPI encoder object child of the generic_encoder class.
        packed : True if working on packed bytes (like PDUs).
        rev_unpack : Reverse the unpacking order from input bytes to bits.
        rev_pack : Reverse the packing order from bits to output bytes.
        mtu : The Maximum Transmission Unit (MTU) of the input frame that the block will be able to process. Specified in bytes and defaults to 1500.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(generic_encoder_sptr my_encoder, bool packed=False, bool rev_unpack=True, bool rev_pack=True, 
            int mtu=1500) -> async_encoder_sptr

        Creates the encoder block for use in GNU Radio flowgraphs with async message from a given FEC API object derived from the generic_encoder class.

        Encodes frames received as async messages or as a PDU over a message port. This encoder works off a full message as one frame or block to encode. The message length is used as the frame length. To support this, the encoder variable used will have had its frame_size set. This block treats that initial frame_size value as the maximum transmission unit (MTU) and will not process frames larger than that.

        This deployment works off messages and expects them to either be messages full of unpacked bits or PDU messages, which means full bytes of a frame from the higher layers, including things like headers, tails, CRC check bytes, etc. For handling PDUs, set the  option of this deployment block to True. The block will then use the FEC API to properly unpack the bits from the PDU, pass it through the encoder, and repack them to output the PDUs for the next stage of processing.

        The packed PDU form of this deployment is designed to work well with other PDU-based blocks to operate within the processing flow of data packets or frames.

        Due to differences in how data is packed and processed, this block also offers the ability to change the direction of how bits are unpacked and packed, where reading or writing from the LSB or MSB. By default, the  and  modes are set to True. Using this setup allows the async block to behave with PDUs in the same operation and format as the tagged stream encoders. That is, putting the same data into both the tagged stream encoder deployment and this with these default settings should produce the same data.

        Constructor Specific Documentation:

        Build the PDU-based FEC encoder block from an FECAPI encoder object.

        Args:
            my_encoder : An FECAPI encoder object child of the generic_encoder class.
            packed : True if working on packed bytes (like PDUs).
            rev_unpack : Reverse the unpacking order from input bytes to bits.
            rev_pack : Reverse the packing order from bits to output bytes.
            mtu : The Maximum Transmission Unit (MTU) of the input frame that the block will be able to process. Specified in bytes and defaults to 1500.
        """
        return _fec_swig.async_encoder_make(*args, **kwargs)

    make = staticmethod(make)
    def general_work(self, *args, **kwargs):
        """
        general_work(async_encoder self, int noutput_items, gr_vector_int & ninput_items, gr_vector_const_void_star & input_items, 
            gr_vector_void_star & output_items) -> int
        """
        return _fec_swig.async_encoder_general_work(self, *args, **kwargs)

    __swig_destroy__ = _fec_swig.delete_async_encoder
    __del__ = lambda self : None;
async_encoder_swigregister = _fec_swig.async_encoder_swigregister
async_encoder_swigregister(async_encoder)

def async_encoder_make(*args, **kwargs):
  """
    async_encoder_make(generic_encoder_sptr my_encoder, bool packed=False, bool rev_unpack=True, bool rev_pack=True, 
        int mtu=1500) -> async_encoder_sptr

    Creates the encoder block for use in GNU Radio flowgraphs with async message from a given FEC API object derived from the generic_encoder class.

    Encodes frames received as async messages or as a PDU over a message port. This encoder works off a full message as one frame or block to encode. The message length is used as the frame length. To support this, the encoder variable used will have had its frame_size set. This block treats that initial frame_size value as the maximum transmission unit (MTU) and will not process frames larger than that.

    This deployment works off messages and expects them to either be messages full of unpacked bits or PDU messages, which means full bytes of a frame from the higher layers, including things like headers, tails, CRC check bytes, etc. For handling PDUs, set the  option of this deployment block to True. The block will then use the FEC API to properly unpack the bits from the PDU, pass it through the encoder, and repack them to output the PDUs for the next stage of processing.

    The packed PDU form of this deployment is designed to work well with other PDU-based blocks to operate within the processing flow of data packets or frames.

    Due to differences in how data is packed and processed, this block also offers the ability to change the direction of how bits are unpacked and packed, where reading or writing from the LSB or MSB. By default, the  and  modes are set to True. Using this setup allows the async block to behave with PDUs in the same operation and format as the tagged stream encoders. That is, putting the same data into both the tagged stream encoder deployment and this with these default settings should produce the same data.

    Constructor Specific Documentation:

    Build the PDU-based FEC encoder block from an FECAPI encoder object.

    Args:
        my_encoder : An FECAPI encoder object child of the generic_encoder class.
        packed : True if working on packed bytes (like PDUs).
        rev_unpack : Reverse the unpacking order from input bytes to bits.
        rev_pack : Reverse the packing order from bits to output bytes.
        mtu : The Maximum Transmission Unit (MTU) of the input frame that the block will be able to process. Specified in bytes and defaults to 1500.
    """
  return _fec_swig.async_encoder_make(*args, **kwargs)

class cc_decoder(generic_decoder):
    """
    Convolutional Code Decoding class.

    This class performs convolutional decoding via the Viterbi algorithm. While it is set up to take variable values for K, rate, and the polynomials, currently, the block is only capable of handling the following settings:


    This is the well-known convolutional part of the Voyager code implemented in the CCSDS encoder.

    The intent of having this FECAPI code classes fully parameterizable is to eventually allow it to take on generic settings, much like the cc_encoder class where the CCSDS settings would be a highly-optimized version of this.

    The decoder is set up with a number of bits per frame in the constructor. When not being used in a tagged stream mode, this encoder will only process frames of the length provided here. If used in a tagged stream block, this setting becomes the maximum allowable frame size that the block may process.

    The  is a cc_mode_t that specifies how the convolutional encoder will behave and under what conditions.





    A common convolutional encoder uses K=7, Rate=1/2, Polynomials=[109, 79]. This is the Voyager code from NASA:
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int frame_size, int k, int rate, std::vector< int,std::allocator< int > > polys, 
            int start_state=0, int end_state=-1, cc_mode_t mode=CC_STREAMING, bool padded=False) -> generic_decoder_sptr

        Build a convolutional code decoding FEC API object.
        """
        return _fec_swig.cc_decoder_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_cc_decoder
    __del__ = lambda self : None;
cc_decoder_swigregister = _fec_swig.cc_decoder_swigregister
cc_decoder_swigregister(cc_decoder)

def cc_decoder_make(*args, **kwargs):
  """
    cc_decoder_make(int frame_size, int k, int rate, std::vector< int,std::allocator< int > > polys, 
        int start_state=0, int end_state=-1, cc_mode_t mode=CC_STREAMING, bool padded=False) -> generic_decoder_sptr

    Build a convolutional code decoding FEC API object.
    """
  return _fec_swig.cc_decoder_make(*args, **kwargs)

class cc_encoder(generic_encoder):
    """
    Convolutional Code Encoding class.

    This class performs convolutional encoding for unpacked bits for frames of a constant length. This class is general in its application of the convolutional encoding and allows us to specify the constraint length, the coding rate, and the polynomials used in the coding process.

    The parameter  sets the constraint length directly. We set the coding rate by setting  to R given a desired rate of 1/R. That is, for a rate 1/2 coder, we would set  to 2. And the polynomial is specified as a vector of integers, where each integer represents the coding polynomial for a different arm of the code. The number of polynomials given must be the same as the value .

    The encoding object holds a shift register that takes in each bit from the input stream and then ANDs the shift register with each polynomial, and places the parity of the result into the output stream. The output stream is therefore also unpacked bits.

    The encoder is set up with a number of bits per frame in the constructor. When not being used in a tagged stream mode, this encoder will only process frames of the length provided here. If used in a tagged stream block, this setting becomes the maximum allowable frame size that the block may process.

    The  is a cc_mode_t that specifies how the convolutional encoder will behave and under what conditions.





    A common convolutional encoder uses K=7, Rate=1/2, Polynomials=[109, 79]. This is the Voyager code from NASA: 
    Another encoder class is provided with gr-fec called the gr::fec::code::ccsds_encoder, which implements the above code that is more highly optimized for just those specific settings.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int frame_size, int k, int rate, std::vector< int,std::allocator< int > > polys, 
            int start_state=0, cc_mode_t mode=CC_STREAMING, bool padded=False) -> generic_encoder_sptr

        Build a convolutional code encoding FEC API object.
        """
        return _fec_swig.cc_encoder_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_cc_encoder
    __del__ = lambda self : None;
cc_encoder_swigregister = _fec_swig.cc_encoder_swigregister
cc_encoder_swigregister(cc_encoder)

def cc_encoder_make(*args, **kwargs):
  """
    cc_encoder_make(int frame_size, int k, int rate, std::vector< int,std::allocator< int > > polys, 
        int start_state=0, cc_mode_t mode=CC_STREAMING, bool padded=False) -> generic_encoder_sptr

    Build a convolutional code encoding FEC API object.
    """
  return _fec_swig.cc_encoder_make(*args, **kwargs)

class ccsds_encoder(generic_encoder):
    """
    CCSDS Encoding class for convolutional encoding with rate 1/2, K=7, and polynomials [109, 79].

    Uses Phil Karn's (KA9Q) implementation of the CCSDS encoder for rate 1/2, K=7, and CC polynomial [109, 79]. These are non-adjustable in this encoder. For an adjustable CC encoder where we can set the rate, constraint length, and polynomial, see gr::fec::code::cc_encoder.

    The encoder is set up with a number of bits per frame in the constructor. When not being used in a tagged stream mode, this encoder will only process frames of the length provided here. If used in a tagged stream block, this setting becomes the maximum allowable frame size that the block may process.

    The  is a cc_mode_t that specifies how the convolutional encoder will behave and under what conditions.





    A common convolutional encoder uses K=7, Rate=1/2, Polynomials=[109, 79]. This is the Voyager code from NASA:
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int frame_size, int start_state=0, cc_mode_t mode=CC_STREAMING) -> generic_encoder_sptr

        Build the CCSDS (rate=1/2, K=7, polys=[109,79] convolutional code FECAPI object.
        """
        return _fec_swig.ccsds_encoder_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_ccsds_encoder
    __del__ = lambda self : None;
ccsds_encoder_swigregister = _fec_swig.ccsds_encoder_swigregister
ccsds_encoder_swigregister(ccsds_encoder)

def ccsds_encoder_make(*args, **kwargs):
  """
    ccsds_encoder_make(int frame_size, int start_state=0, cc_mode_t mode=CC_STREAMING) -> generic_encoder_sptr

    Build the CCSDS (rate=1/2, K=7, polys=[109,79] convolutional code FECAPI object.
    """
  return _fec_swig.ccsds_encoder_make(*args, **kwargs)

class dummy_decoder(generic_decoder):
    """
    Dummy Decoding class.

    A dummy decoder class that simply passes the input to the output. It is meant to allow us to easily use the FEC API encoder and decoder blocks in an application with no coding.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int frame_size) -> generic_decoder_sptr

        Build a dummy decoding FEC API object.
        """
        return _fec_swig.dummy_decoder_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_dummy_decoder
    __del__ = lambda self : None;
dummy_decoder_swigregister = _fec_swig.dummy_decoder_swigregister
dummy_decoder_swigregister(dummy_decoder)

def dummy_decoder_make(*args, **kwargs):
  """
    dummy_decoder_make(int frame_size) -> generic_decoder_sptr

    Build a dummy decoding FEC API object.
    """
  return _fec_swig.dummy_decoder_make(*args, **kwargs)

class dummy_encoder(generic_encoder):
    """
    Dummy Encoding class.

    A dummy encoder class that simply passes the input to the output. It is meant to allow us to easily use the FEC API encoder and decoder blocks in an application with no coding.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int frame_size, bool pack=False, bool packed_bits=False) -> generic_encoder_sptr

        Build a dummy encoding FEC API object.
        """
        return _fec_swig.dummy_encoder_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_dummy_encoder
    __del__ = lambda self : None;
dummy_encoder_swigregister = _fec_swig.dummy_encoder_swigregister
dummy_encoder_swigregister(dummy_encoder)

def dummy_encoder_make(*args, **kwargs):
  """
    dummy_encoder_make(int frame_size, bool pack=False, bool packed_bits=False) -> generic_encoder_sptr

    Build a dummy encoding FEC API object.
    """
  return _fec_swig.dummy_encoder_make(*args, **kwargs)

class repetition_decoder(generic_decoder):
    """
    Repetition Decoding class.

    A repetition decoder class. This takes a majority vote, biased by the  rate, and decides if the number of 1 bits > ap_prob, it is a 1; else, it is a 0.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int frame_size, int rep, float ap_prob=0.5) -> generic_decoder_sptr

        Build a repetition decoding FEC API object.
        """
        return _fec_swig.repetition_decoder_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_repetition_decoder
    __del__ = lambda self : None;
repetition_decoder_swigregister = _fec_swig.repetition_decoder_swigregister
repetition_decoder_swigregister(repetition_decoder)

def repetition_decoder_make(*args, **kwargs):
  """
    repetition_decoder_make(int frame_size, int rep, float ap_prob=0.5) -> generic_decoder_sptr

    Build a repetition decoding FEC API object.
    """
  return _fec_swig.repetition_decoder_make(*args, **kwargs)

class repetition_encoder(generic_encoder):
    """
    Repetition Encoding class.

    A repetition encoder class that repeats each input bit  times. To decode, take a majority vote over the number of repetitions.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int frame_size, int rep) -> generic_encoder_sptr

        Build a repetition encoding FEC API object.
        """
        return _fec_swig.repetition_encoder_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_repetition_encoder
    __del__ = lambda self : None;
repetition_encoder_swigregister = _fec_swig.repetition_encoder_swigregister
repetition_encoder_swigregister(repetition_encoder)

def repetition_encoder_make(*args, **kwargs):
  """
    repetition_encoder_make(int frame_size, int rep) -> generic_encoder_sptr

    Build a repetition encoding FEC API object.
    """
  return _fec_swig.repetition_encoder_make(*args, **kwargs)

class decode_ccsds_27_fb(object):
    """
    A rate 1/2, k=7 convolutional decoder for the CCSDS standard.

    This block performs soft-decision convolutional decoding using the Viterbi algorithm.

    The input is a stream of (possibly noise corrupted) floating point values nominally spanning [-1.0, 1.0], representing the encoded channel symbols 0 (-1.0) and 1 (1.0), with erased symbols at 0.0.

    The output is MSB first packed bytes of decoded values.

    As a rate 1/2 code, there will be one output byte for every 16 input symbols.

    This block is designed for continuous data streaming, not packetized data. The first 32 bits out will be zeroes, with the output delayed four bytes from the corresponding inputs.

    Constructor Specific Documentation:


    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make():
        """
        make() -> decode_ccsds_27_fb_sptr

        A rate 1/2, k=7 convolutional decoder for the CCSDS standard.

        This block performs soft-decision convolutional decoding using the Viterbi algorithm.

        The input is a stream of (possibly noise corrupted) floating point values nominally spanning [-1.0, 1.0], representing the encoded channel symbols 0 (-1.0) and 1 (1.0), with erased symbols at 0.0.

        The output is MSB first packed bytes of decoded values.

        As a rate 1/2 code, there will be one output byte for every 16 input symbols.

        This block is designed for continuous data streaming, not packetized data. The first 32 bits out will be zeroes, with the output delayed four bytes from the corresponding inputs.

        Constructor Specific Documentation:


        """
        return _fec_swig.decode_ccsds_27_fb_make()

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_decode_ccsds_27_fb
    __del__ = lambda self : None;
decode_ccsds_27_fb_swigregister = _fec_swig.decode_ccsds_27_fb_swigregister
decode_ccsds_27_fb_swigregister(decode_ccsds_27_fb)

def decode_ccsds_27_fb_make():
  """
    decode_ccsds_27_fb_make() -> decode_ccsds_27_fb_sptr

    A rate 1/2, k=7 convolutional decoder for the CCSDS standard.

    This block performs soft-decision convolutional decoding using the Viterbi algorithm.

    The input is a stream of (possibly noise corrupted) floating point values nominally spanning [-1.0, 1.0], representing the encoded channel symbols 0 (-1.0) and 1 (1.0), with erased symbols at 0.0.

    The output is MSB first packed bytes of decoded values.

    As a rate 1/2 code, there will be one output byte for every 16 input symbols.

    This block is designed for continuous data streaming, not packetized data. The first 32 bits out will be zeroes, with the output delayed four bytes from the corresponding inputs.

    Constructor Specific Documentation:


    """
  return _fec_swig.decode_ccsds_27_fb_make()

class encode_ccsds_27_bb(object):
    """
    A rate 1/2, k=7 convolutional encoder for the CCSDS standard.

    This block performs convolutional encoding using the CCSDS standard polynomial ("Voyager").

    The input is an MSB first packed stream of bits.

    The output is a stream of symbols 0 or 1 representing the encoded data.

    As a rate 1/2 code, there will be 16 output symbols for every input byte.

    This block is designed for continuous data streaming, not packetized data. There is no provision to "flush" the encoder.

    Constructor Specific Documentation:


    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make():
        """
        make() -> encode_ccsds_27_bb_sptr

        A rate 1/2, k=7 convolutional encoder for the CCSDS standard.

        This block performs convolutional encoding using the CCSDS standard polynomial ("Voyager").

        The input is an MSB first packed stream of bits.

        The output is a stream of symbols 0 or 1 representing the encoded data.

        As a rate 1/2 code, there will be 16 output symbols for every input byte.

        This block is designed for continuous data streaming, not packetized data. There is no provision to "flush" the encoder.

        Constructor Specific Documentation:


        """
        return _fec_swig.encode_ccsds_27_bb_make()

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_encode_ccsds_27_bb
    __del__ = lambda self : None;
encode_ccsds_27_bb_swigregister = _fec_swig.encode_ccsds_27_bb_swigregister
encode_ccsds_27_bb_swigregister(encode_ccsds_27_bb)

def encode_ccsds_27_bb_make():
  """
    encode_ccsds_27_bb_make() -> encode_ccsds_27_bb_sptr

    A rate 1/2, k=7 convolutional encoder for the CCSDS standard.

    This block performs convolutional encoding using the CCSDS standard polynomial ("Voyager").

    The input is an MSB first packed stream of bits.

    The output is a stream of symbols 0 or 1 representing the encoded data.

    As a rate 1/2 code, there will be 16 output symbols for every input byte.

    This block is designed for continuous data streaming, not packetized data. There is no provision to "flush" the encoder.

    Constructor Specific Documentation:


    """
  return _fec_swig.encode_ccsds_27_bb_make()

class ber_bf(object):
    """
    BER block in FECAPI.

    This block measures the bit error rate between two streams of packed data. It compares the bits of each streams and counts the number of incorrect bits between them. It outputs the log of the bit error rate, so a value of -X is 10^{-X} bit errors.

    When the  is set to false (default), it is in streaming mode. This means that the output is constantly producing the current value of the BER. In this mode, there is a single output BER calculation per chunk of bytes passed to it, so there is no exact timing between calculations of BER. In this mode, the other two parameters to the constructor are ignored.

    When  is true, the block is in test mode. This mode is used in the ber_curve_gen example and for other offline analysis of BER curves. Here, the block waits until at least  are observed and then produces a BER calculation. The parameter  helps make sure that the simulation is controlled. If the BER calculation drops below the  setting, the block will exit and simply return the set limit; the real BER is therefore some amount lower than this.

    Note that this block takes in data as packed bytes with 8-bits per byte used. It outputs a stream of floats as the log-scale BER.

    Constructor Specific Documentation:

    Calculate the BER between two streams of data.

    Args:
        test_mode : false for normal streaming mode (default); true for test mode.
        berminerrors : the block needs to observe this many errors before outputting a result. Only valid when test_mode=true.
        ber_limit : if the BER calculation falls below this limit, produce this value and exit. Only valid when test_mode=true.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def total_errors(self):
        """
        total_errors(ber_bf self) -> long

        Get total number of errors counter value.
        """
        return _fec_swig.ber_bf_total_errors(self)

    def make(*args, **kwargs):
        """
        make(bool test_mode=False, int berminerrors=100, float ber_limit=-7.0) -> ber_bf_sptr

        BER block in FECAPI.

        This block measures the bit error rate between two streams of packed data. It compares the bits of each streams and counts the number of incorrect bits between them. It outputs the log of the bit error rate, so a value of -X is 10^{-X} bit errors.

        When the  is set to false (default), it is in streaming mode. This means that the output is constantly producing the current value of the BER. In this mode, there is a single output BER calculation per chunk of bytes passed to it, so there is no exact timing between calculations of BER. In this mode, the other two parameters to the constructor are ignored.

        When  is true, the block is in test mode. This mode is used in the ber_curve_gen example and for other offline analysis of BER curves. Here, the block waits until at least  are observed and then produces a BER calculation. The parameter  helps make sure that the simulation is controlled. If the BER calculation drops below the  setting, the block will exit and simply return the set limit; the real BER is therefore some amount lower than this.

        Note that this block takes in data as packed bytes with 8-bits per byte used. It outputs a stream of floats as the log-scale BER.

        Constructor Specific Documentation:

        Calculate the BER between two streams of data.

        Args:
            test_mode : false for normal streaming mode (default); true for test mode.
            berminerrors : the block needs to observe this many errors before outputting a result. Only valid when test_mode=true.
            ber_limit : if the BER calculation falls below this limit, produce this value and exit. Only valid when test_mode=true.
        """
        return _fec_swig.ber_bf_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_ber_bf
    __del__ = lambda self : None;
ber_bf_swigregister = _fec_swig.ber_bf_swigregister
ber_bf_swigregister(ber_bf)

def ber_bf_make(*args, **kwargs):
  """
    ber_bf_make(bool test_mode=False, int berminerrors=100, float ber_limit=-7.0) -> ber_bf_sptr

    BER block in FECAPI.

    This block measures the bit error rate between two streams of packed data. It compares the bits of each streams and counts the number of incorrect bits between them. It outputs the log of the bit error rate, so a value of -X is 10^{-X} bit errors.

    When the  is set to false (default), it is in streaming mode. This means that the output is constantly producing the current value of the BER. In this mode, there is a single output BER calculation per chunk of bytes passed to it, so there is no exact timing between calculations of BER. In this mode, the other two parameters to the constructor are ignored.

    When  is true, the block is in test mode. This mode is used in the ber_curve_gen example and for other offline analysis of BER curves. Here, the block waits until at least  are observed and then produces a BER calculation. The parameter  helps make sure that the simulation is controlled. If the BER calculation drops below the  setting, the block will exit and simply return the set limit; the real BER is therefore some amount lower than this.

    Note that this block takes in data as packed bytes with 8-bits per byte used. It outputs a stream of floats as the log-scale BER.

    Constructor Specific Documentation:

    Calculate the BER between two streams of data.

    Args:
        test_mode : false for normal streaming mode (default); true for test mode.
        berminerrors : the block needs to observe this many errors before outputting a result. Only valid when test_mode=true.
        ber_limit : if the BER calculation falls below this limit, produce this value and exit. Only valid when test_mode=true.
    """
  return _fec_swig.ber_bf_make(*args, **kwargs)

class conv_bit_corr_bb(object):
    """
    Correlate block in FECAPI.

    What does this block do?

    Constructor Specific Documentation:



    Args:
        correlator : 
        corr_sym : 
        corr_len : 
        cut : 
        flush : 
        thresh : 
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< unsigned long long,std::allocator< unsigned long long > > correlator, 
            int corr_sym, int corr_len, int cut, int flush, float thresh) -> conv_bit_corr_bb_sptr

        Correlate block in FECAPI.

        What does this block do?

        Constructor Specific Documentation:



        Args:
            correlator : 
            corr_sym : 
            corr_len : 
            cut : 
            flush : 
            thresh : 
        """
        return _fec_swig.conv_bit_corr_bb_make(*args, **kwargs)

    make = staticmethod(make)
    def data_garble_rate(self, *args, **kwargs):
        """
        data_garble_rate(conv_bit_corr_bb self, int taps, float syn_density) -> float

        This subroutine will find the encoded data garble rate corresponding to a syndrome density of `target', that is created with an annihilating polynomial with 'taps' number of taps.
        """
        return _fec_swig.conv_bit_corr_bb_data_garble_rate(self, *args, **kwargs)

    __swig_destroy__ = _fec_swig.delete_conv_bit_corr_bb
    __del__ = lambda self : None;
conv_bit_corr_bb_swigregister = _fec_swig.conv_bit_corr_bb_swigregister
conv_bit_corr_bb_swigregister(conv_bit_corr_bb)

def conv_bit_corr_bb_make(*args, **kwargs):
  """
    conv_bit_corr_bb_make(std::vector< unsigned long long,std::allocator< unsigned long long > > correlator, 
        int corr_sym, int corr_len, int cut, int flush, float thresh) -> conv_bit_corr_bb_sptr

    Correlate block in FECAPI.

    What does this block do?

    Constructor Specific Documentation:



    Args:
        correlator : 
        corr_sym : 
        corr_len : 
        cut : 
        flush : 
        thresh : 
    """
  return _fec_swig.conv_bit_corr_bb_make(*args, **kwargs)

class puncture_bb(object):
    """
    Puncture a stream of unpacked bits.

    Puncture a given block of input samples of . The items produced is based on pattern . Basically, if:



    This block is designed for unpacked bits - that is, every input sample is a bit, either a 1 or 0. It's possible to use packed bits as symbols, but the puncturing will be done on the symbol level, not the bit level.

     is specified as a 32-bit integer that we can convert into the vector _puncpat used in the algorithm above:



    Example: 

    The gr.fec Python module provides a read_bitlist function that can turn a string of a puncture pattern into the correct integer form. The pattern of 0xEF could be specified as fec.readbitlist("11101111"). Also, this allows us to use puncsize=len("11101111") to make sure that our sizes are set up correctly for the pattern we want.

    The fec.extended_encoder takes in the puncture pattern directly as a string and uses the readbitlist inside to do the conversion.

    Note that due to the above concept, the default setting in the extended encoder of '11' translates into no puncturing.

    The  parameter delays the application of the puncture pattern. This is equivalent to circularly rotating the  by . Note that because of the circular shift, the delay should be between 0 and , but this is not enforced; the effective delay will simply be  mod . A negative value here is ignored.

    Constructor Specific Documentation:

    Constructs a puncture block for unpacked bits.

    Args:
        puncsize : Size of block of bits to puncture
        puncpat : The puncturing pattern
        delay : Delayed the puncturing pattern by shifting it
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int puncsize, int puncpat, int delay=0) -> puncture_bb_sptr

        Puncture a stream of unpacked bits.

        Puncture a given block of input samples of . The items produced is based on pattern . Basically, if:



        This block is designed for unpacked bits - that is, every input sample is a bit, either a 1 or 0. It's possible to use packed bits as symbols, but the puncturing will be done on the symbol level, not the bit level.

         is specified as a 32-bit integer that we can convert into the vector _puncpat used in the algorithm above:



        Example: 

        The gr.fec Python module provides a read_bitlist function that can turn a string of a puncture pattern into the correct integer form. The pattern of 0xEF could be specified as fec.readbitlist("11101111"). Also, this allows us to use puncsize=len("11101111") to make sure that our sizes are set up correctly for the pattern we want.

        The fec.extended_encoder takes in the puncture pattern directly as a string and uses the readbitlist inside to do the conversion.

        Note that due to the above concept, the default setting in the extended encoder of '11' translates into no puncturing.

        The  parameter delays the application of the puncture pattern. This is equivalent to circularly rotating the  by . Note that because of the circular shift, the delay should be between 0 and , but this is not enforced; the effective delay will simply be  mod . A negative value here is ignored.

        Constructor Specific Documentation:

        Constructs a puncture block for unpacked bits.

        Args:
            puncsize : Size of block of bits to puncture
            puncpat : The puncturing pattern
            delay : Delayed the puncturing pattern by shifting it
        """
        return _fec_swig.puncture_bb_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_puncture_bb
    __del__ = lambda self : None;
puncture_bb_swigregister = _fec_swig.puncture_bb_swigregister
puncture_bb_swigregister(puncture_bb)

def puncture_bb_make(*args, **kwargs):
  """
    puncture_bb_make(int puncsize, int puncpat, int delay=0) -> puncture_bb_sptr

    Puncture a stream of unpacked bits.

    Puncture a given block of input samples of . The items produced is based on pattern . Basically, if:



    This block is designed for unpacked bits - that is, every input sample is a bit, either a 1 or 0. It's possible to use packed bits as symbols, but the puncturing will be done on the symbol level, not the bit level.

     is specified as a 32-bit integer that we can convert into the vector _puncpat used in the algorithm above:



    Example: 

    The gr.fec Python module provides a read_bitlist function that can turn a string of a puncture pattern into the correct integer form. The pattern of 0xEF could be specified as fec.readbitlist("11101111"). Also, this allows us to use puncsize=len("11101111") to make sure that our sizes are set up correctly for the pattern we want.

    The fec.extended_encoder takes in the puncture pattern directly as a string and uses the readbitlist inside to do the conversion.

    Note that due to the above concept, the default setting in the extended encoder of '11' translates into no puncturing.

    The  parameter delays the application of the puncture pattern. This is equivalent to circularly rotating the  by . Note that because of the circular shift, the delay should be between 0 and , but this is not enforced; the effective delay will simply be  mod . A negative value here is ignored.

    Constructor Specific Documentation:

    Constructs a puncture block for unpacked bits.

    Args:
        puncsize : Size of block of bits to puncture
        puncpat : The puncturing pattern
        delay : Delayed the puncturing pattern by shifting it
    """
  return _fec_swig.puncture_bb_make(*args, **kwargs)

class puncture_ff(object):
    """
    Puncture a stream of floats.

    For a given block of input samples of , the items produced is based on . Basically, if:



    This block is designed for floats, generally 1's and -1's. It's possible to use other float values as symbols, but this is not the expected operation.

     is specified as a 32-bit integer that we can convert into the vector _puncpat used in the algorithm above:



    Example: 

    The gr.fec Python module provides a read_bitlist function that can turn a string of a puncture pattern into the correct integer form. The pattern of 0xEF could be specified as fec.readbitlist("11101111"). Also, this allows us to use puncsize=len("11101111") to make sure that our sizes are set up correctly for the pattern we want.

    The fec.extended_encoder takes in the puncture pattern directly as a string and uses the readbitlist inside to do the conversion.

    Note that due to the above concept, the default setting in the extended encoder of '11' translates into no puncturing.

    The  parameter delays the application of the puncture pattern. This is equivalent to circularly rotating the  by . Note that because of the circular shift, the delay should be between 0 and , but this is not enforced; the effective delay will simply be  mod . A negative value here is ignored.

    Constructor Specific Documentation:

    Constructs a puncture block for floats.

    Args:
        puncsize : Size of block of bits to puncture
        puncpat : The puncturing pattern
        delay : Delayed the puncturing pattern by shifting it
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int puncsize, int puncpat, int delay) -> puncture_ff_sptr

        Puncture a stream of floats.

        For a given block of input samples of , the items produced is based on . Basically, if:



        This block is designed for floats, generally 1's and -1's. It's possible to use other float values as symbols, but this is not the expected operation.

         is specified as a 32-bit integer that we can convert into the vector _puncpat used in the algorithm above:



        Example: 

        The gr.fec Python module provides a read_bitlist function that can turn a string of a puncture pattern into the correct integer form. The pattern of 0xEF could be specified as fec.readbitlist("11101111"). Also, this allows us to use puncsize=len("11101111") to make sure that our sizes are set up correctly for the pattern we want.

        The fec.extended_encoder takes in the puncture pattern directly as a string and uses the readbitlist inside to do the conversion.

        Note that due to the above concept, the default setting in the extended encoder of '11' translates into no puncturing.

        The  parameter delays the application of the puncture pattern. This is equivalent to circularly rotating the  by . Note that because of the circular shift, the delay should be between 0 and , but this is not enforced; the effective delay will simply be  mod . A negative value here is ignored.

        Constructor Specific Documentation:

        Constructs a puncture block for floats.

        Args:
            puncsize : Size of block of bits to puncture
            puncpat : The puncturing pattern
            delay : Delayed the puncturing pattern by shifting it
        """
        return _fec_swig.puncture_ff_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_puncture_ff
    __del__ = lambda self : None;
puncture_ff_swigregister = _fec_swig.puncture_ff_swigregister
puncture_ff_swigregister(puncture_ff)

def puncture_ff_make(*args, **kwargs):
  """
    puncture_ff_make(int puncsize, int puncpat, int delay) -> puncture_ff_sptr

    Puncture a stream of floats.

    For a given block of input samples of , the items produced is based on . Basically, if:



    This block is designed for floats, generally 1's and -1's. It's possible to use other float values as symbols, but this is not the expected operation.

     is specified as a 32-bit integer that we can convert into the vector _puncpat used in the algorithm above:



    Example: 

    The gr.fec Python module provides a read_bitlist function that can turn a string of a puncture pattern into the correct integer form. The pattern of 0xEF could be specified as fec.readbitlist("11101111"). Also, this allows us to use puncsize=len("11101111") to make sure that our sizes are set up correctly for the pattern we want.

    The fec.extended_encoder takes in the puncture pattern directly as a string and uses the readbitlist inside to do the conversion.

    Note that due to the above concept, the default setting in the extended encoder of '11' translates into no puncturing.

    The  parameter delays the application of the puncture pattern. This is equivalent to circularly rotating the  by . Note that because of the circular shift, the delay should be between 0 and , but this is not enforced; the effective delay will simply be  mod . A negative value here is ignored.

    Constructor Specific Documentation:

    Constructs a puncture block for floats.

    Args:
        puncsize : Size of block of bits to puncture
        puncpat : The puncturing pattern
        delay : Delayed the puncturing pattern by shifting it
    """
  return _fec_swig.puncture_ff_make(*args, **kwargs)

class depuncture_bb(object):
    """
    Depuncture a stream of samples.

    Depuncture a given block of input samples of . The items produced is based on the pattern . Basically, if:



    This block is designed for unpacked bits - that is, every input sample is a bit, either a 1 or 0. It's possible to use packed bits as symbols, but the depuncturing will be done on the symbol level, not the bit level.

     is specified as a 32-bit integer that we can convert into the vector _puncpat used in the algorithm above:



    Example: 

    The gr.fec Python module provides a read_bitlist function that can turn a string of a puncture pattern into the correct integer form. The pattern of 0xEF could be specified as fec.readbitlist("11101111"). Also, this allows us to use puncsize=len("11101111") to make sure that our sizes are set up correctly for the pattern we want.

    The fec.extended_decoder takes in the puncture pattern directly as a string and uses the readbitlist inside to do the conversion.

    The  parameter delays the application of the puncture pattern. This is equivalent to circularly rotating the  by . Note that because of the circular shift, the delay should be between 0 and , but this is not enforced; the effective delay will simply be  mod . A negative value here is ignored.

    Constructor Specific Documentation:

    Constructs a depuncture block.

    Args:
        puncsize : Size of block of bits to puncture
        puncpat : The puncturing pattern
        delay : Delayed the puncturing pattern by shifting it
        symbol : The symbol to reinsert into the stream (def=127)
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int puncsize, int puncpat, int delay=0, char symbol=127) -> depuncture_bb_sptr

        Depuncture a stream of samples.

        Depuncture a given block of input samples of . The items produced is based on the pattern . Basically, if:



        This block is designed for unpacked bits - that is, every input sample is a bit, either a 1 or 0. It's possible to use packed bits as symbols, but the depuncturing will be done on the symbol level, not the bit level.

         is specified as a 32-bit integer that we can convert into the vector _puncpat used in the algorithm above:



        Example: 

        The gr.fec Python module provides a read_bitlist function that can turn a string of a puncture pattern into the correct integer form. The pattern of 0xEF could be specified as fec.readbitlist("11101111"). Also, this allows us to use puncsize=len("11101111") to make sure that our sizes are set up correctly for the pattern we want.

        The fec.extended_decoder takes in the puncture pattern directly as a string and uses the readbitlist inside to do the conversion.

        The  parameter delays the application of the puncture pattern. This is equivalent to circularly rotating the  by . Note that because of the circular shift, the delay should be between 0 and , but this is not enforced; the effective delay will simply be  mod . A negative value here is ignored.

        Constructor Specific Documentation:

        Constructs a depuncture block.

        Args:
            puncsize : Size of block of bits to puncture
            puncpat : The puncturing pattern
            delay : Delayed the puncturing pattern by shifting it
            symbol : The symbol to reinsert into the stream (def=127)
        """
        return _fec_swig.depuncture_bb_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_depuncture_bb
    __del__ = lambda self : None;
depuncture_bb_swigregister = _fec_swig.depuncture_bb_swigregister
depuncture_bb_swigregister(depuncture_bb)

def depuncture_bb_make(*args, **kwargs):
  """
    depuncture_bb_make(int puncsize, int puncpat, int delay=0, char symbol=127) -> depuncture_bb_sptr

    Depuncture a stream of samples.

    Depuncture a given block of input samples of . The items produced is based on the pattern . Basically, if:



    This block is designed for unpacked bits - that is, every input sample is a bit, either a 1 or 0. It's possible to use packed bits as symbols, but the depuncturing will be done on the symbol level, not the bit level.

     is specified as a 32-bit integer that we can convert into the vector _puncpat used in the algorithm above:



    Example: 

    The gr.fec Python module provides a read_bitlist function that can turn a string of a puncture pattern into the correct integer form. The pattern of 0xEF could be specified as fec.readbitlist("11101111"). Also, this allows us to use puncsize=len("11101111") to make sure that our sizes are set up correctly for the pattern we want.

    The fec.extended_decoder takes in the puncture pattern directly as a string and uses the readbitlist inside to do the conversion.

    The  parameter delays the application of the puncture pattern. This is equivalent to circularly rotating the  by . Note that because of the circular shift, the delay should be between 0 and , but this is not enforced; the effective delay will simply be  mod . A negative value here is ignored.

    Constructor Specific Documentation:

    Constructs a depuncture block.

    Args:
        puncsize : Size of block of bits to puncture
        puncpat : The puncturing pattern
        delay : Delayed the puncturing pattern by shifting it
        symbol : The symbol to reinsert into the stream (def=127)
    """
  return _fec_swig.depuncture_bb_make(*args, **kwargs)

class tpc_encoder(generic_encoder):
    """Proxy of C++ gr::fec::tpc_encoder class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _fec_swig.delete_tpc_encoder
    __del__ = lambda self : None;
    def make(*args, **kwargs):
        """
        make(std::vector< int,std::allocator< int > > row_poly, std::vector< int,std::allocator< int > > col_poly, 
            int krow, int kcol, int bval, int qval) -> generic_encoder_sptr
        """
        return _fec_swig.tpc_encoder_make(*args, **kwargs)

    make = staticmethod(make)
tpc_encoder_swigregister = _fec_swig.tpc_encoder_swigregister
tpc_encoder_swigregister(tpc_encoder)

def tpc_encoder_make(*args, **kwargs):
  """
    tpc_encoder_make(std::vector< int,std::allocator< int > > row_poly, std::vector< int,std::allocator< int > > col_poly, 
        int krow, int kcol, int bval, int qval) -> generic_encoder_sptr
    """
  return _fec_swig.tpc_encoder_make(*args, **kwargs)

MAXLOG = _fec_swig.MAXLOG
class tpc_decoder(generic_decoder):
    """Proxy of C++ gr::fec::tpc_decoder class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::vector< int,std::allocator< int > > row_poly, std::vector< int,std::allocator< int > > col_poly, 
            int krow, int kcol, int bval, int qval, int max_iter, 
            int decoder_type) -> generic_decoder_sptr
        """
        return _fec_swig.tpc_decoder_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_tpc_decoder
    __del__ = lambda self : None;
tpc_decoder_swigregister = _fec_swig.tpc_decoder_swigregister
tpc_decoder_swigregister(tpc_decoder)

def tpc_decoder_make(*args, **kwargs):
  """
    tpc_decoder_make(std::vector< int,std::allocator< int > > row_poly, std::vector< int,std::allocator< int > > col_poly, 
        int krow, int kcol, int bval, int qval, int max_iter, 
        int decoder_type) -> generic_decoder_sptr
    """
  return _fec_swig.tpc_decoder_make(*args, **kwargs)

class polar_encoder(generic_encoder):
    """
    POLAR encoder for basic details see 'polar_common' class.

    expects values with MSB first. It needs a full information word and encodes it in one pass. Output is a codeword of block_size.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int block_size, int num_info_bits, std::vector< int,std::allocator< int > > frozen_bit_positions, 
            std::vector< char,std::allocator< char > > frozen_bit_values, 
            bool is_packed=False) -> generic_encoder_sptr

        Factory for a polar code encoder object.
        """
        return _fec_swig.polar_encoder_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_polar_encoder
    __del__ = lambda self : None;
polar_encoder_swigregister = _fec_swig.polar_encoder_swigregister
polar_encoder_swigregister(polar_encoder)

def polar_encoder_make(*args, **kwargs):
  """
    polar_encoder_make(int block_size, int num_info_bits, std::vector< int,std::allocator< int > > frozen_bit_positions, 
        std::vector< char,std::allocator< char > > frozen_bit_values, 
        bool is_packed=False) -> generic_encoder_sptr

    Factory for a polar code encoder object.
    """
  return _fec_swig.polar_encoder_make(*args, **kwargs)

class polar_decoder_sc(object):
    """
    Standard successive cancellation (SC) decoder for POLAR codes.

    It expects float input with bits mapped 1 > 1, 0 > -1 Or: f = 2.0 * bit - 1.0
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int block_size, int num_info_bits, std::vector< int,std::allocator< int > > frozen_bit_positions, 
            std::vector< char,std::allocator< char > > frozen_bit_values) -> generic_decoder_sptr
        """
        return _fec_swig.polar_decoder_sc_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_polar_decoder_sc
    __del__ = lambda self : None;
    def generic_work(self, *args, **kwargs):
        """generic_work(polar_decoder_sc self, void * in_buffer, void * out_buffer)"""
        return _fec_swig.polar_decoder_sc_generic_work(self, *args, **kwargs)

polar_decoder_sc_swigregister = _fec_swig.polar_decoder_sc_swigregister
polar_decoder_sc_swigregister(polar_decoder_sc)

def polar_decoder_sc_make(*args, **kwargs):
  """
    polar_decoder_sc_make(int block_size, int num_info_bits, std::vector< int,std::allocator< int > > frozen_bit_positions, 
        std::vector< char,std::allocator< char > > frozen_bit_values) -> generic_decoder_sptr
    """
  return _fec_swig.polar_decoder_sc_make(*args, **kwargs)

class polar_common(object):
    """
    POLAR code common operations and attributes.

    Polar codes are based on this paper by Erdal Arikan "Channel Polarization: A Method for Constructing Capacity-Achieving Codes for Symmetric Binary-Input Memoryless Channels", 2009 block holds common information for encoders and decoders. All polar encoder/decoders inherit from polar_common.

    class holds common info. It is common to all encoders and decoders.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args, **kwargs): 
        """
        __init__(gr::fec::code::polar_common self, int block_size, int num_info_bits, std::vector< int,std::allocator< int > > frozen_bit_positions, 
            std::vector< char,std::allocator< char > > frozen_bit_values) -> polar_common
        """
        this = _fec_swig.new_polar_common(*args, **kwargs)
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fec_swig.delete_polar_common
    __del__ = lambda self : None;
polar_common_swigregister = _fec_swig.polar_common_swigregister
polar_common_swigregister(polar_common)

class polar_decoder_sc_list(object):
    """
    Successive cancellation list (SCL) decoder for polar codes.

    Decoder is based on Tal, Vardy "List Decoding of Polar Codes", 2012 LLR version: Balatsoukas-Stimming, Parizi, Burg "LLR-based
    Successive Cancellation List Decoding of Polar Codes", 2015.

    Block expects float input with bits mapped 1 > 1, 0 > -1 Or: f = 2.0 * bit - 1.0
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int max_list_size, int block_size, int num_info_bits, std::vector< int,std::allocator< int > > frozen_bit_positions, 
            std::vector< char,std::allocator< char > > frozen_bit_values) -> generic_decoder_sptr
        """
        return _fec_swig.polar_decoder_sc_list_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_polar_decoder_sc_list
    __del__ = lambda self : None;
    def generic_work(self, *args, **kwargs):
        """generic_work(polar_decoder_sc_list self, void * in_buffer, void * out_buffer)"""
        return _fec_swig.polar_decoder_sc_list_generic_work(self, *args, **kwargs)

polar_decoder_sc_list_swigregister = _fec_swig.polar_decoder_sc_list_swigregister
polar_decoder_sc_list_swigregister(polar_decoder_sc_list)

def polar_decoder_sc_list_make(*args, **kwargs):
  """
    polar_decoder_sc_list_make(int max_list_size, int block_size, int num_info_bits, std::vector< int,std::allocator< int > > frozen_bit_positions, 
        std::vector< char,std::allocator< char > > frozen_bit_values) -> generic_decoder_sptr
    """
  return _fec_swig.polar_decoder_sc_list_make(*args, **kwargs)

class polar_decoder_common(generic_decoder,polar_common):
    """Class holds common methods and attributes for different decoder implementations."""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fec_swig.delete_polar_decoder_common
    __del__ = lambda self : None;
polar_decoder_common_swigregister = _fec_swig.polar_decoder_common_swigregister
polar_decoder_common_swigregister(polar_decoder_common)

class polar_encoder_systematic(generic_encoder,polar_common):
    """
    systematic POLAR encoder for basic details see 'polar_common' class.

    expects values with MSB first. It needs a full information word and encodes it in one pass. Output is a codeword of block_size.

    Systematic encoding indicates that the info bit values are present in the codeword. 'info_bit_positions' may be obtained by ordering all non frozen_bit_positions in increasing order. One may extract them at their positions after a bit reversal operation. encoder -> decoder chain would need additional bit-reversal after encoding + before decoding. This is unnecessary.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(int block_size, int num_info_bits, std::vector< int,std::allocator< int > > frozen_bit_positions) -> generic_encoder_sptr

        Factory for a polar code encoder object.
        """
        return _fec_swig.polar_encoder_systematic_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_polar_encoder_systematic
    __del__ = lambda self : None;
polar_encoder_systematic_swigregister = _fec_swig.polar_encoder_systematic_swigregister
polar_encoder_systematic_swigregister(polar_encoder_systematic)

def polar_encoder_systematic_make(*args, **kwargs):
  """
    polar_encoder_systematic_make(int block_size, int num_info_bits, std::vector< int,std::allocator< int > > frozen_bit_positions) -> generic_encoder_sptr

    Factory for a polar code encoder object.
    """
  return _fec_swig.polar_encoder_systematic_make(*args, **kwargs)

class polar_decoder_sc_systematic(polar_decoder_common):
    """
    Standard systematic successive cancellation (SC) decoder for POLAR codes.

    It expects float input with bits mapped 1 > 1, 0 > -1 Or: f = 2.0 * bit - 1.0

    Systematic encoding indicates that the info bit values are present in the codeword. 'info_bit_positions' may be obtained by ordering all non frozen_bit_positions in increasing order. One may extract them at their positions after a bit reversal operation. encoder -> decoder chain would need additional bit-reversal after encoding + before decoding. This is unnecessary.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """make(int block_size, int num_info_bits, std::vector< int,std::allocator< int > > frozen_bit_positions) -> generic_decoder_sptr"""
        return _fec_swig.polar_decoder_sc_systematic_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_polar_decoder_sc_systematic
    __del__ = lambda self : None;
polar_decoder_sc_systematic_swigregister = _fec_swig.polar_decoder_sc_systematic_swigregister
polar_decoder_sc_systematic_swigregister(polar_decoder_sc_systematic)

def polar_decoder_sc_systematic_make(*args, **kwargs):
  """polar_decoder_sc_systematic_make(int block_size, int num_info_bits, std::vector< int,std::allocator< int > > frozen_bit_positions) -> generic_decoder_sptr"""
  return _fec_swig.polar_decoder_sc_systematic_make(*args, **kwargs)

class ldpc_encoder(generic_encoder):
    """Proxy of C++ gr::fec::ldpc_encoder class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """make(std::string alist_file) -> generic_encoder_sptr"""
        return _fec_swig.ldpc_encoder_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_ldpc_encoder
    __del__ = lambda self : None;
ldpc_encoder_swigregister = _fec_swig.ldpc_encoder_swigregister
ldpc_encoder_swigregister(ldpc_encoder)

def ldpc_encoder_make(*args, **kwargs):
  """ldpc_encoder_make(std::string alist_file) -> generic_encoder_sptr"""
  return _fec_swig.ldpc_encoder_make(*args, **kwargs)

class block_data(object):
    """Proxy of C++ gr::fec::code::block_data class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    size = _swig_property(_fec_swig.block_data_size_get, _fec_swig.block_data_size_set)
    data = _swig_property(_fec_swig.block_data_data_get, _fec_swig.block_data_data_set)
    def __init__(self): 
        """__init__(gr::fec::code::block_data self) -> block_data"""
        this = _fec_swig.new_block_data()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fec_swig.delete_block_data
    __del__ = lambda self : None;
block_data_swigregister = _fec_swig.block_data_swigregister
block_data_swigregister(block_data)

class matrix(object):
    """Proxy of C++ gr::fec::code::matrix class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    size1 = _swig_property(_fec_swig.matrix_size1_get, _fec_swig.matrix_size1_set)
    size2 = _swig_property(_fec_swig.matrix_size2_get, _fec_swig.matrix_size2_set)
    tda = _swig_property(_fec_swig.matrix_tda_get, _fec_swig.matrix_tda_set)
    data = _swig_property(_fec_swig.matrix_data_get, _fec_swig.matrix_data_set)
    block = _swig_property(_fec_swig.matrix_block_get, _fec_swig.matrix_block_set)
    owner = _swig_property(_fec_swig.matrix_owner_get, _fec_swig.matrix_owner_set)
    def __init__(self): 
        """__init__(gr::fec::code::matrix self) -> matrix"""
        this = _fec_swig.new_matrix()
        try: self.this.append(this)
        except: self.this = this
    __swig_destroy__ = _fec_swig.delete_matrix
    __del__ = lambda self : None;
matrix_swigregister = _fec_swig.matrix_swigregister
matrix_swigregister(matrix)


def matrix_free(*args, **kwargs):
  """matrix_free(matrix x)"""
  return _fec_swig.matrix_free(*args, **kwargs)

def read_matrix_from_file(*args, **kwargs):
  """
    read_matrix_from_file(std::string const filename) -> matrix_sptr

    Read in an alist file and produce the matrix object.

    Takes in a an alist file (the file name as a string) and creates the corresponding matrix. The format of alist files is described at: 

    The result is returned as a matrix shared pointer.
    """
  return _fec_swig.read_matrix_from_file(*args, **kwargs)

def write_matrix_to_file(*args, **kwargs):
  """write_matrix_to_file(std::string const filename, matrix_sptr M)"""
  return _fec_swig.write_matrix_to_file(*args, **kwargs)

def generate_G_transpose(*args, **kwargs):
  """
    generate_G_transpose(matrix_sptr H_obj) -> matrix_sptr

    Takes a parity check matrix (H) and returns the transpose of the generator matrix (G).

    The result is returned as a matrix shared pointer. The form of this matrix is [I_k | P]^T, where P is the parity check matrix. It is a n x k matrix where k is the information length and n is the codeword length.
    """
  return _fec_swig.generate_G_transpose(*args, **kwargs)

def generate_G(*args, **kwargs):
  """
    generate_G(matrix_sptr H_obj) -> matrix_sptr

    Takes a parity check matrix (H) and returns the generator matrix (G).

    The result is returned as a matrix shared pointer. The form of this matrix is [I_k | P], where P is the parity check matrix. It is a k x n matrix where k is the information length and n is the codeword length.
    """
  return _fec_swig.generate_G(*args, **kwargs)

def generate_H(*args, **kwargs):
  """
    generate_H(matrix_sptr G_obj) -> matrix_sptr

    Takes a generator matrix (G) and returns the parity check matrix (H).
    """
  return _fec_swig.generate_H(*args, **kwargs)

def print_matrix(*args, **kwargs):
  """
    print_matrix(matrix_sptr M, bool numpy=False)

    Takes a matrix and prints it to screen.
    """
  return _fec_swig.print_matrix(*args, **kwargs)
class fec_mtrx(object):
    """
    Base class for FEC matrix objects.

    Base class of ldpc_H_matrix and ldpc_G_matrix classes. The child objects can be either generator matrices or parity check matrices. This base class can be provided to the decoder ldpc_bit_flip_decoder, whereas the encoder classes ldpc_gen_mtrx_encoder and ldpc_encoder will not accept this base class; they require one of the child classes.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _fec_swig.delete_fec_mtrx
    __del__ = lambda self : None;
    def encode(self, *args, **kwargs):
        """
        encode(fec_mtrx self, unsigned char * outbuffer, unsigned char const * inbuffer)

        Encode  with LDPC H matrix into .
        """
        return _fec_swig.fec_mtrx_encode(self, *args, **kwargs)

    def decode(self, *args, **kwargs):
        """
        decode(fec_mtrx self, unsigned char * outbuffer, float const * inbuffer, unsigned int frame_size, unsigned int max_iterations)

        Decode  with LDPC H matrix into .
        """
        return _fec_swig.fec_mtrx_decode(self, *args, **kwargs)

    def n(self):
        """
        n(fec_mtrx self) -> unsigned int

        Get the codeword length n.
        """
        return _fec_swig.fec_mtrx_n(self)

    def k(self):
        """
        k(fec_mtrx self) -> unsigned int

        Get the information word length k.
        """
        return _fec_swig.fec_mtrx_k(self)

fec_mtrx_swigregister = _fec_swig.fec_mtrx_swigregister
fec_mtrx_swigregister(fec_mtrx)

class ldpc_H_matrix(fec_mtrx):
    """
    Parity check matrix in Richardson/Urbanke format.

    This class stores a matrix for use with the ldpc_encoder class. It must be of the specific format described by Richardson and Urbanke in Appendix A of their book: Modern Coding Theory (ISBN 978-0-521-85229-6). The form is:  This class can be used with the ldpc_bit_flip_decoder.

    To convert a parity check matrix to this format, use the python functions in: /lib/python2.7/dist-packages/gnuradio/fec/LDPC/Generate_LDPC_matrix.py.

    Constructor Specific Documentation:

    Constructor given alist file and gap.

    Args:
        filename : Name of an alist file to use. The alist format is described at:
        gap : A property of the matrix being used. For alist files distributed with GNU Radio, this value is specified in the alist filename. The gap is found during the matrix preprocessing algorithm. It is equal to the number of rows in submatrices E, C and D.
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::string const filename, unsigned int gap) -> ldpc_H_matrix_sptr

        Parity check matrix in Richardson/Urbanke format.

        This class stores a matrix for use with the ldpc_encoder class. It must be of the specific format described by Richardson and Urbanke in Appendix A of their book: Modern Coding Theory (ISBN 978-0-521-85229-6). The form is:  This class can be used with the ldpc_bit_flip_decoder.

        To convert a parity check matrix to this format, use the python functions in: /lib/python2.7/dist-packages/gnuradio/fec/LDPC/Generate_LDPC_matrix.py.

        Constructor Specific Documentation:

        Constructor given alist file and gap.

        Args:
            filename : Name of an alist file to use. The alist format is described at:
            gap : A property of the matrix being used. For alist files distributed with GNU Radio, this value is specified in the alist filename. The gap is found during the matrix preprocessing algorithm. It is equal to the number of rows in submatrices E, C and D.
        """
        return _fec_swig.ldpc_H_matrix_make(*args, **kwargs)

    make = staticmethod(make)
    def get_base_sptr(self):
        """
        get_base_sptr(ldpc_H_matrix self) -> fec_mtrx_sptr

        A pointer to make SWIG work.

        SWIG doesn't understand the parent class pointer to this child class for the make function of the ldpc_bit_flip_decoder; it's expecting a pointer to the base class. This returns a shared_from_this instance.
        """
        return _fec_swig.ldpc_H_matrix_get_base_sptr(self)

    __swig_destroy__ = _fec_swig.delete_ldpc_H_matrix
    __del__ = lambda self : None;
ldpc_H_matrix_swigregister = _fec_swig.ldpc_H_matrix_swigregister
ldpc_H_matrix_swigregister(ldpc_H_matrix)

def ldpc_H_matrix_make(*args, **kwargs):
  """
    ldpc_H_matrix_make(std::string const filename, unsigned int gap) -> ldpc_H_matrix_sptr

    Parity check matrix in Richardson/Urbanke format.

    This class stores a matrix for use with the ldpc_encoder class. It must be of the specific format described by Richardson and Urbanke in Appendix A of their book: Modern Coding Theory (ISBN 978-0-521-85229-6). The form is:  This class can be used with the ldpc_bit_flip_decoder.

    To convert a parity check matrix to this format, use the python functions in: /lib/python2.7/dist-packages/gnuradio/fec/LDPC/Generate_LDPC_matrix.py.

    Constructor Specific Documentation:

    Constructor given alist file and gap.

    Args:
        filename : Name of an alist file to use. The alist format is described at:
        gap : A property of the matrix being used. For alist files distributed with GNU Radio, this value is specified in the alist filename. The gap is found during the matrix preprocessing algorithm. It is equal to the number of rows in submatrices E, C and D.
    """
  return _fec_swig.ldpc_H_matrix_make(*args, **kwargs)

class ldpc_G_matrix(fec_mtrx):
    """
    Class for storing H or G matrix.

    This class stores a matrix variable, specifically either a:

    1) Generator matrix, G, in the standard format G = [I P], where I is an identity matrix and P is the parity submatrix.

    or

    2) Parity matrix, H, in the standard format H = [P' I], where P' is the transpose of the parity submatrix and I is an identity matrix.

    This variable can used by the ldpc_gen_mtrx_encoder and ldpc_bit_flip_decoder classes.

    Constructor Specific Documentation:

    Constructor given alist file.

    Args:
        filename : Name of an alist file to use. The alist format is described at:
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(std::string const filename) -> ldpc_G_matrix_sptr

        Class for storing H or G matrix.

        This class stores a matrix variable, specifically either a:

        1) Generator matrix, G, in the standard format G = [I P], where I is an identity matrix and P is the parity submatrix.

        or

        2) Parity matrix, H, in the standard format H = [P' I], where P' is the transpose of the parity submatrix and I is an identity matrix.

        This variable can used by the ldpc_gen_mtrx_encoder and ldpc_bit_flip_decoder classes.

        Constructor Specific Documentation:

        Constructor given alist file.

        Args:
            filename : Name of an alist file to use. The alist format is described at:
        """
        return _fec_swig.ldpc_G_matrix_make(*args, **kwargs)

    make = staticmethod(make)
    def get_base_sptr(self):
        """
        get_base_sptr(ldpc_G_matrix self) -> fec_mtrx_sptr

        A pointer to make SWIG work.

        SWIG doesn't understand the parent class pointer to this child class for the make function of the ldpc_bit_flip_decoder; it's expecting a pointer to the base class. This returns a shared_from_this instance.
        """
        return _fec_swig.ldpc_G_matrix_get_base_sptr(self)

    __swig_destroy__ = _fec_swig.delete_ldpc_G_matrix
    __del__ = lambda self : None;
ldpc_G_matrix_swigregister = _fec_swig.ldpc_G_matrix_swigregister
ldpc_G_matrix_swigregister(ldpc_G_matrix)

def ldpc_G_matrix_make(*args, **kwargs):
  """
    ldpc_G_matrix_make(std::string const filename) -> ldpc_G_matrix_sptr

    Class for storing H or G matrix.

    This class stores a matrix variable, specifically either a:

    1) Generator matrix, G, in the standard format G = [I P], where I is an identity matrix and P is the parity submatrix.

    or

    2) Parity matrix, H, in the standard format H = [P' I], where P' is the transpose of the parity submatrix and I is an identity matrix.

    This variable can used by the ldpc_gen_mtrx_encoder and ldpc_bit_flip_decoder classes.

    Constructor Specific Documentation:

    Constructor given alist file.

    Args:
        filename : Name of an alist file to use. The alist format is described at:
    """
  return _fec_swig.ldpc_G_matrix_make(*args, **kwargs)

class ldpc_gen_mtrx_encoder(generic_encoder):
    """
    LDPC generator matrix encoder.

    A standard encoder class. This method is discussed in many textbooks; one is: Turbo Coding for Satellite and Wireless Communications by Soleymani, Gao, and Vilaipornsawai. Given a generator matrix in systematic form, , where  is the identity matrix and  is the parity submatrix, the information word  is encoded into a codeword  via:
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(ldpc_G_matrix_sptr G_obj) -> generic_encoder_sptr

        Build an encoding FEC API object.
        """
        return _fec_swig.ldpc_gen_mtrx_encoder_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_ldpc_gen_mtrx_encoder
    __del__ = lambda self : None;
ldpc_gen_mtrx_encoder_swigregister = _fec_swig.ldpc_gen_mtrx_encoder_swigregister
ldpc_gen_mtrx_encoder_swigregister(ldpc_gen_mtrx_encoder)

def ldpc_gen_mtrx_encoder_make(*args, **kwargs):
  """
    ldpc_gen_mtrx_encoder_make(ldpc_G_matrix_sptr G_obj) -> generic_encoder_sptr

    Build an encoding FEC API object.
    """
  return _fec_swig.ldpc_gen_mtrx_encoder_make(*args, **kwargs)

class ldpc_par_mtrx_encoder(generic_encoder):
    """Proxy of C++ gr::fec::code::ldpc_par_mtrx_encoder class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """make(std::string alist_file, unsigned int gap=0) -> generic_encoder_sptr"""
        return _fec_swig.ldpc_par_mtrx_encoder_make(*args, **kwargs)

    make = staticmethod(make)
    def make_H(*args, **kwargs):
        """make_H(ldpc_H_matrix_sptr H_obj) -> generic_encoder_sptr"""
        return _fec_swig.ldpc_par_mtrx_encoder_make_H(*args, **kwargs)

    make_H = staticmethod(make_H)
    __swig_destroy__ = _fec_swig.delete_ldpc_par_mtrx_encoder
    __del__ = lambda self : None;
ldpc_par_mtrx_encoder_swigregister = _fec_swig.ldpc_par_mtrx_encoder_swigregister
ldpc_par_mtrx_encoder_swigregister(ldpc_par_mtrx_encoder)

def ldpc_par_mtrx_encoder_make(*args, **kwargs):
  """ldpc_par_mtrx_encoder_make(std::string alist_file, unsigned int gap=0) -> generic_encoder_sptr"""
  return _fec_swig.ldpc_par_mtrx_encoder_make(*args, **kwargs)

def ldpc_par_mtrx_encoder_make_H(*args, **kwargs):
  """ldpc_par_mtrx_encoder_make_H(ldpc_H_matrix_sptr H_obj) -> generic_encoder_sptr"""
  return _fec_swig.ldpc_par_mtrx_encoder_make_H(*args, **kwargs)

class ldpc_bit_flip_decoder(generic_decoder):
    """
    LDPC bit flip decoding class.

    A hard decision bit flip decoder class for decoding low density parity check (LDPC) codes. The decoder requires knowledge of the matrix used to create (encode) the codewords. The simple algorithm is:
    """
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    def make(*args, **kwargs):
        """
        make(fec_mtrx_sptr mtrx_obj, unsigned int max_iter=100) -> generic_decoder_sptr

        Build a bit flip decoding FEC API object.
        """
        return _fec_swig.ldpc_bit_flip_decoder_make(*args, **kwargs)

    make = staticmethod(make)
    __swig_destroy__ = _fec_swig.delete_ldpc_bit_flip_decoder
    __del__ = lambda self : None;
ldpc_bit_flip_decoder_swigregister = _fec_swig.ldpc_bit_flip_decoder_swigregister
ldpc_bit_flip_decoder_swigregister(ldpc_bit_flip_decoder)

def ldpc_bit_flip_decoder_make(*args, **kwargs):
  """
    ldpc_bit_flip_decoder_make(fec_mtrx_sptr mtrx_obj, unsigned int max_iter=100) -> generic_decoder_sptr

    Build a bit flip decoding FEC API object.
    """
  return _fec_swig.ldpc_bit_flip_decoder_make(*args, **kwargs)

class ldpc_decoder(generic_decoder):
    """Proxy of C++ gr::fec::ldpc_decoder class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    def __init__(self, *args, **kwargs): raise AttributeError("No constructor defined")
    __repr__ = _swig_repr
    __swig_destroy__ = _fec_swig.delete_ldpc_decoder
    __del__ = lambda self : None;
    def make(*args, **kwargs):
        """make(std::string alist_file, float sigma=0.5, int max_iterations=50) -> generic_decoder_sptr"""
        return _fec_swig.ldpc_decoder_make(*args, **kwargs)

    make = staticmethod(make)
ldpc_decoder_swigregister = _fec_swig.ldpc_decoder_swigregister
ldpc_decoder_swigregister(ldpc_decoder)

def ldpc_decoder_make(*args, **kwargs):
  """ldpc_decoder_make(std::string alist_file, float sigma=0.5, int max_iterations=50) -> generic_decoder_sptr"""
  return _fec_swig.ldpc_decoder_make(*args, **kwargs)

class matrix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::code::matrix)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::code::matrix)> self) -> matrix_sptr
        __init__(boost::shared_ptr<(gr::fec::code::matrix)> self, matrix p) -> matrix_sptr
        """
        this = _fec_swig.new_matrix_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(matrix_sptr self) -> matrix"""
        return _fec_swig.matrix_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_matrix_sptr
    __del__ = lambda self : None;
    size1 = _swig_property(_fec_swig.matrix_sptr_size1_get, _fec_swig.matrix_sptr_size1_set)
    size2 = _swig_property(_fec_swig.matrix_sptr_size2_get, _fec_swig.matrix_sptr_size2_set)
    tda = _swig_property(_fec_swig.matrix_sptr_tda_get, _fec_swig.matrix_sptr_tda_set)
    data = _swig_property(_fec_swig.matrix_sptr_data_get, _fec_swig.matrix_sptr_data_set)
    block = _swig_property(_fec_swig.matrix_sptr_block_get, _fec_swig.matrix_sptr_block_set)
    owner = _swig_property(_fec_swig.matrix_sptr_owner_get, _fec_swig.matrix_sptr_owner_set)
matrix_sptr_swigregister = _fec_swig.matrix_sptr_swigregister
matrix_sptr_swigregister(matrix_sptr)

class fec_mtrx_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::code::fec_mtrx)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::code::fec_mtrx)> self) -> fec_mtrx_sptr
        __init__(boost::shared_ptr<(gr::fec::code::fec_mtrx)> self, fec_mtrx p) -> fec_mtrx_sptr
        """
        this = _fec_swig.new_fec_mtrx_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(fec_mtrx_sptr self) -> fec_mtrx"""
        return _fec_swig.fec_mtrx_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_fec_mtrx_sptr
    __del__ = lambda self : None;
    def encode(self, *args, **kwargs):
        """
        encode(fec_mtrx_sptr self, unsigned char * outbuffer, unsigned char const * inbuffer)

        Encode  with LDPC H matrix into .
        """
        return _fec_swig.fec_mtrx_sptr_encode(self, *args, **kwargs)

    def decode(self, *args, **kwargs):
        """
        decode(fec_mtrx_sptr self, unsigned char * outbuffer, float const * inbuffer, unsigned int frame_size, unsigned int max_iterations)

        Decode  with LDPC H matrix into .
        """
        return _fec_swig.fec_mtrx_sptr_decode(self, *args, **kwargs)

    def n(self):
        """
        n(fec_mtrx_sptr self) -> unsigned int

        Get the codeword length n.
        """
        return _fec_swig.fec_mtrx_sptr_n(self)

    def k(self):
        """
        k(fec_mtrx_sptr self) -> unsigned int

        Get the information word length k.
        """
        return _fec_swig.fec_mtrx_sptr_k(self)

fec_mtrx_sptr_swigregister = _fec_swig.fec_mtrx_sptr_swigregister
fec_mtrx_sptr_swigregister(fec_mtrx_sptr)

class ldpc_H_matrix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::code::ldpc_H_matrix)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::code::ldpc_H_matrix)> self) -> ldpc_H_matrix_sptr
        __init__(boost::shared_ptr<(gr::fec::code::ldpc_H_matrix)> self, ldpc_H_matrix p) -> ldpc_H_matrix_sptr
        """
        this = _fec_swig.new_ldpc_H_matrix_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ldpc_H_matrix_sptr self) -> ldpc_H_matrix"""
        return _fec_swig.ldpc_H_matrix_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_ldpc_H_matrix_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ldpc_H_matrix_sptr self, std::string const filename, unsigned int gap) -> ldpc_H_matrix_sptr

        Parity check matrix in Richardson/Urbanke format.

        This class stores a matrix for use with the ldpc_encoder class. It must be of the specific format described by Richardson and Urbanke in Appendix A of their book: Modern Coding Theory (ISBN 978-0-521-85229-6). The form is:  This class can be used with the ldpc_bit_flip_decoder.

        To convert a parity check matrix to this format, use the python functions in: /lib/python2.7/dist-packages/gnuradio/fec/LDPC/Generate_LDPC_matrix.py.

        Constructor Specific Documentation:

        Constructor given alist file and gap.

        Args:
            filename : Name of an alist file to use. The alist format is described at:
            gap : A property of the matrix being used. For alist files distributed with GNU Radio, this value is specified in the alist filename. The gap is found during the matrix preprocessing algorithm. It is equal to the number of rows in submatrices E, C and D.
        """
        return _fec_swig.ldpc_H_matrix_sptr_make(self, *args, **kwargs)

    def get_base_sptr(self):
        """
        get_base_sptr(ldpc_H_matrix_sptr self) -> fec_mtrx_sptr

        A pointer to make SWIG work.

        SWIG doesn't understand the parent class pointer to this child class for the make function of the ldpc_bit_flip_decoder; it's expecting a pointer to the base class. This returns a shared_from_this instance.
        """
        return _fec_swig.ldpc_H_matrix_sptr_get_base_sptr(self)

    def encode(self, *args, **kwargs):
        """
        encode(ldpc_H_matrix_sptr self, unsigned char * outbuffer, unsigned char const * inbuffer)

        Encode  with LDPC H matrix into .
        """
        return _fec_swig.ldpc_H_matrix_sptr_encode(self, *args, **kwargs)

    def decode(self, *args, **kwargs):
        """
        decode(ldpc_H_matrix_sptr self, unsigned char * outbuffer, float const * inbuffer, unsigned int frame_size, unsigned int max_iterations)

        Decode  with LDPC H matrix into .
        """
        return _fec_swig.ldpc_H_matrix_sptr_decode(self, *args, **kwargs)

    def n(self):
        """
        n(ldpc_H_matrix_sptr self) -> unsigned int

        Get the codeword length n.
        """
        return _fec_swig.ldpc_H_matrix_sptr_n(self)

    def k(self):
        """
        k(ldpc_H_matrix_sptr self) -> unsigned int

        Get the information word length k.
        """
        return _fec_swig.ldpc_H_matrix_sptr_k(self)

ldpc_H_matrix_sptr_swigregister = _fec_swig.ldpc_H_matrix_sptr_swigregister
ldpc_H_matrix_sptr_swigregister(ldpc_H_matrix_sptr)

ldpc_H_matrix = ldpc_H_matrix.make;

class ldpc_G_matrix_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::code::ldpc_G_matrix)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::code::ldpc_G_matrix)> self) -> ldpc_G_matrix_sptr
        __init__(boost::shared_ptr<(gr::fec::code::ldpc_G_matrix)> self, ldpc_G_matrix p) -> ldpc_G_matrix_sptr
        """
        this = _fec_swig.new_ldpc_G_matrix_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ldpc_G_matrix_sptr self) -> ldpc_G_matrix"""
        return _fec_swig.ldpc_G_matrix_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_ldpc_G_matrix_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(ldpc_G_matrix_sptr self, std::string const filename) -> ldpc_G_matrix_sptr

        Class for storing H or G matrix.

        This class stores a matrix variable, specifically either a:

        1) Generator matrix, G, in the standard format G = [I P], where I is an identity matrix and P is the parity submatrix.

        or

        2) Parity matrix, H, in the standard format H = [P' I], where P' is the transpose of the parity submatrix and I is an identity matrix.

        This variable can used by the ldpc_gen_mtrx_encoder and ldpc_bit_flip_decoder classes.

        Constructor Specific Documentation:

        Constructor given alist file.

        Args:
            filename : Name of an alist file to use. The alist format is described at:
        """
        return _fec_swig.ldpc_G_matrix_sptr_make(self, *args, **kwargs)

    def get_base_sptr(self):
        """
        get_base_sptr(ldpc_G_matrix_sptr self) -> fec_mtrx_sptr

        A pointer to make SWIG work.

        SWIG doesn't understand the parent class pointer to this child class for the make function of the ldpc_bit_flip_decoder; it's expecting a pointer to the base class. This returns a shared_from_this instance.
        """
        return _fec_swig.ldpc_G_matrix_sptr_get_base_sptr(self)

    def encode(self, *args, **kwargs):
        """
        encode(ldpc_G_matrix_sptr self, unsigned char * outbuffer, unsigned char const * inbuffer)

        Encode  with LDPC H matrix into .
        """
        return _fec_swig.ldpc_G_matrix_sptr_encode(self, *args, **kwargs)

    def decode(self, *args, **kwargs):
        """
        decode(ldpc_G_matrix_sptr self, unsigned char * outbuffer, float const * inbuffer, unsigned int frame_size, unsigned int max_iterations)

        Decode  with LDPC H matrix into .
        """
        return _fec_swig.ldpc_G_matrix_sptr_decode(self, *args, **kwargs)

    def n(self):
        """
        n(ldpc_G_matrix_sptr self) -> unsigned int

        Get the codeword length n.
        """
        return _fec_swig.ldpc_G_matrix_sptr_n(self)

    def k(self):
        """
        k(ldpc_G_matrix_sptr self) -> unsigned int

        Get the information word length k.
        """
        return _fec_swig.ldpc_G_matrix_sptr_k(self)

ldpc_G_matrix_sptr_swigregister = _fec_swig.ldpc_G_matrix_sptr_swigregister
ldpc_G_matrix_sptr_swigregister(ldpc_G_matrix_sptr)

ldpc_G_matrix = ldpc_G_matrix.make;

class decoder_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::decoder)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::decoder)> self) -> decoder_sptr
        __init__(boost::shared_ptr<(gr::fec::decoder)> self, decoder p) -> decoder_sptr
        """
        this = _fec_swig.new_decoder_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(decoder_sptr self) -> decoder"""
        return _fec_swig.decoder_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_decoder_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(decoder_sptr self, generic_decoder_sptr my_decoder, size_t input_item_size, size_t output_item_size) -> decoder_sptr

        General FEC decoding block that takes in a decoder variable object (derived from gr::fec::general_decoder) for use in a flowgraph.

        This block uses a decoder variable object (derived from gr::fec::generic_decoder) to decode data within a flowgraph. This block interacts with the general FECAPI architecture to handle all passing all input and output data in a flowgraph. The decoder variable takes care of understanding the requirements, data types and sizes, and boundary conditions of the specific FEC decoding algorithm.

        Generally, this block is used within the fec.extended_decoder Python block to handle some input/output formatting issues. In the FECAPI, the decoder variable sets properties like the input and output types and sizes and whether the output is packed or unpacked bytes. The fec.extended_decoder uses this information to set up an gr::hier_block2 structure to make sure the I/O to the variable is handled consistently, such as to make sure all inputs are floats with one soft symbol per item and the outputs are unpacked bytes with the bit in the LSB.

        See gr::fec::generic_decoder for detail on what information an FECAPI variable object can set if using this block directly and not as part of the fec.extended_decoder.

        Constructor Specific Documentation:

        Create the FEC decoder block by taking in the FECAPI decoder object as well as input and output sizes.

        Args:
            my_decoder : An FECAPI decoder object (See gr::fec::generic_decoder).
            input_item_size : The size of the input items (often the my_decoder object can tell us this).
            output_item_size : The size of the output items (often the my_decoder object can tell us this).
        """
        return _fec_swig.decoder_sptr_make(self, *args, **kwargs)

    def general_work(self, *args, **kwargs):
        """
        general_work(decoder_sptr self, int noutput_items, gr_vector_int & ninput_items, gr_vector_const_void_star & input_items, 
            gr_vector_void_star & output_items) -> int
        """
        return _fec_swig.decoder_sptr_general_work(self, *args, **kwargs)

    def fixed_rate_ninput_to_noutput(self, *args, **kwargs):
        """fixed_rate_ninput_to_noutput(decoder_sptr self, int ninput) -> int"""
        return _fec_swig.decoder_sptr_fixed_rate_ninput_to_noutput(self, *args, **kwargs)

    def fixed_rate_noutput_to_ninput(self, *args, **kwargs):
        """fixed_rate_noutput_to_ninput(decoder_sptr self, int noutput) -> int"""
        return _fec_swig.decoder_sptr_fixed_rate_noutput_to_ninput(self, *args, **kwargs)

    def forecast(self, *args, **kwargs):
        """forecast(decoder_sptr self, int noutput_items, gr_vector_int & ninput_items_required)"""
        return _fec_swig.decoder_sptr_forecast(self, *args, **kwargs)

    def history(self):
        """history(decoder_sptr self) -> unsigned int"""
        return _fec_swig.decoder_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(decoder_sptr self, int which, int delay)
        declare_sample_delay(decoder_sptr self, unsigned int delay)
        """
        return _fec_swig.decoder_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(decoder_sptr self, int which) -> unsigned int"""
        return _fec_swig.decoder_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(decoder_sptr self) -> int"""
        return _fec_swig.decoder_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(decoder_sptr self) -> double"""
        return _fec_swig.decoder_sptr_relative_rate(self)

    def start(self):
        """start(decoder_sptr self) -> bool"""
        return _fec_swig.decoder_sptr_start(self)

    def stop(self):
        """stop(decoder_sptr self) -> bool"""
        return _fec_swig.decoder_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(decoder_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.decoder_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(decoder_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.decoder_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(decoder_sptr self) -> int"""
        return _fec_swig.decoder_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(decoder_sptr self, int m)"""
        return _fec_swig.decoder_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(decoder_sptr self)"""
        return _fec_swig.decoder_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(decoder_sptr self) -> bool"""
        return _fec_swig.decoder_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(decoder_sptr self, int m)"""
        return _fec_swig.decoder_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(decoder_sptr self) -> int"""
        return _fec_swig.decoder_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(decoder_sptr self, int i) -> long"""
        return _fec_swig.decoder_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(decoder_sptr self, long max_output_buffer)
        set_max_output_buffer(decoder_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.decoder_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(decoder_sptr self, int i) -> long"""
        return _fec_swig.decoder_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(decoder_sptr self, long min_output_buffer)
        set_min_output_buffer(decoder_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.decoder_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(decoder_sptr self) -> float"""
        return _fec_swig.decoder_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(decoder_sptr self) -> float"""
        return _fec_swig.decoder_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(decoder_sptr self) -> float"""
        return _fec_swig.decoder_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(decoder_sptr self) -> float"""
        return _fec_swig.decoder_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(decoder_sptr self) -> float"""
        return _fec_swig.decoder_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(decoder_sptr self) -> float"""
        return _fec_swig.decoder_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(decoder_sptr self, int which) -> float
        pc_input_buffers_full(decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.decoder_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(decoder_sptr self, int which) -> float
        pc_input_buffers_full_avg(decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.decoder_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(decoder_sptr self, int which) -> float
        pc_input_buffers_full_var(decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.decoder_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(decoder_sptr self, int which) -> float
        pc_output_buffers_full(decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.decoder_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(decoder_sptr self, int which) -> float
        pc_output_buffers_full_avg(decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.decoder_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(decoder_sptr self, int which) -> float
        pc_output_buffers_full_var(decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.decoder_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(decoder_sptr self) -> float"""
        return _fec_swig.decoder_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(decoder_sptr self) -> float"""
        return _fec_swig.decoder_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(decoder_sptr self) -> float"""
        return _fec_swig.decoder_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(decoder_sptr self) -> float"""
        return _fec_swig.decoder_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(decoder_sptr self) -> float"""
        return _fec_swig.decoder_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(decoder_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.decoder_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(decoder_sptr self)"""
        return _fec_swig.decoder_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(decoder_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.decoder_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(decoder_sptr self) -> int"""
        return _fec_swig.decoder_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(decoder_sptr self) -> int"""
        return _fec_swig.decoder_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(decoder_sptr self, int priority) -> int"""
        return _fec_swig.decoder_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(decoder_sptr self) -> std::string"""
        return _fec_swig.decoder_sptr_name(self)

    def symbol_name(self):
        """symbol_name(decoder_sptr self) -> std::string"""
        return _fec_swig.decoder_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(decoder_sptr self) -> io_signature_sptr"""
        return _fec_swig.decoder_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(decoder_sptr self) -> io_signature_sptr"""
        return _fec_swig.decoder_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(decoder_sptr self) -> long"""
        return _fec_swig.decoder_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(decoder_sptr self) -> basic_block_sptr"""
        return _fec_swig.decoder_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(decoder_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.decoder_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(decoder_sptr self) -> std::string"""
        return _fec_swig.decoder_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(decoder_sptr self, std::string name)"""
        return _fec_swig.decoder_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(decoder_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.decoder_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(decoder_sptr self) -> swig_int_ptr"""
        return _fec_swig.decoder_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(decoder_sptr self) -> swig_int_ptr"""
        return _fec_swig.decoder_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(decoder_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.decoder_sptr_message_subscribers(self, *args, **kwargs)

decoder_sptr_swigregister = _fec_swig.decoder_sptr_swigregister
decoder_sptr_swigregister(decoder_sptr)

decoder_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
decoder = decoder.make;

class encoder_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::encoder)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::encoder)> self) -> encoder_sptr
        __init__(boost::shared_ptr<(gr::fec::encoder)> self, encoder p) -> encoder_sptr
        """
        this = _fec_swig.new_encoder_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(encoder_sptr self) -> encoder"""
        return _fec_swig.encoder_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_encoder_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(encoder_sptr self, generic_encoder_sptr my_encoder, size_t input_item_size, size_t output_item_size) -> encoder_sptr

        Creates the encoder block for use in GNU Radio flowgraphs from a given FECAPI object derived from the generic_encoder class.

        Generally, we would use the fec.extended_encoder Python implementation to instantiate this. The extended_encoder wraps up a few more details, like taking care of puncturing as well as the encoder itself.

        Constructor Specific Documentation:

        Build the FEC encoder block from an FECAPI encoder object.

        Args:
            my_encoder : An FECAPI encoder object child of the generic_encoder class.
            input_item_size : size of a block of data for the encoder.
            output_item_size : size of a block of data the encoder will produce.
        """
        return _fec_swig.encoder_sptr_make(self, *args, **kwargs)

    def general_work(self, *args, **kwargs):
        """
        general_work(encoder_sptr self, int noutput_items, gr_vector_int & ninput_items, gr_vector_const_void_star & input_items, 
            gr_vector_void_star & output_items) -> int
        """
        return _fec_swig.encoder_sptr_general_work(self, *args, **kwargs)

    def fixed_rate_ninput_to_noutput(self, *args, **kwargs):
        """fixed_rate_ninput_to_noutput(encoder_sptr self, int ninput) -> int"""
        return _fec_swig.encoder_sptr_fixed_rate_ninput_to_noutput(self, *args, **kwargs)

    def fixed_rate_noutput_to_ninput(self, *args, **kwargs):
        """fixed_rate_noutput_to_ninput(encoder_sptr self, int noutput) -> int"""
        return _fec_swig.encoder_sptr_fixed_rate_noutput_to_ninput(self, *args, **kwargs)

    def forecast(self, *args, **kwargs):
        """forecast(encoder_sptr self, int noutput_items, gr_vector_int & ninput_items_required)"""
        return _fec_swig.encoder_sptr_forecast(self, *args, **kwargs)

    def history(self):
        """history(encoder_sptr self) -> unsigned int"""
        return _fec_swig.encoder_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(encoder_sptr self, int which, int delay)
        declare_sample_delay(encoder_sptr self, unsigned int delay)
        """
        return _fec_swig.encoder_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(encoder_sptr self, int which) -> unsigned int"""
        return _fec_swig.encoder_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(encoder_sptr self) -> int"""
        return _fec_swig.encoder_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(encoder_sptr self) -> double"""
        return _fec_swig.encoder_sptr_relative_rate(self)

    def start(self):
        """start(encoder_sptr self) -> bool"""
        return _fec_swig.encoder_sptr_start(self)

    def stop(self):
        """stop(encoder_sptr self) -> bool"""
        return _fec_swig.encoder_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(encoder_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.encoder_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(encoder_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.encoder_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(encoder_sptr self) -> int"""
        return _fec_swig.encoder_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(encoder_sptr self, int m)"""
        return _fec_swig.encoder_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(encoder_sptr self)"""
        return _fec_swig.encoder_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(encoder_sptr self) -> bool"""
        return _fec_swig.encoder_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(encoder_sptr self, int m)"""
        return _fec_swig.encoder_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(encoder_sptr self) -> int"""
        return _fec_swig.encoder_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(encoder_sptr self, int i) -> long"""
        return _fec_swig.encoder_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(encoder_sptr self, long max_output_buffer)
        set_max_output_buffer(encoder_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.encoder_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(encoder_sptr self, int i) -> long"""
        return _fec_swig.encoder_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(encoder_sptr self, long min_output_buffer)
        set_min_output_buffer(encoder_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.encoder_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(encoder_sptr self) -> float"""
        return _fec_swig.encoder_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(encoder_sptr self) -> float"""
        return _fec_swig.encoder_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(encoder_sptr self) -> float"""
        return _fec_swig.encoder_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(encoder_sptr self) -> float"""
        return _fec_swig.encoder_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(encoder_sptr self) -> float"""
        return _fec_swig.encoder_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(encoder_sptr self) -> float"""
        return _fec_swig.encoder_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(encoder_sptr self, int which) -> float
        pc_input_buffers_full(encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.encoder_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(encoder_sptr self, int which) -> float
        pc_input_buffers_full_avg(encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.encoder_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(encoder_sptr self, int which) -> float
        pc_input_buffers_full_var(encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.encoder_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(encoder_sptr self, int which) -> float
        pc_output_buffers_full(encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.encoder_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(encoder_sptr self, int which) -> float
        pc_output_buffers_full_avg(encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.encoder_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(encoder_sptr self, int which) -> float
        pc_output_buffers_full_var(encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.encoder_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(encoder_sptr self) -> float"""
        return _fec_swig.encoder_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(encoder_sptr self) -> float"""
        return _fec_swig.encoder_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(encoder_sptr self) -> float"""
        return _fec_swig.encoder_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(encoder_sptr self) -> float"""
        return _fec_swig.encoder_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(encoder_sptr self) -> float"""
        return _fec_swig.encoder_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(encoder_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.encoder_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(encoder_sptr self)"""
        return _fec_swig.encoder_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(encoder_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.encoder_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(encoder_sptr self) -> int"""
        return _fec_swig.encoder_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(encoder_sptr self) -> int"""
        return _fec_swig.encoder_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(encoder_sptr self, int priority) -> int"""
        return _fec_swig.encoder_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(encoder_sptr self) -> std::string"""
        return _fec_swig.encoder_sptr_name(self)

    def symbol_name(self):
        """symbol_name(encoder_sptr self) -> std::string"""
        return _fec_swig.encoder_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(encoder_sptr self) -> io_signature_sptr"""
        return _fec_swig.encoder_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(encoder_sptr self) -> io_signature_sptr"""
        return _fec_swig.encoder_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(encoder_sptr self) -> long"""
        return _fec_swig.encoder_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(encoder_sptr self) -> basic_block_sptr"""
        return _fec_swig.encoder_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(encoder_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.encoder_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(encoder_sptr self) -> std::string"""
        return _fec_swig.encoder_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(encoder_sptr self, std::string name)"""
        return _fec_swig.encoder_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(encoder_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.encoder_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(encoder_sptr self) -> swig_int_ptr"""
        return _fec_swig.encoder_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(encoder_sptr self) -> swig_int_ptr"""
        return _fec_swig.encoder_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(encoder_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.encoder_sptr_message_subscribers(self, *args, **kwargs)

encoder_sptr_swigregister = _fec_swig.encoder_sptr_swigregister
encoder_sptr_swigregister(encoder_sptr)

encoder_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
encoder = encoder.make;

class tagged_decoder_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::tagged_decoder)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::tagged_decoder)> self) -> tagged_decoder_sptr
        __init__(boost::shared_ptr<(gr::fec::tagged_decoder)> self, tagged_decoder p) -> tagged_decoder_sptr
        """
        this = _fec_swig.new_tagged_decoder_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(tagged_decoder_sptr self) -> tagged_decoder"""
        return _fec_swig.tagged_decoder_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_tagged_decoder_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(tagged_decoder_sptr self, generic_decoder_sptr my_decoder, size_t input_item_size, size_t output_item_size, 
            std::string const & lengthtagname="packet_len", int mtu=1500) -> tagged_decoder_sptr

        General FEC decoding block that takes in a decoder variable object (derived from gr::fec::general_decoder) for use in a flowgraph.

        This block uses a decoder variable object (derived from gr::fec::generic_decoder) to decode data within a flowgraph. This block interacts with the general FECAPI architecture to handle all passing all input and output data in a flowgraph. The decoder variable takes care of understanding the requirements, data types and sizes, and boundary conditions of the specific FEC decoding algorithm.

        Generally, this block is used within the fec.extended_decoder Python block to handle some input/output formatting issues. In the FECAPI, the decoder variable sets properties like the input and output types and sizes and whether the output is packed or unpacked bytes. The fec.extended_decoder uses this information to set up an gr::hier_block2 structure to make sure the I/O to the variable is handled consistently, such as to make sure all inputs are floats with one soft symbol per item and the outputs are unpacked bytes with the bit in the LSB.

        See gr::fec::generic_decoder for detail on what information an FECAPI variable object can set if using this block directly and not as part of the fec.extended_decoder.

        Constructor Specific Documentation:

        Create the FEC decoder block by taking in the FECAPI decoder object as well as input and output sizes.

        Args:
            my_decoder : An FECAPI decoder object (See gr::fec::generic_decoder).
            input_item_size : The size of the input items (often the my_decoder object can tell us this).
            output_item_size : The size of the output items (often the my_decoder object can tell us this).
            lengthtagname : Key name of the tagged stream frame size.
            mtu : The Maximum Transmission Unit (MTU) of the output frame that the block will be able to process. Specified in bytes and defaults to 1500.
        """
        return _fec_swig.tagged_decoder_sptr_make(self, *args, **kwargs)

    def work(self, *args, **kwargs):
        """
        work(tagged_decoder_sptr self, int noutput_items, gr_vector_int & ninput_items, gr_vector_const_void_star & input_items, 
            gr_vector_void_star & output_items) -> int
        """
        return _fec_swig.tagged_decoder_sptr_work(self, *args, **kwargs)

    def calculate_output_stream_length(self, *args, **kwargs):
        """calculate_output_stream_length(tagged_decoder_sptr self, gr_vector_int const & ninput_items) -> int"""
        return _fec_swig.tagged_decoder_sptr_calculate_output_stream_length(self, *args, **kwargs)

    def history(self):
        """history(tagged_decoder_sptr self) -> unsigned int"""
        return _fec_swig.tagged_decoder_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(tagged_decoder_sptr self, int which, int delay)
        declare_sample_delay(tagged_decoder_sptr self, unsigned int delay)
        """
        return _fec_swig.tagged_decoder_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(tagged_decoder_sptr self, int which) -> unsigned int"""
        return _fec_swig.tagged_decoder_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(tagged_decoder_sptr self) -> int"""
        return _fec_swig.tagged_decoder_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(tagged_decoder_sptr self) -> double"""
        return _fec_swig.tagged_decoder_sptr_relative_rate(self)

    def start(self):
        """start(tagged_decoder_sptr self) -> bool"""
        return _fec_swig.tagged_decoder_sptr_start(self)

    def stop(self):
        """stop(tagged_decoder_sptr self) -> bool"""
        return _fec_swig.tagged_decoder_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(tagged_decoder_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.tagged_decoder_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(tagged_decoder_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.tagged_decoder_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(tagged_decoder_sptr self) -> int"""
        return _fec_swig.tagged_decoder_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(tagged_decoder_sptr self, int m)"""
        return _fec_swig.tagged_decoder_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(tagged_decoder_sptr self)"""
        return _fec_swig.tagged_decoder_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(tagged_decoder_sptr self) -> bool"""
        return _fec_swig.tagged_decoder_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(tagged_decoder_sptr self, int m)"""
        return _fec_swig.tagged_decoder_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(tagged_decoder_sptr self) -> int"""
        return _fec_swig.tagged_decoder_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(tagged_decoder_sptr self, int i) -> long"""
        return _fec_swig.tagged_decoder_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(tagged_decoder_sptr self, long max_output_buffer)
        set_max_output_buffer(tagged_decoder_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.tagged_decoder_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(tagged_decoder_sptr self, int i) -> long"""
        return _fec_swig.tagged_decoder_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(tagged_decoder_sptr self, long min_output_buffer)
        set_min_output_buffer(tagged_decoder_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.tagged_decoder_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(tagged_decoder_sptr self) -> float"""
        return _fec_swig.tagged_decoder_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(tagged_decoder_sptr self) -> float"""
        return _fec_swig.tagged_decoder_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(tagged_decoder_sptr self) -> float"""
        return _fec_swig.tagged_decoder_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(tagged_decoder_sptr self) -> float"""
        return _fec_swig.tagged_decoder_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(tagged_decoder_sptr self) -> float"""
        return _fec_swig.tagged_decoder_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(tagged_decoder_sptr self) -> float"""
        return _fec_swig.tagged_decoder_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(tagged_decoder_sptr self, int which) -> float
        pc_input_buffers_full(tagged_decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.tagged_decoder_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(tagged_decoder_sptr self, int which) -> float
        pc_input_buffers_full_avg(tagged_decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.tagged_decoder_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(tagged_decoder_sptr self, int which) -> float
        pc_input_buffers_full_var(tagged_decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.tagged_decoder_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(tagged_decoder_sptr self, int which) -> float
        pc_output_buffers_full(tagged_decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.tagged_decoder_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(tagged_decoder_sptr self, int which) -> float
        pc_output_buffers_full_avg(tagged_decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.tagged_decoder_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(tagged_decoder_sptr self, int which) -> float
        pc_output_buffers_full_var(tagged_decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.tagged_decoder_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(tagged_decoder_sptr self) -> float"""
        return _fec_swig.tagged_decoder_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(tagged_decoder_sptr self) -> float"""
        return _fec_swig.tagged_decoder_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(tagged_decoder_sptr self) -> float"""
        return _fec_swig.tagged_decoder_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(tagged_decoder_sptr self) -> float"""
        return _fec_swig.tagged_decoder_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(tagged_decoder_sptr self) -> float"""
        return _fec_swig.tagged_decoder_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(tagged_decoder_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.tagged_decoder_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(tagged_decoder_sptr self)"""
        return _fec_swig.tagged_decoder_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(tagged_decoder_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.tagged_decoder_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(tagged_decoder_sptr self) -> int"""
        return _fec_swig.tagged_decoder_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(tagged_decoder_sptr self) -> int"""
        return _fec_swig.tagged_decoder_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(tagged_decoder_sptr self, int priority) -> int"""
        return _fec_swig.tagged_decoder_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(tagged_decoder_sptr self) -> std::string"""
        return _fec_swig.tagged_decoder_sptr_name(self)

    def symbol_name(self):
        """symbol_name(tagged_decoder_sptr self) -> std::string"""
        return _fec_swig.tagged_decoder_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(tagged_decoder_sptr self) -> io_signature_sptr"""
        return _fec_swig.tagged_decoder_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(tagged_decoder_sptr self) -> io_signature_sptr"""
        return _fec_swig.tagged_decoder_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(tagged_decoder_sptr self) -> long"""
        return _fec_swig.tagged_decoder_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(tagged_decoder_sptr self) -> basic_block_sptr"""
        return _fec_swig.tagged_decoder_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(tagged_decoder_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.tagged_decoder_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(tagged_decoder_sptr self) -> std::string"""
        return _fec_swig.tagged_decoder_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(tagged_decoder_sptr self, std::string name)"""
        return _fec_swig.tagged_decoder_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(tagged_decoder_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.tagged_decoder_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(tagged_decoder_sptr self) -> swig_int_ptr"""
        return _fec_swig.tagged_decoder_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(tagged_decoder_sptr self) -> swig_int_ptr"""
        return _fec_swig.tagged_decoder_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(tagged_decoder_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.tagged_decoder_sptr_message_subscribers(self, *args, **kwargs)

tagged_decoder_sptr_swigregister = _fec_swig.tagged_decoder_sptr_swigregister
tagged_decoder_sptr_swigregister(tagged_decoder_sptr)

tagged_decoder_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
tagged_decoder = tagged_decoder.make;

class tagged_encoder_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::tagged_encoder)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::tagged_encoder)> self) -> tagged_encoder_sptr
        __init__(boost::shared_ptr<(gr::fec::tagged_encoder)> self, tagged_encoder p) -> tagged_encoder_sptr
        """
        this = _fec_swig.new_tagged_encoder_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(tagged_encoder_sptr self) -> tagged_encoder"""
        return _fec_swig.tagged_encoder_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_tagged_encoder_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(tagged_encoder_sptr self, generic_encoder_sptr my_encoder, size_t input_item_size, size_t output_item_size, 
            std::string const & lengthtagname="packet_len", int mtu=1500) -> tagged_encoder_sptr

        Creates the encoder block for use in GNU Radio flowgraphs from a given FECAPI object derived from the generic_encoder class.

        Generally, we would use the fec.extended_encoder Python implementation to instantiate this. The extended_encoder wraps up a few more details, like taking care of puncturing as well as the encoder itself.

        Constructor Specific Documentation:

        Build the FEC encoder block from an FECAPI encoder object.

        Args:
            my_encoder : An FECAPI encoder object child of the generic_encoder class.
            input_item_size : size of a block of data for the encoder.
            output_item_size : size of a block of data the encoder will produce.
            lengthtagname : Key name of the tagged stream frame size.
            mtu : The Maximum Transmission Unit (MTU) of the input frame that the block will be able to process. Specified in bytes and defaults to 1500.
        """
        return _fec_swig.tagged_encoder_sptr_make(self, *args, **kwargs)

    def work(self, *args, **kwargs):
        """
        work(tagged_encoder_sptr self, int noutput_items, gr_vector_int & ninput_items, gr_vector_const_void_star & input_items, 
            gr_vector_void_star & output_items) -> int
        """
        return _fec_swig.tagged_encoder_sptr_work(self, *args, **kwargs)

    def calculate_output_stream_length(self, *args, **kwargs):
        """calculate_output_stream_length(tagged_encoder_sptr self, gr_vector_int const & ninput_items) -> int"""
        return _fec_swig.tagged_encoder_sptr_calculate_output_stream_length(self, *args, **kwargs)

    def history(self):
        """history(tagged_encoder_sptr self) -> unsigned int"""
        return _fec_swig.tagged_encoder_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(tagged_encoder_sptr self, int which, int delay)
        declare_sample_delay(tagged_encoder_sptr self, unsigned int delay)
        """
        return _fec_swig.tagged_encoder_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(tagged_encoder_sptr self, int which) -> unsigned int"""
        return _fec_swig.tagged_encoder_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(tagged_encoder_sptr self) -> int"""
        return _fec_swig.tagged_encoder_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(tagged_encoder_sptr self) -> double"""
        return _fec_swig.tagged_encoder_sptr_relative_rate(self)

    def start(self):
        """start(tagged_encoder_sptr self) -> bool"""
        return _fec_swig.tagged_encoder_sptr_start(self)

    def stop(self):
        """stop(tagged_encoder_sptr self) -> bool"""
        return _fec_swig.tagged_encoder_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(tagged_encoder_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.tagged_encoder_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(tagged_encoder_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.tagged_encoder_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(tagged_encoder_sptr self) -> int"""
        return _fec_swig.tagged_encoder_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(tagged_encoder_sptr self, int m)"""
        return _fec_swig.tagged_encoder_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(tagged_encoder_sptr self)"""
        return _fec_swig.tagged_encoder_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(tagged_encoder_sptr self) -> bool"""
        return _fec_swig.tagged_encoder_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(tagged_encoder_sptr self, int m)"""
        return _fec_swig.tagged_encoder_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(tagged_encoder_sptr self) -> int"""
        return _fec_swig.tagged_encoder_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(tagged_encoder_sptr self, int i) -> long"""
        return _fec_swig.tagged_encoder_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(tagged_encoder_sptr self, long max_output_buffer)
        set_max_output_buffer(tagged_encoder_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.tagged_encoder_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(tagged_encoder_sptr self, int i) -> long"""
        return _fec_swig.tagged_encoder_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(tagged_encoder_sptr self, long min_output_buffer)
        set_min_output_buffer(tagged_encoder_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.tagged_encoder_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(tagged_encoder_sptr self) -> float"""
        return _fec_swig.tagged_encoder_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(tagged_encoder_sptr self) -> float"""
        return _fec_swig.tagged_encoder_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(tagged_encoder_sptr self) -> float"""
        return _fec_swig.tagged_encoder_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(tagged_encoder_sptr self) -> float"""
        return _fec_swig.tagged_encoder_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(tagged_encoder_sptr self) -> float"""
        return _fec_swig.tagged_encoder_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(tagged_encoder_sptr self) -> float"""
        return _fec_swig.tagged_encoder_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(tagged_encoder_sptr self, int which) -> float
        pc_input_buffers_full(tagged_encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.tagged_encoder_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(tagged_encoder_sptr self, int which) -> float
        pc_input_buffers_full_avg(tagged_encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.tagged_encoder_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(tagged_encoder_sptr self, int which) -> float
        pc_input_buffers_full_var(tagged_encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.tagged_encoder_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(tagged_encoder_sptr self, int which) -> float
        pc_output_buffers_full(tagged_encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.tagged_encoder_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(tagged_encoder_sptr self, int which) -> float
        pc_output_buffers_full_avg(tagged_encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.tagged_encoder_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(tagged_encoder_sptr self, int which) -> float
        pc_output_buffers_full_var(tagged_encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.tagged_encoder_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(tagged_encoder_sptr self) -> float"""
        return _fec_swig.tagged_encoder_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(tagged_encoder_sptr self) -> float"""
        return _fec_swig.tagged_encoder_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(tagged_encoder_sptr self) -> float"""
        return _fec_swig.tagged_encoder_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(tagged_encoder_sptr self) -> float"""
        return _fec_swig.tagged_encoder_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(tagged_encoder_sptr self) -> float"""
        return _fec_swig.tagged_encoder_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(tagged_encoder_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.tagged_encoder_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(tagged_encoder_sptr self)"""
        return _fec_swig.tagged_encoder_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(tagged_encoder_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.tagged_encoder_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(tagged_encoder_sptr self) -> int"""
        return _fec_swig.tagged_encoder_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(tagged_encoder_sptr self) -> int"""
        return _fec_swig.tagged_encoder_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(tagged_encoder_sptr self, int priority) -> int"""
        return _fec_swig.tagged_encoder_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(tagged_encoder_sptr self) -> std::string"""
        return _fec_swig.tagged_encoder_sptr_name(self)

    def symbol_name(self):
        """symbol_name(tagged_encoder_sptr self) -> std::string"""
        return _fec_swig.tagged_encoder_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(tagged_encoder_sptr self) -> io_signature_sptr"""
        return _fec_swig.tagged_encoder_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(tagged_encoder_sptr self) -> io_signature_sptr"""
        return _fec_swig.tagged_encoder_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(tagged_encoder_sptr self) -> long"""
        return _fec_swig.tagged_encoder_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(tagged_encoder_sptr self) -> basic_block_sptr"""
        return _fec_swig.tagged_encoder_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(tagged_encoder_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.tagged_encoder_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(tagged_encoder_sptr self) -> std::string"""
        return _fec_swig.tagged_encoder_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(tagged_encoder_sptr self, std::string name)"""
        return _fec_swig.tagged_encoder_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(tagged_encoder_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.tagged_encoder_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(tagged_encoder_sptr self) -> swig_int_ptr"""
        return _fec_swig.tagged_encoder_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(tagged_encoder_sptr self) -> swig_int_ptr"""
        return _fec_swig.tagged_encoder_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(tagged_encoder_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.tagged_encoder_sptr_message_subscribers(self, *args, **kwargs)

tagged_encoder_sptr_swigregister = _fec_swig.tagged_encoder_sptr_swigregister
tagged_encoder_sptr_swigregister(tagged_encoder_sptr)

tagged_encoder_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
tagged_encoder = tagged_encoder.make;

class async_decoder_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::async_decoder)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::async_decoder)> self) -> async_decoder_sptr
        __init__(boost::shared_ptr<(gr::fec::async_decoder)> self, async_decoder p) -> async_decoder_sptr
        """
        this = _fec_swig.new_async_decoder_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(async_decoder_sptr self) -> async_decoder"""
        return _fec_swig.async_decoder_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_async_decoder_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(async_decoder_sptr self, generic_decoder_sptr my_decoder, bool packed=False, bool rev_pack=True, int mtu=1500) -> async_decoder_sptr

        Creates the decoder block for use in GNU Radio flowgraphs from a given FEC API object derived from the generic_decoder class.

        Decodes frames received as async messages over a message port. This decoder deployment expects messages of soft decision symbols in and can produce either packed, PDU messages ( = True) or messages full of unpacked bits ( = False).

        This decoder works off a full message as one frame or block to decode. The message length is used to calculate the frame length. To support this, the decoder variable used will have had its frame_size set. This block treats that initial frame_size value as the maximum transmission unit (MTU) and will not process frames larger than that after being decoded.

        The packed PDU form of this deployment is designed to work well with other PDU-based blocks to operate within the processing flow of data packets or frames.

        Due to differences in how data is packed and processed, this block also offers the ability to change the direction of how bits are packed. All inputs messages are one soft decision per item. By default, the  mode is set to True. Using this setup allows the async block to behave with PDUs in the same operation and format as the tagged stream decoders. That is, putting the same data into both the tagged stream decoder deployment and this with the default setting should produce the same data.

        Because the block handles data as a full frame per message, this decoder deployment cannot work with any decoders that require history. For example, the gr::fec::code::cc_decoder decoder in streaming mode requires an extra rate*(K-1) bits to complete the decoding, so it would have to wait for the next message to come in and finish processing. Therefore, the streaming mode of the CC decoder is not allowed. The other three modes will work with this deployment since the frame is self-contained for decoding.

        Constructor Specific Documentation:

        Build the PDU-based FEC decoder block from an FECAPI decoder object.

        Args:
            my_decoder : An FECAPI decoder object child of the generic_decoder class.
            packed : Sets output to packed bytes if true; otherwise, 1 bit per byte.
            rev_pack : If packing bits, should they be reversed?
            mtu : The Maximum Transmission Unit (MTU) of the output frame that the block will be able to process. Specified in bytes and defaults to 1500.
        """
        return _fec_swig.async_decoder_sptr_make(self, *args, **kwargs)

    def general_work(self, *args, **kwargs):
        """
        general_work(async_decoder_sptr self, int noutput_items, gr_vector_int & ninput_items, gr_vector_const_void_star & input_items, 
            gr_vector_void_star & output_items) -> int
        """
        return _fec_swig.async_decoder_sptr_general_work(self, *args, **kwargs)

    def history(self):
        """history(async_decoder_sptr self) -> unsigned int"""
        return _fec_swig.async_decoder_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(async_decoder_sptr self, int which, int delay)
        declare_sample_delay(async_decoder_sptr self, unsigned int delay)
        """
        return _fec_swig.async_decoder_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(async_decoder_sptr self, int which) -> unsigned int"""
        return _fec_swig.async_decoder_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(async_decoder_sptr self) -> int"""
        return _fec_swig.async_decoder_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(async_decoder_sptr self) -> double"""
        return _fec_swig.async_decoder_sptr_relative_rate(self)

    def start(self):
        """start(async_decoder_sptr self) -> bool"""
        return _fec_swig.async_decoder_sptr_start(self)

    def stop(self):
        """stop(async_decoder_sptr self) -> bool"""
        return _fec_swig.async_decoder_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(async_decoder_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.async_decoder_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(async_decoder_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.async_decoder_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(async_decoder_sptr self) -> int"""
        return _fec_swig.async_decoder_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(async_decoder_sptr self, int m)"""
        return _fec_swig.async_decoder_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(async_decoder_sptr self)"""
        return _fec_swig.async_decoder_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(async_decoder_sptr self) -> bool"""
        return _fec_swig.async_decoder_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(async_decoder_sptr self, int m)"""
        return _fec_swig.async_decoder_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(async_decoder_sptr self) -> int"""
        return _fec_swig.async_decoder_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(async_decoder_sptr self, int i) -> long"""
        return _fec_swig.async_decoder_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(async_decoder_sptr self, long max_output_buffer)
        set_max_output_buffer(async_decoder_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.async_decoder_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(async_decoder_sptr self, int i) -> long"""
        return _fec_swig.async_decoder_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(async_decoder_sptr self, long min_output_buffer)
        set_min_output_buffer(async_decoder_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.async_decoder_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(async_decoder_sptr self) -> float"""
        return _fec_swig.async_decoder_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(async_decoder_sptr self) -> float"""
        return _fec_swig.async_decoder_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(async_decoder_sptr self) -> float"""
        return _fec_swig.async_decoder_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(async_decoder_sptr self) -> float"""
        return _fec_swig.async_decoder_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(async_decoder_sptr self) -> float"""
        return _fec_swig.async_decoder_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(async_decoder_sptr self) -> float"""
        return _fec_swig.async_decoder_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(async_decoder_sptr self, int which) -> float
        pc_input_buffers_full(async_decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.async_decoder_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(async_decoder_sptr self, int which) -> float
        pc_input_buffers_full_avg(async_decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.async_decoder_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(async_decoder_sptr self, int which) -> float
        pc_input_buffers_full_var(async_decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.async_decoder_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(async_decoder_sptr self, int which) -> float
        pc_output_buffers_full(async_decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.async_decoder_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(async_decoder_sptr self, int which) -> float
        pc_output_buffers_full_avg(async_decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.async_decoder_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(async_decoder_sptr self, int which) -> float
        pc_output_buffers_full_var(async_decoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.async_decoder_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(async_decoder_sptr self) -> float"""
        return _fec_swig.async_decoder_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(async_decoder_sptr self) -> float"""
        return _fec_swig.async_decoder_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(async_decoder_sptr self) -> float"""
        return _fec_swig.async_decoder_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(async_decoder_sptr self) -> float"""
        return _fec_swig.async_decoder_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(async_decoder_sptr self) -> float"""
        return _fec_swig.async_decoder_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(async_decoder_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.async_decoder_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(async_decoder_sptr self)"""
        return _fec_swig.async_decoder_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(async_decoder_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.async_decoder_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(async_decoder_sptr self) -> int"""
        return _fec_swig.async_decoder_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(async_decoder_sptr self) -> int"""
        return _fec_swig.async_decoder_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(async_decoder_sptr self, int priority) -> int"""
        return _fec_swig.async_decoder_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(async_decoder_sptr self) -> std::string"""
        return _fec_swig.async_decoder_sptr_name(self)

    def symbol_name(self):
        """symbol_name(async_decoder_sptr self) -> std::string"""
        return _fec_swig.async_decoder_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(async_decoder_sptr self) -> io_signature_sptr"""
        return _fec_swig.async_decoder_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(async_decoder_sptr self) -> io_signature_sptr"""
        return _fec_swig.async_decoder_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(async_decoder_sptr self) -> long"""
        return _fec_swig.async_decoder_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(async_decoder_sptr self) -> basic_block_sptr"""
        return _fec_swig.async_decoder_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(async_decoder_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.async_decoder_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(async_decoder_sptr self) -> std::string"""
        return _fec_swig.async_decoder_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(async_decoder_sptr self, std::string name)"""
        return _fec_swig.async_decoder_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(async_decoder_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.async_decoder_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(async_decoder_sptr self) -> swig_int_ptr"""
        return _fec_swig.async_decoder_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(async_decoder_sptr self) -> swig_int_ptr"""
        return _fec_swig.async_decoder_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(async_decoder_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.async_decoder_sptr_message_subscribers(self, *args, **kwargs)

async_decoder_sptr_swigregister = _fec_swig.async_decoder_sptr_swigregister
async_decoder_sptr_swigregister(async_decoder_sptr)

async_decoder_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
async_decoder = async_decoder.make;

class async_encoder_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::async_encoder)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::async_encoder)> self) -> async_encoder_sptr
        __init__(boost::shared_ptr<(gr::fec::async_encoder)> self, async_encoder p) -> async_encoder_sptr
        """
        this = _fec_swig.new_async_encoder_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(async_encoder_sptr self) -> async_encoder"""
        return _fec_swig.async_encoder_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_async_encoder_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(async_encoder_sptr self, generic_encoder_sptr my_encoder, bool packed=False, bool rev_unpack=True, bool rev_pack=True, 
            int mtu=1500) -> async_encoder_sptr

        Creates the encoder block for use in GNU Radio flowgraphs with async message from a given FEC API object derived from the generic_encoder class.

        Encodes frames received as async messages or as a PDU over a message port. This encoder works off a full message as one frame or block to encode. The message length is used as the frame length. To support this, the encoder variable used will have had its frame_size set. This block treats that initial frame_size value as the maximum transmission unit (MTU) and will not process frames larger than that.

        This deployment works off messages and expects them to either be messages full of unpacked bits or PDU messages, which means full bytes of a frame from the higher layers, including things like headers, tails, CRC check bytes, etc. For handling PDUs, set the  option of this deployment block to True. The block will then use the FEC API to properly unpack the bits from the PDU, pass it through the encoder, and repack them to output the PDUs for the next stage of processing.

        The packed PDU form of this deployment is designed to work well with other PDU-based blocks to operate within the processing flow of data packets or frames.

        Due to differences in how data is packed and processed, this block also offers the ability to change the direction of how bits are unpacked and packed, where reading or writing from the LSB or MSB. By default, the  and  modes are set to True. Using this setup allows the async block to behave with PDUs in the same operation and format as the tagged stream encoders. That is, putting the same data into both the tagged stream encoder deployment and this with these default settings should produce the same data.

        Constructor Specific Documentation:

        Build the PDU-based FEC encoder block from an FECAPI encoder object.

        Args:
            my_encoder : An FECAPI encoder object child of the generic_encoder class.
            packed : True if working on packed bytes (like PDUs).
            rev_unpack : Reverse the unpacking order from input bytes to bits.
            rev_pack : Reverse the packing order from bits to output bytes.
            mtu : The Maximum Transmission Unit (MTU) of the input frame that the block will be able to process. Specified in bytes and defaults to 1500.
        """
        return _fec_swig.async_encoder_sptr_make(self, *args, **kwargs)

    def general_work(self, *args, **kwargs):
        """
        general_work(async_encoder_sptr self, int noutput_items, gr_vector_int & ninput_items, gr_vector_const_void_star & input_items, 
            gr_vector_void_star & output_items) -> int
        """
        return _fec_swig.async_encoder_sptr_general_work(self, *args, **kwargs)

    def history(self):
        """history(async_encoder_sptr self) -> unsigned int"""
        return _fec_swig.async_encoder_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(async_encoder_sptr self, int which, int delay)
        declare_sample_delay(async_encoder_sptr self, unsigned int delay)
        """
        return _fec_swig.async_encoder_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(async_encoder_sptr self, int which) -> unsigned int"""
        return _fec_swig.async_encoder_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(async_encoder_sptr self) -> int"""
        return _fec_swig.async_encoder_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(async_encoder_sptr self) -> double"""
        return _fec_swig.async_encoder_sptr_relative_rate(self)

    def start(self):
        """start(async_encoder_sptr self) -> bool"""
        return _fec_swig.async_encoder_sptr_start(self)

    def stop(self):
        """stop(async_encoder_sptr self) -> bool"""
        return _fec_swig.async_encoder_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(async_encoder_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.async_encoder_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(async_encoder_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.async_encoder_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(async_encoder_sptr self) -> int"""
        return _fec_swig.async_encoder_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(async_encoder_sptr self, int m)"""
        return _fec_swig.async_encoder_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(async_encoder_sptr self)"""
        return _fec_swig.async_encoder_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(async_encoder_sptr self) -> bool"""
        return _fec_swig.async_encoder_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(async_encoder_sptr self, int m)"""
        return _fec_swig.async_encoder_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(async_encoder_sptr self) -> int"""
        return _fec_swig.async_encoder_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(async_encoder_sptr self, int i) -> long"""
        return _fec_swig.async_encoder_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(async_encoder_sptr self, long max_output_buffer)
        set_max_output_buffer(async_encoder_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.async_encoder_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(async_encoder_sptr self, int i) -> long"""
        return _fec_swig.async_encoder_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(async_encoder_sptr self, long min_output_buffer)
        set_min_output_buffer(async_encoder_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.async_encoder_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(async_encoder_sptr self) -> float"""
        return _fec_swig.async_encoder_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(async_encoder_sptr self) -> float"""
        return _fec_swig.async_encoder_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(async_encoder_sptr self) -> float"""
        return _fec_swig.async_encoder_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(async_encoder_sptr self) -> float"""
        return _fec_swig.async_encoder_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(async_encoder_sptr self) -> float"""
        return _fec_swig.async_encoder_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(async_encoder_sptr self) -> float"""
        return _fec_swig.async_encoder_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(async_encoder_sptr self, int which) -> float
        pc_input_buffers_full(async_encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.async_encoder_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(async_encoder_sptr self, int which) -> float
        pc_input_buffers_full_avg(async_encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.async_encoder_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(async_encoder_sptr self, int which) -> float
        pc_input_buffers_full_var(async_encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.async_encoder_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(async_encoder_sptr self, int which) -> float
        pc_output_buffers_full(async_encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.async_encoder_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(async_encoder_sptr self, int which) -> float
        pc_output_buffers_full_avg(async_encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.async_encoder_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(async_encoder_sptr self, int which) -> float
        pc_output_buffers_full_var(async_encoder_sptr self) -> pmt_vector_float
        """
        return _fec_swig.async_encoder_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(async_encoder_sptr self) -> float"""
        return _fec_swig.async_encoder_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(async_encoder_sptr self) -> float"""
        return _fec_swig.async_encoder_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(async_encoder_sptr self) -> float"""
        return _fec_swig.async_encoder_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(async_encoder_sptr self) -> float"""
        return _fec_swig.async_encoder_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(async_encoder_sptr self) -> float"""
        return _fec_swig.async_encoder_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(async_encoder_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.async_encoder_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(async_encoder_sptr self)"""
        return _fec_swig.async_encoder_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(async_encoder_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.async_encoder_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(async_encoder_sptr self) -> int"""
        return _fec_swig.async_encoder_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(async_encoder_sptr self) -> int"""
        return _fec_swig.async_encoder_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(async_encoder_sptr self, int priority) -> int"""
        return _fec_swig.async_encoder_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(async_encoder_sptr self) -> std::string"""
        return _fec_swig.async_encoder_sptr_name(self)

    def symbol_name(self):
        """symbol_name(async_encoder_sptr self) -> std::string"""
        return _fec_swig.async_encoder_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(async_encoder_sptr self) -> io_signature_sptr"""
        return _fec_swig.async_encoder_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(async_encoder_sptr self) -> io_signature_sptr"""
        return _fec_swig.async_encoder_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(async_encoder_sptr self) -> long"""
        return _fec_swig.async_encoder_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(async_encoder_sptr self) -> basic_block_sptr"""
        return _fec_swig.async_encoder_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(async_encoder_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.async_encoder_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(async_encoder_sptr self) -> std::string"""
        return _fec_swig.async_encoder_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(async_encoder_sptr self, std::string name)"""
        return _fec_swig.async_encoder_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(async_encoder_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.async_encoder_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(async_encoder_sptr self) -> swig_int_ptr"""
        return _fec_swig.async_encoder_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(async_encoder_sptr self) -> swig_int_ptr"""
        return _fec_swig.async_encoder_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(async_encoder_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.async_encoder_sptr_message_subscribers(self, *args, **kwargs)

async_encoder_sptr_swigregister = _fec_swig.async_encoder_sptr_swigregister
async_encoder_sptr_swigregister(async_encoder_sptr)

async_encoder_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
async_encoder = async_encoder.make;

class decode_ccsds_27_fb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::decode_ccsds_27_fb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::decode_ccsds_27_fb)> self) -> decode_ccsds_27_fb_sptr
        __init__(boost::shared_ptr<(gr::fec::decode_ccsds_27_fb)> self, decode_ccsds_27_fb p) -> decode_ccsds_27_fb_sptr
        """
        this = _fec_swig.new_decode_ccsds_27_fb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(decode_ccsds_27_fb_sptr self) -> decode_ccsds_27_fb"""
        return _fec_swig.decode_ccsds_27_fb_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_decode_ccsds_27_fb_sptr
    __del__ = lambda self : None;
    def make(self):
        """
        make(decode_ccsds_27_fb_sptr self) -> decode_ccsds_27_fb_sptr

        A rate 1/2, k=7 convolutional decoder for the CCSDS standard.

        This block performs soft-decision convolutional decoding using the Viterbi algorithm.

        The input is a stream of (possibly noise corrupted) floating point values nominally spanning [-1.0, 1.0], representing the encoded channel symbols 0 (-1.0) and 1 (1.0), with erased symbols at 0.0.

        The output is MSB first packed bytes of decoded values.

        As a rate 1/2 code, there will be one output byte for every 16 input symbols.

        This block is designed for continuous data streaming, not packetized data. The first 32 bits out will be zeroes, with the output delayed four bytes from the corresponding inputs.

        Constructor Specific Documentation:


        """
        return _fec_swig.decode_ccsds_27_fb_sptr_make(self)

    def history(self):
        """history(decode_ccsds_27_fb_sptr self) -> unsigned int"""
        return _fec_swig.decode_ccsds_27_fb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(decode_ccsds_27_fb_sptr self, int which, int delay)
        declare_sample_delay(decode_ccsds_27_fb_sptr self, unsigned int delay)
        """
        return _fec_swig.decode_ccsds_27_fb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(decode_ccsds_27_fb_sptr self, int which) -> unsigned int"""
        return _fec_swig.decode_ccsds_27_fb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(decode_ccsds_27_fb_sptr self) -> int"""
        return _fec_swig.decode_ccsds_27_fb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(decode_ccsds_27_fb_sptr self) -> double"""
        return _fec_swig.decode_ccsds_27_fb_sptr_relative_rate(self)

    def start(self):
        """start(decode_ccsds_27_fb_sptr self) -> bool"""
        return _fec_swig.decode_ccsds_27_fb_sptr_start(self)

    def stop(self):
        """stop(decode_ccsds_27_fb_sptr self) -> bool"""
        return _fec_swig.decode_ccsds_27_fb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(decode_ccsds_27_fb_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.decode_ccsds_27_fb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(decode_ccsds_27_fb_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.decode_ccsds_27_fb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(decode_ccsds_27_fb_sptr self) -> int"""
        return _fec_swig.decode_ccsds_27_fb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(decode_ccsds_27_fb_sptr self, int m)"""
        return _fec_swig.decode_ccsds_27_fb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(decode_ccsds_27_fb_sptr self)"""
        return _fec_swig.decode_ccsds_27_fb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(decode_ccsds_27_fb_sptr self) -> bool"""
        return _fec_swig.decode_ccsds_27_fb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(decode_ccsds_27_fb_sptr self, int m)"""
        return _fec_swig.decode_ccsds_27_fb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(decode_ccsds_27_fb_sptr self) -> int"""
        return _fec_swig.decode_ccsds_27_fb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(decode_ccsds_27_fb_sptr self, int i) -> long"""
        return _fec_swig.decode_ccsds_27_fb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(decode_ccsds_27_fb_sptr self, long max_output_buffer)
        set_max_output_buffer(decode_ccsds_27_fb_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.decode_ccsds_27_fb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(decode_ccsds_27_fb_sptr self, int i) -> long"""
        return _fec_swig.decode_ccsds_27_fb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(decode_ccsds_27_fb_sptr self, long min_output_buffer)
        set_min_output_buffer(decode_ccsds_27_fb_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.decode_ccsds_27_fb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(decode_ccsds_27_fb_sptr self) -> float"""
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(decode_ccsds_27_fb_sptr self) -> float"""
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(decode_ccsds_27_fb_sptr self) -> float"""
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(decode_ccsds_27_fb_sptr self) -> float"""
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(decode_ccsds_27_fb_sptr self) -> float"""
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(decode_ccsds_27_fb_sptr self) -> float"""
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(decode_ccsds_27_fb_sptr self, int which) -> float
        pc_input_buffers_full(decode_ccsds_27_fb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(decode_ccsds_27_fb_sptr self, int which) -> float
        pc_input_buffers_full_avg(decode_ccsds_27_fb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(decode_ccsds_27_fb_sptr self, int which) -> float
        pc_input_buffers_full_var(decode_ccsds_27_fb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(decode_ccsds_27_fb_sptr self, int which) -> float
        pc_output_buffers_full(decode_ccsds_27_fb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(decode_ccsds_27_fb_sptr self, int which) -> float
        pc_output_buffers_full_avg(decode_ccsds_27_fb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(decode_ccsds_27_fb_sptr self, int which) -> float
        pc_output_buffers_full_var(decode_ccsds_27_fb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(decode_ccsds_27_fb_sptr self) -> float"""
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(decode_ccsds_27_fb_sptr self) -> float"""
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(decode_ccsds_27_fb_sptr self) -> float"""
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(decode_ccsds_27_fb_sptr self) -> float"""
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(decode_ccsds_27_fb_sptr self) -> float"""
        return _fec_swig.decode_ccsds_27_fb_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(decode_ccsds_27_fb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.decode_ccsds_27_fb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(decode_ccsds_27_fb_sptr self)"""
        return _fec_swig.decode_ccsds_27_fb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(decode_ccsds_27_fb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.decode_ccsds_27_fb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(decode_ccsds_27_fb_sptr self) -> int"""
        return _fec_swig.decode_ccsds_27_fb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(decode_ccsds_27_fb_sptr self) -> int"""
        return _fec_swig.decode_ccsds_27_fb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(decode_ccsds_27_fb_sptr self, int priority) -> int"""
        return _fec_swig.decode_ccsds_27_fb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(decode_ccsds_27_fb_sptr self) -> std::string"""
        return _fec_swig.decode_ccsds_27_fb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(decode_ccsds_27_fb_sptr self) -> std::string"""
        return _fec_swig.decode_ccsds_27_fb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(decode_ccsds_27_fb_sptr self) -> io_signature_sptr"""
        return _fec_swig.decode_ccsds_27_fb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(decode_ccsds_27_fb_sptr self) -> io_signature_sptr"""
        return _fec_swig.decode_ccsds_27_fb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(decode_ccsds_27_fb_sptr self) -> long"""
        return _fec_swig.decode_ccsds_27_fb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(decode_ccsds_27_fb_sptr self) -> basic_block_sptr"""
        return _fec_swig.decode_ccsds_27_fb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(decode_ccsds_27_fb_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.decode_ccsds_27_fb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(decode_ccsds_27_fb_sptr self) -> std::string"""
        return _fec_swig.decode_ccsds_27_fb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(decode_ccsds_27_fb_sptr self, std::string name)"""
        return _fec_swig.decode_ccsds_27_fb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(decode_ccsds_27_fb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.decode_ccsds_27_fb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(decode_ccsds_27_fb_sptr self) -> swig_int_ptr"""
        return _fec_swig.decode_ccsds_27_fb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(decode_ccsds_27_fb_sptr self) -> swig_int_ptr"""
        return _fec_swig.decode_ccsds_27_fb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(decode_ccsds_27_fb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.decode_ccsds_27_fb_sptr_message_subscribers(self, *args, **kwargs)

decode_ccsds_27_fb_sptr_swigregister = _fec_swig.decode_ccsds_27_fb_sptr_swigregister
decode_ccsds_27_fb_sptr_swigregister(decode_ccsds_27_fb_sptr)

decode_ccsds_27_fb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
decode_ccsds_27_fb = decode_ccsds_27_fb.make;

class encode_ccsds_27_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::encode_ccsds_27_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::encode_ccsds_27_bb)> self) -> encode_ccsds_27_bb_sptr
        __init__(boost::shared_ptr<(gr::fec::encode_ccsds_27_bb)> self, encode_ccsds_27_bb p) -> encode_ccsds_27_bb_sptr
        """
        this = _fec_swig.new_encode_ccsds_27_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(encode_ccsds_27_bb_sptr self) -> encode_ccsds_27_bb"""
        return _fec_swig.encode_ccsds_27_bb_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_encode_ccsds_27_bb_sptr
    __del__ = lambda self : None;
    def make(self):
        """
        make(encode_ccsds_27_bb_sptr self) -> encode_ccsds_27_bb_sptr

        A rate 1/2, k=7 convolutional encoder for the CCSDS standard.

        This block performs convolutional encoding using the CCSDS standard polynomial ("Voyager").

        The input is an MSB first packed stream of bits.

        The output is a stream of symbols 0 or 1 representing the encoded data.

        As a rate 1/2 code, there will be 16 output symbols for every input byte.

        This block is designed for continuous data streaming, not packetized data. There is no provision to "flush" the encoder.

        Constructor Specific Documentation:


        """
        return _fec_swig.encode_ccsds_27_bb_sptr_make(self)

    def history(self):
        """history(encode_ccsds_27_bb_sptr self) -> unsigned int"""
        return _fec_swig.encode_ccsds_27_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(encode_ccsds_27_bb_sptr self, int which, int delay)
        declare_sample_delay(encode_ccsds_27_bb_sptr self, unsigned int delay)
        """
        return _fec_swig.encode_ccsds_27_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(encode_ccsds_27_bb_sptr self, int which) -> unsigned int"""
        return _fec_swig.encode_ccsds_27_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(encode_ccsds_27_bb_sptr self) -> int"""
        return _fec_swig.encode_ccsds_27_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(encode_ccsds_27_bb_sptr self) -> double"""
        return _fec_swig.encode_ccsds_27_bb_sptr_relative_rate(self)

    def start(self):
        """start(encode_ccsds_27_bb_sptr self) -> bool"""
        return _fec_swig.encode_ccsds_27_bb_sptr_start(self)

    def stop(self):
        """stop(encode_ccsds_27_bb_sptr self) -> bool"""
        return _fec_swig.encode_ccsds_27_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(encode_ccsds_27_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.encode_ccsds_27_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(encode_ccsds_27_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.encode_ccsds_27_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(encode_ccsds_27_bb_sptr self) -> int"""
        return _fec_swig.encode_ccsds_27_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(encode_ccsds_27_bb_sptr self, int m)"""
        return _fec_swig.encode_ccsds_27_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(encode_ccsds_27_bb_sptr self)"""
        return _fec_swig.encode_ccsds_27_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(encode_ccsds_27_bb_sptr self) -> bool"""
        return _fec_swig.encode_ccsds_27_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(encode_ccsds_27_bb_sptr self, int m)"""
        return _fec_swig.encode_ccsds_27_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(encode_ccsds_27_bb_sptr self) -> int"""
        return _fec_swig.encode_ccsds_27_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(encode_ccsds_27_bb_sptr self, int i) -> long"""
        return _fec_swig.encode_ccsds_27_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(encode_ccsds_27_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(encode_ccsds_27_bb_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.encode_ccsds_27_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(encode_ccsds_27_bb_sptr self, int i) -> long"""
        return _fec_swig.encode_ccsds_27_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(encode_ccsds_27_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(encode_ccsds_27_bb_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.encode_ccsds_27_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(encode_ccsds_27_bb_sptr self) -> float"""
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(encode_ccsds_27_bb_sptr self) -> float"""
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(encode_ccsds_27_bb_sptr self) -> float"""
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(encode_ccsds_27_bb_sptr self) -> float"""
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(encode_ccsds_27_bb_sptr self) -> float"""
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(encode_ccsds_27_bb_sptr self) -> float"""
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(encode_ccsds_27_bb_sptr self, int which) -> float
        pc_input_buffers_full(encode_ccsds_27_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(encode_ccsds_27_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(encode_ccsds_27_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(encode_ccsds_27_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(encode_ccsds_27_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(encode_ccsds_27_bb_sptr self, int which) -> float
        pc_output_buffers_full(encode_ccsds_27_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(encode_ccsds_27_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(encode_ccsds_27_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(encode_ccsds_27_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(encode_ccsds_27_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(encode_ccsds_27_bb_sptr self) -> float"""
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(encode_ccsds_27_bb_sptr self) -> float"""
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(encode_ccsds_27_bb_sptr self) -> float"""
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(encode_ccsds_27_bb_sptr self) -> float"""
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(encode_ccsds_27_bb_sptr self) -> float"""
        return _fec_swig.encode_ccsds_27_bb_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(encode_ccsds_27_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.encode_ccsds_27_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(encode_ccsds_27_bb_sptr self)"""
        return _fec_swig.encode_ccsds_27_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(encode_ccsds_27_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.encode_ccsds_27_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(encode_ccsds_27_bb_sptr self) -> int"""
        return _fec_swig.encode_ccsds_27_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(encode_ccsds_27_bb_sptr self) -> int"""
        return _fec_swig.encode_ccsds_27_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(encode_ccsds_27_bb_sptr self, int priority) -> int"""
        return _fec_swig.encode_ccsds_27_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(encode_ccsds_27_bb_sptr self) -> std::string"""
        return _fec_swig.encode_ccsds_27_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(encode_ccsds_27_bb_sptr self) -> std::string"""
        return _fec_swig.encode_ccsds_27_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(encode_ccsds_27_bb_sptr self) -> io_signature_sptr"""
        return _fec_swig.encode_ccsds_27_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(encode_ccsds_27_bb_sptr self) -> io_signature_sptr"""
        return _fec_swig.encode_ccsds_27_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(encode_ccsds_27_bb_sptr self) -> long"""
        return _fec_swig.encode_ccsds_27_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(encode_ccsds_27_bb_sptr self) -> basic_block_sptr"""
        return _fec_swig.encode_ccsds_27_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(encode_ccsds_27_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.encode_ccsds_27_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(encode_ccsds_27_bb_sptr self) -> std::string"""
        return _fec_swig.encode_ccsds_27_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(encode_ccsds_27_bb_sptr self, std::string name)"""
        return _fec_swig.encode_ccsds_27_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(encode_ccsds_27_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.encode_ccsds_27_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(encode_ccsds_27_bb_sptr self) -> swig_int_ptr"""
        return _fec_swig.encode_ccsds_27_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(encode_ccsds_27_bb_sptr self) -> swig_int_ptr"""
        return _fec_swig.encode_ccsds_27_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(encode_ccsds_27_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.encode_ccsds_27_bb_sptr_message_subscribers(self, *args, **kwargs)

encode_ccsds_27_bb_sptr_swigregister = _fec_swig.encode_ccsds_27_bb_sptr_swigregister
encode_ccsds_27_bb_sptr_swigregister(encode_ccsds_27_bb_sptr)

encode_ccsds_27_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
encode_ccsds_27_bb = encode_ccsds_27_bb.make;

class ber_bf_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::ber_bf)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::ber_bf)> self) -> ber_bf_sptr
        __init__(boost::shared_ptr<(gr::fec::ber_bf)> self, ber_bf p) -> ber_bf_sptr
        """
        this = _fec_swig.new_ber_bf_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(ber_bf_sptr self) -> ber_bf"""
        return _fec_swig.ber_bf_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_ber_bf_sptr
    __del__ = lambda self : None;
    def total_errors(self):
        """
        total_errors(ber_bf_sptr self) -> long

        Get total number of errors counter value.
        """
        return _fec_swig.ber_bf_sptr_total_errors(self)

    def make(self, *args, **kwargs):
        """
        make(ber_bf_sptr self, bool test_mode=False, int berminerrors=100, float ber_limit=-7.0) -> ber_bf_sptr

        BER block in FECAPI.

        This block measures the bit error rate between two streams of packed data. It compares the bits of each streams and counts the number of incorrect bits between them. It outputs the log of the bit error rate, so a value of -X is 10^{-X} bit errors.

        When the  is set to false (default), it is in streaming mode. This means that the output is constantly producing the current value of the BER. In this mode, there is a single output BER calculation per chunk of bytes passed to it, so there is no exact timing between calculations of BER. In this mode, the other two parameters to the constructor are ignored.

        When  is true, the block is in test mode. This mode is used in the ber_curve_gen example and for other offline analysis of BER curves. Here, the block waits until at least  are observed and then produces a BER calculation. The parameter  helps make sure that the simulation is controlled. If the BER calculation drops below the  setting, the block will exit and simply return the set limit; the real BER is therefore some amount lower than this.

        Note that this block takes in data as packed bytes with 8-bits per byte used. It outputs a stream of floats as the log-scale BER.

        Constructor Specific Documentation:

        Calculate the BER between two streams of data.

        Args:
            test_mode : false for normal streaming mode (default); true for test mode.
            berminerrors : the block needs to observe this many errors before outputting a result. Only valid when test_mode=true.
            ber_limit : if the BER calculation falls below this limit, produce this value and exit. Only valid when test_mode=true.
        """
        return _fec_swig.ber_bf_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(ber_bf_sptr self) -> unsigned int"""
        return _fec_swig.ber_bf_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(ber_bf_sptr self, int which, int delay)
        declare_sample_delay(ber_bf_sptr self, unsigned int delay)
        """
        return _fec_swig.ber_bf_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(ber_bf_sptr self, int which) -> unsigned int"""
        return _fec_swig.ber_bf_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(ber_bf_sptr self) -> int"""
        return _fec_swig.ber_bf_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(ber_bf_sptr self) -> double"""
        return _fec_swig.ber_bf_sptr_relative_rate(self)

    def start(self):
        """start(ber_bf_sptr self) -> bool"""
        return _fec_swig.ber_bf_sptr_start(self)

    def stop(self):
        """stop(ber_bf_sptr self) -> bool"""
        return _fec_swig.ber_bf_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(ber_bf_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.ber_bf_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(ber_bf_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.ber_bf_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(ber_bf_sptr self) -> int"""
        return _fec_swig.ber_bf_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(ber_bf_sptr self, int m)"""
        return _fec_swig.ber_bf_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(ber_bf_sptr self)"""
        return _fec_swig.ber_bf_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(ber_bf_sptr self) -> bool"""
        return _fec_swig.ber_bf_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(ber_bf_sptr self, int m)"""
        return _fec_swig.ber_bf_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(ber_bf_sptr self) -> int"""
        return _fec_swig.ber_bf_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(ber_bf_sptr self, int i) -> long"""
        return _fec_swig.ber_bf_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(ber_bf_sptr self, long max_output_buffer)
        set_max_output_buffer(ber_bf_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.ber_bf_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(ber_bf_sptr self, int i) -> long"""
        return _fec_swig.ber_bf_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(ber_bf_sptr self, long min_output_buffer)
        set_min_output_buffer(ber_bf_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.ber_bf_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(ber_bf_sptr self) -> float"""
        return _fec_swig.ber_bf_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(ber_bf_sptr self) -> float"""
        return _fec_swig.ber_bf_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(ber_bf_sptr self) -> float"""
        return _fec_swig.ber_bf_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(ber_bf_sptr self) -> float"""
        return _fec_swig.ber_bf_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(ber_bf_sptr self) -> float"""
        return _fec_swig.ber_bf_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(ber_bf_sptr self) -> float"""
        return _fec_swig.ber_bf_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(ber_bf_sptr self, int which) -> float
        pc_input_buffers_full(ber_bf_sptr self) -> pmt_vector_float
        """
        return _fec_swig.ber_bf_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(ber_bf_sptr self, int which) -> float
        pc_input_buffers_full_avg(ber_bf_sptr self) -> pmt_vector_float
        """
        return _fec_swig.ber_bf_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(ber_bf_sptr self, int which) -> float
        pc_input_buffers_full_var(ber_bf_sptr self) -> pmt_vector_float
        """
        return _fec_swig.ber_bf_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(ber_bf_sptr self, int which) -> float
        pc_output_buffers_full(ber_bf_sptr self) -> pmt_vector_float
        """
        return _fec_swig.ber_bf_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(ber_bf_sptr self, int which) -> float
        pc_output_buffers_full_avg(ber_bf_sptr self) -> pmt_vector_float
        """
        return _fec_swig.ber_bf_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(ber_bf_sptr self, int which) -> float
        pc_output_buffers_full_var(ber_bf_sptr self) -> pmt_vector_float
        """
        return _fec_swig.ber_bf_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(ber_bf_sptr self) -> float"""
        return _fec_swig.ber_bf_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(ber_bf_sptr self) -> float"""
        return _fec_swig.ber_bf_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(ber_bf_sptr self) -> float"""
        return _fec_swig.ber_bf_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(ber_bf_sptr self) -> float"""
        return _fec_swig.ber_bf_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(ber_bf_sptr self) -> float"""
        return _fec_swig.ber_bf_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(ber_bf_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.ber_bf_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(ber_bf_sptr self)"""
        return _fec_swig.ber_bf_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(ber_bf_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.ber_bf_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(ber_bf_sptr self) -> int"""
        return _fec_swig.ber_bf_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(ber_bf_sptr self) -> int"""
        return _fec_swig.ber_bf_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(ber_bf_sptr self, int priority) -> int"""
        return _fec_swig.ber_bf_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(ber_bf_sptr self) -> std::string"""
        return _fec_swig.ber_bf_sptr_name(self)

    def symbol_name(self):
        """symbol_name(ber_bf_sptr self) -> std::string"""
        return _fec_swig.ber_bf_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(ber_bf_sptr self) -> io_signature_sptr"""
        return _fec_swig.ber_bf_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(ber_bf_sptr self) -> io_signature_sptr"""
        return _fec_swig.ber_bf_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(ber_bf_sptr self) -> long"""
        return _fec_swig.ber_bf_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(ber_bf_sptr self) -> basic_block_sptr"""
        return _fec_swig.ber_bf_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(ber_bf_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.ber_bf_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(ber_bf_sptr self) -> std::string"""
        return _fec_swig.ber_bf_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(ber_bf_sptr self, std::string name)"""
        return _fec_swig.ber_bf_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(ber_bf_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.ber_bf_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(ber_bf_sptr self) -> swig_int_ptr"""
        return _fec_swig.ber_bf_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(ber_bf_sptr self) -> swig_int_ptr"""
        return _fec_swig.ber_bf_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(ber_bf_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.ber_bf_sptr_message_subscribers(self, *args, **kwargs)

ber_bf_sptr_swigregister = _fec_swig.ber_bf_sptr_swigregister
ber_bf_sptr_swigregister(ber_bf_sptr)

ber_bf_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
ber_bf = ber_bf.make;

class conv_bit_corr_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::conv_bit_corr_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::conv_bit_corr_bb)> self) -> conv_bit_corr_bb_sptr
        __init__(boost::shared_ptr<(gr::fec::conv_bit_corr_bb)> self, conv_bit_corr_bb p) -> conv_bit_corr_bb_sptr
        """
        this = _fec_swig.new_conv_bit_corr_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(conv_bit_corr_bb_sptr self) -> conv_bit_corr_bb"""
        return _fec_swig.conv_bit_corr_bb_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_conv_bit_corr_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(conv_bit_corr_bb_sptr self, std::vector< unsigned long long,std::allocator< unsigned long long > > correlator, 
            int corr_sym, int corr_len, int cut, int flush, float thresh) -> conv_bit_corr_bb_sptr

        Correlate block in FECAPI.

        What does this block do?

        Constructor Specific Documentation:



        Args:
            correlator : 
            corr_sym : 
            corr_len : 
            cut : 
            flush : 
            thresh : 
        """
        return _fec_swig.conv_bit_corr_bb_sptr_make(self, *args, **kwargs)

    def data_garble_rate(self, *args, **kwargs):
        """
        data_garble_rate(conv_bit_corr_bb_sptr self, int taps, float syn_density) -> float

        This subroutine will find the encoded data garble rate corresponding to a syndrome density of `target', that is created with an annihilating polynomial with 'taps' number of taps.
        """
        return _fec_swig.conv_bit_corr_bb_sptr_data_garble_rate(self, *args, **kwargs)

    def history(self):
        """history(conv_bit_corr_bb_sptr self) -> unsigned int"""
        return _fec_swig.conv_bit_corr_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(conv_bit_corr_bb_sptr self, int which, int delay)
        declare_sample_delay(conv_bit_corr_bb_sptr self, unsigned int delay)
        """
        return _fec_swig.conv_bit_corr_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(conv_bit_corr_bb_sptr self, int which) -> unsigned int"""
        return _fec_swig.conv_bit_corr_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(conv_bit_corr_bb_sptr self) -> int"""
        return _fec_swig.conv_bit_corr_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(conv_bit_corr_bb_sptr self) -> double"""
        return _fec_swig.conv_bit_corr_bb_sptr_relative_rate(self)

    def start(self):
        """start(conv_bit_corr_bb_sptr self) -> bool"""
        return _fec_swig.conv_bit_corr_bb_sptr_start(self)

    def stop(self):
        """stop(conv_bit_corr_bb_sptr self) -> bool"""
        return _fec_swig.conv_bit_corr_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(conv_bit_corr_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.conv_bit_corr_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(conv_bit_corr_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.conv_bit_corr_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(conv_bit_corr_bb_sptr self) -> int"""
        return _fec_swig.conv_bit_corr_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(conv_bit_corr_bb_sptr self, int m)"""
        return _fec_swig.conv_bit_corr_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(conv_bit_corr_bb_sptr self)"""
        return _fec_swig.conv_bit_corr_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(conv_bit_corr_bb_sptr self) -> bool"""
        return _fec_swig.conv_bit_corr_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(conv_bit_corr_bb_sptr self, int m)"""
        return _fec_swig.conv_bit_corr_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(conv_bit_corr_bb_sptr self) -> int"""
        return _fec_swig.conv_bit_corr_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(conv_bit_corr_bb_sptr self, int i) -> long"""
        return _fec_swig.conv_bit_corr_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(conv_bit_corr_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(conv_bit_corr_bb_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.conv_bit_corr_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(conv_bit_corr_bb_sptr self, int i) -> long"""
        return _fec_swig.conv_bit_corr_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(conv_bit_corr_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(conv_bit_corr_bb_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.conv_bit_corr_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(conv_bit_corr_bb_sptr self) -> float"""
        return _fec_swig.conv_bit_corr_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(conv_bit_corr_bb_sptr self) -> float"""
        return _fec_swig.conv_bit_corr_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(conv_bit_corr_bb_sptr self) -> float"""
        return _fec_swig.conv_bit_corr_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(conv_bit_corr_bb_sptr self) -> float"""
        return _fec_swig.conv_bit_corr_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(conv_bit_corr_bb_sptr self) -> float"""
        return _fec_swig.conv_bit_corr_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(conv_bit_corr_bb_sptr self) -> float"""
        return _fec_swig.conv_bit_corr_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(conv_bit_corr_bb_sptr self, int which) -> float
        pc_input_buffers_full(conv_bit_corr_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.conv_bit_corr_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(conv_bit_corr_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(conv_bit_corr_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.conv_bit_corr_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(conv_bit_corr_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(conv_bit_corr_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.conv_bit_corr_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(conv_bit_corr_bb_sptr self, int which) -> float
        pc_output_buffers_full(conv_bit_corr_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.conv_bit_corr_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(conv_bit_corr_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(conv_bit_corr_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.conv_bit_corr_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(conv_bit_corr_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(conv_bit_corr_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.conv_bit_corr_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(conv_bit_corr_bb_sptr self) -> float"""
        return _fec_swig.conv_bit_corr_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(conv_bit_corr_bb_sptr self) -> float"""
        return _fec_swig.conv_bit_corr_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(conv_bit_corr_bb_sptr self) -> float"""
        return _fec_swig.conv_bit_corr_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(conv_bit_corr_bb_sptr self) -> float"""
        return _fec_swig.conv_bit_corr_bb_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(conv_bit_corr_bb_sptr self) -> float"""
        return _fec_swig.conv_bit_corr_bb_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(conv_bit_corr_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.conv_bit_corr_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(conv_bit_corr_bb_sptr self)"""
        return _fec_swig.conv_bit_corr_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(conv_bit_corr_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.conv_bit_corr_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(conv_bit_corr_bb_sptr self) -> int"""
        return _fec_swig.conv_bit_corr_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(conv_bit_corr_bb_sptr self) -> int"""
        return _fec_swig.conv_bit_corr_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(conv_bit_corr_bb_sptr self, int priority) -> int"""
        return _fec_swig.conv_bit_corr_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(conv_bit_corr_bb_sptr self) -> std::string"""
        return _fec_swig.conv_bit_corr_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(conv_bit_corr_bb_sptr self) -> std::string"""
        return _fec_swig.conv_bit_corr_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(conv_bit_corr_bb_sptr self) -> io_signature_sptr"""
        return _fec_swig.conv_bit_corr_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(conv_bit_corr_bb_sptr self) -> io_signature_sptr"""
        return _fec_swig.conv_bit_corr_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(conv_bit_corr_bb_sptr self) -> long"""
        return _fec_swig.conv_bit_corr_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(conv_bit_corr_bb_sptr self) -> basic_block_sptr"""
        return _fec_swig.conv_bit_corr_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(conv_bit_corr_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.conv_bit_corr_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(conv_bit_corr_bb_sptr self) -> std::string"""
        return _fec_swig.conv_bit_corr_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(conv_bit_corr_bb_sptr self, std::string name)"""
        return _fec_swig.conv_bit_corr_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(conv_bit_corr_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.conv_bit_corr_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(conv_bit_corr_bb_sptr self) -> swig_int_ptr"""
        return _fec_swig.conv_bit_corr_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(conv_bit_corr_bb_sptr self) -> swig_int_ptr"""
        return _fec_swig.conv_bit_corr_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(conv_bit_corr_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.conv_bit_corr_bb_sptr_message_subscribers(self, *args, **kwargs)

conv_bit_corr_bb_sptr_swigregister = _fec_swig.conv_bit_corr_bb_sptr_swigregister
conv_bit_corr_bb_sptr_swigregister(conv_bit_corr_bb_sptr)

conv_bit_corr_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
conv_bit_corr_bb = conv_bit_corr_bb.make;

class puncture_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::puncture_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::puncture_bb)> self) -> puncture_bb_sptr
        __init__(boost::shared_ptr<(gr::fec::puncture_bb)> self, puncture_bb p) -> puncture_bb_sptr
        """
        this = _fec_swig.new_puncture_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(puncture_bb_sptr self) -> puncture_bb"""
        return _fec_swig.puncture_bb_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_puncture_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(puncture_bb_sptr self, int puncsize, int puncpat, int delay=0) -> puncture_bb_sptr

        Puncture a stream of unpacked bits.

        Puncture a given block of input samples of . The items produced is based on pattern . Basically, if:



        This block is designed for unpacked bits - that is, every input sample is a bit, either a 1 or 0. It's possible to use packed bits as symbols, but the puncturing will be done on the symbol level, not the bit level.

         is specified as a 32-bit integer that we can convert into the vector _puncpat used in the algorithm above:



        Example: 

        The gr.fec Python module provides a read_bitlist function that can turn a string of a puncture pattern into the correct integer form. The pattern of 0xEF could be specified as fec.readbitlist("11101111"). Also, this allows us to use puncsize=len("11101111") to make sure that our sizes are set up correctly for the pattern we want.

        The fec.extended_encoder takes in the puncture pattern directly as a string and uses the readbitlist inside to do the conversion.

        Note that due to the above concept, the default setting in the extended encoder of '11' translates into no puncturing.

        The  parameter delays the application of the puncture pattern. This is equivalent to circularly rotating the  by . Note that because of the circular shift, the delay should be between 0 and , but this is not enforced; the effective delay will simply be  mod . A negative value here is ignored.

        Constructor Specific Documentation:

        Constructs a puncture block for unpacked bits.

        Args:
            puncsize : Size of block of bits to puncture
            puncpat : The puncturing pattern
            delay : Delayed the puncturing pattern by shifting it
        """
        return _fec_swig.puncture_bb_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(puncture_bb_sptr self) -> unsigned int"""
        return _fec_swig.puncture_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(puncture_bb_sptr self, int which, int delay)
        declare_sample_delay(puncture_bb_sptr self, unsigned int delay)
        """
        return _fec_swig.puncture_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(puncture_bb_sptr self, int which) -> unsigned int"""
        return _fec_swig.puncture_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(puncture_bb_sptr self) -> int"""
        return _fec_swig.puncture_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(puncture_bb_sptr self) -> double"""
        return _fec_swig.puncture_bb_sptr_relative_rate(self)

    def start(self):
        """start(puncture_bb_sptr self) -> bool"""
        return _fec_swig.puncture_bb_sptr_start(self)

    def stop(self):
        """stop(puncture_bb_sptr self) -> bool"""
        return _fec_swig.puncture_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(puncture_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.puncture_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(puncture_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.puncture_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(puncture_bb_sptr self) -> int"""
        return _fec_swig.puncture_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(puncture_bb_sptr self, int m)"""
        return _fec_swig.puncture_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(puncture_bb_sptr self)"""
        return _fec_swig.puncture_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(puncture_bb_sptr self) -> bool"""
        return _fec_swig.puncture_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(puncture_bb_sptr self, int m)"""
        return _fec_swig.puncture_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(puncture_bb_sptr self) -> int"""
        return _fec_swig.puncture_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(puncture_bb_sptr self, int i) -> long"""
        return _fec_swig.puncture_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(puncture_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(puncture_bb_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.puncture_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(puncture_bb_sptr self, int i) -> long"""
        return _fec_swig.puncture_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(puncture_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(puncture_bb_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.puncture_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(puncture_bb_sptr self) -> float"""
        return _fec_swig.puncture_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(puncture_bb_sptr self) -> float"""
        return _fec_swig.puncture_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(puncture_bb_sptr self) -> float"""
        return _fec_swig.puncture_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(puncture_bb_sptr self) -> float"""
        return _fec_swig.puncture_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(puncture_bb_sptr self) -> float"""
        return _fec_swig.puncture_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(puncture_bb_sptr self) -> float"""
        return _fec_swig.puncture_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(puncture_bb_sptr self, int which) -> float
        pc_input_buffers_full(puncture_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.puncture_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(puncture_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(puncture_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.puncture_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(puncture_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(puncture_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.puncture_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(puncture_bb_sptr self, int which) -> float
        pc_output_buffers_full(puncture_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.puncture_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(puncture_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(puncture_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.puncture_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(puncture_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(puncture_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.puncture_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(puncture_bb_sptr self) -> float"""
        return _fec_swig.puncture_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(puncture_bb_sptr self) -> float"""
        return _fec_swig.puncture_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(puncture_bb_sptr self) -> float"""
        return _fec_swig.puncture_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(puncture_bb_sptr self) -> float"""
        return _fec_swig.puncture_bb_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(puncture_bb_sptr self) -> float"""
        return _fec_swig.puncture_bb_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(puncture_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.puncture_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(puncture_bb_sptr self)"""
        return _fec_swig.puncture_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(puncture_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.puncture_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(puncture_bb_sptr self) -> int"""
        return _fec_swig.puncture_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(puncture_bb_sptr self) -> int"""
        return _fec_swig.puncture_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(puncture_bb_sptr self, int priority) -> int"""
        return _fec_swig.puncture_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(puncture_bb_sptr self) -> std::string"""
        return _fec_swig.puncture_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(puncture_bb_sptr self) -> std::string"""
        return _fec_swig.puncture_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(puncture_bb_sptr self) -> io_signature_sptr"""
        return _fec_swig.puncture_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(puncture_bb_sptr self) -> io_signature_sptr"""
        return _fec_swig.puncture_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(puncture_bb_sptr self) -> long"""
        return _fec_swig.puncture_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(puncture_bb_sptr self) -> basic_block_sptr"""
        return _fec_swig.puncture_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(puncture_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.puncture_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(puncture_bb_sptr self) -> std::string"""
        return _fec_swig.puncture_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(puncture_bb_sptr self, std::string name)"""
        return _fec_swig.puncture_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(puncture_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.puncture_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(puncture_bb_sptr self) -> swig_int_ptr"""
        return _fec_swig.puncture_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(puncture_bb_sptr self) -> swig_int_ptr"""
        return _fec_swig.puncture_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(puncture_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.puncture_bb_sptr_message_subscribers(self, *args, **kwargs)

puncture_bb_sptr_swigregister = _fec_swig.puncture_bb_sptr_swigregister
puncture_bb_sptr_swigregister(puncture_bb_sptr)

puncture_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
puncture_bb = puncture_bb.make;

class puncture_ff_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::puncture_ff)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::puncture_ff)> self) -> puncture_ff_sptr
        __init__(boost::shared_ptr<(gr::fec::puncture_ff)> self, puncture_ff p) -> puncture_ff_sptr
        """
        this = _fec_swig.new_puncture_ff_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(puncture_ff_sptr self) -> puncture_ff"""
        return _fec_swig.puncture_ff_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_puncture_ff_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(puncture_ff_sptr self, int puncsize, int puncpat, int delay) -> puncture_ff_sptr

        Puncture a stream of floats.

        For a given block of input samples of , the items produced is based on . Basically, if:



        This block is designed for floats, generally 1's and -1's. It's possible to use other float values as symbols, but this is not the expected operation.

         is specified as a 32-bit integer that we can convert into the vector _puncpat used in the algorithm above:



        Example: 

        The gr.fec Python module provides a read_bitlist function that can turn a string of a puncture pattern into the correct integer form. The pattern of 0xEF could be specified as fec.readbitlist("11101111"). Also, this allows us to use puncsize=len("11101111") to make sure that our sizes are set up correctly for the pattern we want.

        The fec.extended_encoder takes in the puncture pattern directly as a string and uses the readbitlist inside to do the conversion.

        Note that due to the above concept, the default setting in the extended encoder of '11' translates into no puncturing.

        The  parameter delays the application of the puncture pattern. This is equivalent to circularly rotating the  by . Note that because of the circular shift, the delay should be between 0 and , but this is not enforced; the effective delay will simply be  mod . A negative value here is ignored.

        Constructor Specific Documentation:

        Constructs a puncture block for floats.

        Args:
            puncsize : Size of block of bits to puncture
            puncpat : The puncturing pattern
            delay : Delayed the puncturing pattern by shifting it
        """
        return _fec_swig.puncture_ff_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(puncture_ff_sptr self) -> unsigned int"""
        return _fec_swig.puncture_ff_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(puncture_ff_sptr self, int which, int delay)
        declare_sample_delay(puncture_ff_sptr self, unsigned int delay)
        """
        return _fec_swig.puncture_ff_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(puncture_ff_sptr self, int which) -> unsigned int"""
        return _fec_swig.puncture_ff_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(puncture_ff_sptr self) -> int"""
        return _fec_swig.puncture_ff_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(puncture_ff_sptr self) -> double"""
        return _fec_swig.puncture_ff_sptr_relative_rate(self)

    def start(self):
        """start(puncture_ff_sptr self) -> bool"""
        return _fec_swig.puncture_ff_sptr_start(self)

    def stop(self):
        """stop(puncture_ff_sptr self) -> bool"""
        return _fec_swig.puncture_ff_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(puncture_ff_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.puncture_ff_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(puncture_ff_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.puncture_ff_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(puncture_ff_sptr self) -> int"""
        return _fec_swig.puncture_ff_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(puncture_ff_sptr self, int m)"""
        return _fec_swig.puncture_ff_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(puncture_ff_sptr self)"""
        return _fec_swig.puncture_ff_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(puncture_ff_sptr self) -> bool"""
        return _fec_swig.puncture_ff_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(puncture_ff_sptr self, int m)"""
        return _fec_swig.puncture_ff_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(puncture_ff_sptr self) -> int"""
        return _fec_swig.puncture_ff_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(puncture_ff_sptr self, int i) -> long"""
        return _fec_swig.puncture_ff_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(puncture_ff_sptr self, long max_output_buffer)
        set_max_output_buffer(puncture_ff_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.puncture_ff_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(puncture_ff_sptr self, int i) -> long"""
        return _fec_swig.puncture_ff_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(puncture_ff_sptr self, long min_output_buffer)
        set_min_output_buffer(puncture_ff_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.puncture_ff_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(puncture_ff_sptr self) -> float"""
        return _fec_swig.puncture_ff_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(puncture_ff_sptr self) -> float"""
        return _fec_swig.puncture_ff_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(puncture_ff_sptr self) -> float"""
        return _fec_swig.puncture_ff_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(puncture_ff_sptr self) -> float"""
        return _fec_swig.puncture_ff_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(puncture_ff_sptr self) -> float"""
        return _fec_swig.puncture_ff_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(puncture_ff_sptr self) -> float"""
        return _fec_swig.puncture_ff_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(puncture_ff_sptr self, int which) -> float
        pc_input_buffers_full(puncture_ff_sptr self) -> pmt_vector_float
        """
        return _fec_swig.puncture_ff_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(puncture_ff_sptr self, int which) -> float
        pc_input_buffers_full_avg(puncture_ff_sptr self) -> pmt_vector_float
        """
        return _fec_swig.puncture_ff_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(puncture_ff_sptr self, int which) -> float
        pc_input_buffers_full_var(puncture_ff_sptr self) -> pmt_vector_float
        """
        return _fec_swig.puncture_ff_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(puncture_ff_sptr self, int which) -> float
        pc_output_buffers_full(puncture_ff_sptr self) -> pmt_vector_float
        """
        return _fec_swig.puncture_ff_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(puncture_ff_sptr self, int which) -> float
        pc_output_buffers_full_avg(puncture_ff_sptr self) -> pmt_vector_float
        """
        return _fec_swig.puncture_ff_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(puncture_ff_sptr self, int which) -> float
        pc_output_buffers_full_var(puncture_ff_sptr self) -> pmt_vector_float
        """
        return _fec_swig.puncture_ff_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(puncture_ff_sptr self) -> float"""
        return _fec_swig.puncture_ff_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(puncture_ff_sptr self) -> float"""
        return _fec_swig.puncture_ff_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(puncture_ff_sptr self) -> float"""
        return _fec_swig.puncture_ff_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(puncture_ff_sptr self) -> float"""
        return _fec_swig.puncture_ff_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(puncture_ff_sptr self) -> float"""
        return _fec_swig.puncture_ff_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(puncture_ff_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.puncture_ff_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(puncture_ff_sptr self)"""
        return _fec_swig.puncture_ff_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(puncture_ff_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.puncture_ff_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(puncture_ff_sptr self) -> int"""
        return _fec_swig.puncture_ff_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(puncture_ff_sptr self) -> int"""
        return _fec_swig.puncture_ff_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(puncture_ff_sptr self, int priority) -> int"""
        return _fec_swig.puncture_ff_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(puncture_ff_sptr self) -> std::string"""
        return _fec_swig.puncture_ff_sptr_name(self)

    def symbol_name(self):
        """symbol_name(puncture_ff_sptr self) -> std::string"""
        return _fec_swig.puncture_ff_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(puncture_ff_sptr self) -> io_signature_sptr"""
        return _fec_swig.puncture_ff_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(puncture_ff_sptr self) -> io_signature_sptr"""
        return _fec_swig.puncture_ff_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(puncture_ff_sptr self) -> long"""
        return _fec_swig.puncture_ff_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(puncture_ff_sptr self) -> basic_block_sptr"""
        return _fec_swig.puncture_ff_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(puncture_ff_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.puncture_ff_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(puncture_ff_sptr self) -> std::string"""
        return _fec_swig.puncture_ff_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(puncture_ff_sptr self, std::string name)"""
        return _fec_swig.puncture_ff_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(puncture_ff_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.puncture_ff_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(puncture_ff_sptr self) -> swig_int_ptr"""
        return _fec_swig.puncture_ff_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(puncture_ff_sptr self) -> swig_int_ptr"""
        return _fec_swig.puncture_ff_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(puncture_ff_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.puncture_ff_sptr_message_subscribers(self, *args, **kwargs)

puncture_ff_sptr_swigregister = _fec_swig.puncture_ff_sptr_swigregister
puncture_ff_sptr_swigregister(puncture_ff_sptr)

puncture_ff_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
puncture_ff = puncture_ff.make;

class depuncture_bb_sptr(object):
    """Proxy of C++ boost::shared_ptr<(gr::fec::depuncture_bb)> class"""
    thisown = _swig_property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc='The membership flag')
    __repr__ = _swig_repr
    def __init__(self, *args): 
        """
        __init__(boost::shared_ptr<(gr::fec::depuncture_bb)> self) -> depuncture_bb_sptr
        __init__(boost::shared_ptr<(gr::fec::depuncture_bb)> self, depuncture_bb p) -> depuncture_bb_sptr
        """
        this = _fec_swig.new_depuncture_bb_sptr(*args)
        try: self.this.append(this)
        except: self.this = this
    def __deref__(self):
        """__deref__(depuncture_bb_sptr self) -> depuncture_bb"""
        return _fec_swig.depuncture_bb_sptr___deref__(self)

    __swig_destroy__ = _fec_swig.delete_depuncture_bb_sptr
    __del__ = lambda self : None;
    def make(self, *args, **kwargs):
        """
        make(depuncture_bb_sptr self, int puncsize, int puncpat, int delay=0, char symbol=127) -> depuncture_bb_sptr

        Depuncture a stream of samples.

        Depuncture a given block of input samples of . The items produced is based on the pattern . Basically, if:



        This block is designed for unpacked bits - that is, every input sample is a bit, either a 1 or 0. It's possible to use packed bits as symbols, but the depuncturing will be done on the symbol level, not the bit level.

         is specified as a 32-bit integer that we can convert into the vector _puncpat used in the algorithm above:



        Example: 

        The gr.fec Python module provides a read_bitlist function that can turn a string of a puncture pattern into the correct integer form. The pattern of 0xEF could be specified as fec.readbitlist("11101111"). Also, this allows us to use puncsize=len("11101111") to make sure that our sizes are set up correctly for the pattern we want.

        The fec.extended_decoder takes in the puncture pattern directly as a string and uses the readbitlist inside to do the conversion.

        The  parameter delays the application of the puncture pattern. This is equivalent to circularly rotating the  by . Note that because of the circular shift, the delay should be between 0 and , but this is not enforced; the effective delay will simply be  mod . A negative value here is ignored.

        Constructor Specific Documentation:

        Constructs a depuncture block.

        Args:
            puncsize : Size of block of bits to puncture
            puncpat : The puncturing pattern
            delay : Delayed the puncturing pattern by shifting it
            symbol : The symbol to reinsert into the stream (def=127)
        """
        return _fec_swig.depuncture_bb_sptr_make(self, *args, **kwargs)

    def history(self):
        """history(depuncture_bb_sptr self) -> unsigned int"""
        return _fec_swig.depuncture_bb_sptr_history(self)

    def declare_sample_delay(self, *args):
        """
        declare_sample_delay(depuncture_bb_sptr self, int which, int delay)
        declare_sample_delay(depuncture_bb_sptr self, unsigned int delay)
        """
        return _fec_swig.depuncture_bb_sptr_declare_sample_delay(self, *args)

    def sample_delay(self, *args, **kwargs):
        """sample_delay(depuncture_bb_sptr self, int which) -> unsigned int"""
        return _fec_swig.depuncture_bb_sptr_sample_delay(self, *args, **kwargs)

    def output_multiple(self):
        """output_multiple(depuncture_bb_sptr self) -> int"""
        return _fec_swig.depuncture_bb_sptr_output_multiple(self)

    def relative_rate(self):
        """relative_rate(depuncture_bb_sptr self) -> double"""
        return _fec_swig.depuncture_bb_sptr_relative_rate(self)

    def start(self):
        """start(depuncture_bb_sptr self) -> bool"""
        return _fec_swig.depuncture_bb_sptr_start(self)

    def stop(self):
        """stop(depuncture_bb_sptr self) -> bool"""
        return _fec_swig.depuncture_bb_sptr_stop(self)

    def nitems_read(self, *args, **kwargs):
        """nitems_read(depuncture_bb_sptr self, unsigned int which_input) -> uint64_t"""
        return _fec_swig.depuncture_bb_sptr_nitems_read(self, *args, **kwargs)

    def nitems_written(self, *args, **kwargs):
        """nitems_written(depuncture_bb_sptr self, unsigned int which_output) -> uint64_t"""
        return _fec_swig.depuncture_bb_sptr_nitems_written(self, *args, **kwargs)

    def max_noutput_items(self):
        """max_noutput_items(depuncture_bb_sptr self) -> int"""
        return _fec_swig.depuncture_bb_sptr_max_noutput_items(self)

    def set_max_noutput_items(self, *args, **kwargs):
        """set_max_noutput_items(depuncture_bb_sptr self, int m)"""
        return _fec_swig.depuncture_bb_sptr_set_max_noutput_items(self, *args, **kwargs)

    def unset_max_noutput_items(self):
        """unset_max_noutput_items(depuncture_bb_sptr self)"""
        return _fec_swig.depuncture_bb_sptr_unset_max_noutput_items(self)

    def is_set_max_noutput_items(self):
        """is_set_max_noutput_items(depuncture_bb_sptr self) -> bool"""
        return _fec_swig.depuncture_bb_sptr_is_set_max_noutput_items(self)

    def set_min_noutput_items(self, *args, **kwargs):
        """set_min_noutput_items(depuncture_bb_sptr self, int m)"""
        return _fec_swig.depuncture_bb_sptr_set_min_noutput_items(self, *args, **kwargs)

    def min_noutput_items(self):
        """min_noutput_items(depuncture_bb_sptr self) -> int"""
        return _fec_swig.depuncture_bb_sptr_min_noutput_items(self)

    def max_output_buffer(self, *args, **kwargs):
        """max_output_buffer(depuncture_bb_sptr self, int i) -> long"""
        return _fec_swig.depuncture_bb_sptr_max_output_buffer(self, *args, **kwargs)

    def set_max_output_buffer(self, *args):
        """
        set_max_output_buffer(depuncture_bb_sptr self, long max_output_buffer)
        set_max_output_buffer(depuncture_bb_sptr self, int port, long max_output_buffer)
        """
        return _fec_swig.depuncture_bb_sptr_set_max_output_buffer(self, *args)

    def min_output_buffer(self, *args, **kwargs):
        """min_output_buffer(depuncture_bb_sptr self, int i) -> long"""
        return _fec_swig.depuncture_bb_sptr_min_output_buffer(self, *args, **kwargs)

    def set_min_output_buffer(self, *args):
        """
        set_min_output_buffer(depuncture_bb_sptr self, long min_output_buffer)
        set_min_output_buffer(depuncture_bb_sptr self, int port, long min_output_buffer)
        """
        return _fec_swig.depuncture_bb_sptr_set_min_output_buffer(self, *args)

    def pc_noutput_items(self):
        """pc_noutput_items(depuncture_bb_sptr self) -> float"""
        return _fec_swig.depuncture_bb_sptr_pc_noutput_items(self)

    def pc_noutput_items_avg(self):
        """pc_noutput_items_avg(depuncture_bb_sptr self) -> float"""
        return _fec_swig.depuncture_bb_sptr_pc_noutput_items_avg(self)

    def pc_noutput_items_var(self):
        """pc_noutput_items_var(depuncture_bb_sptr self) -> float"""
        return _fec_swig.depuncture_bb_sptr_pc_noutput_items_var(self)

    def pc_nproduced(self):
        """pc_nproduced(depuncture_bb_sptr self) -> float"""
        return _fec_swig.depuncture_bb_sptr_pc_nproduced(self)

    def pc_nproduced_avg(self):
        """pc_nproduced_avg(depuncture_bb_sptr self) -> float"""
        return _fec_swig.depuncture_bb_sptr_pc_nproduced_avg(self)

    def pc_nproduced_var(self):
        """pc_nproduced_var(depuncture_bb_sptr self) -> float"""
        return _fec_swig.depuncture_bb_sptr_pc_nproduced_var(self)

    def pc_input_buffers_full(self, *args):
        """
        pc_input_buffers_full(depuncture_bb_sptr self, int which) -> float
        pc_input_buffers_full(depuncture_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.depuncture_bb_sptr_pc_input_buffers_full(self, *args)

    def pc_input_buffers_full_avg(self, *args):
        """
        pc_input_buffers_full_avg(depuncture_bb_sptr self, int which) -> float
        pc_input_buffers_full_avg(depuncture_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.depuncture_bb_sptr_pc_input_buffers_full_avg(self, *args)

    def pc_input_buffers_full_var(self, *args):
        """
        pc_input_buffers_full_var(depuncture_bb_sptr self, int which) -> float
        pc_input_buffers_full_var(depuncture_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.depuncture_bb_sptr_pc_input_buffers_full_var(self, *args)

    def pc_output_buffers_full(self, *args):
        """
        pc_output_buffers_full(depuncture_bb_sptr self, int which) -> float
        pc_output_buffers_full(depuncture_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.depuncture_bb_sptr_pc_output_buffers_full(self, *args)

    def pc_output_buffers_full_avg(self, *args):
        """
        pc_output_buffers_full_avg(depuncture_bb_sptr self, int which) -> float
        pc_output_buffers_full_avg(depuncture_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.depuncture_bb_sptr_pc_output_buffers_full_avg(self, *args)

    def pc_output_buffers_full_var(self, *args):
        """
        pc_output_buffers_full_var(depuncture_bb_sptr self, int which) -> float
        pc_output_buffers_full_var(depuncture_bb_sptr self) -> pmt_vector_float
        """
        return _fec_swig.depuncture_bb_sptr_pc_output_buffers_full_var(self, *args)

    def pc_work_time(self):
        """pc_work_time(depuncture_bb_sptr self) -> float"""
        return _fec_swig.depuncture_bb_sptr_pc_work_time(self)

    def pc_work_time_avg(self):
        """pc_work_time_avg(depuncture_bb_sptr self) -> float"""
        return _fec_swig.depuncture_bb_sptr_pc_work_time_avg(self)

    def pc_work_time_var(self):
        """pc_work_time_var(depuncture_bb_sptr self) -> float"""
        return _fec_swig.depuncture_bb_sptr_pc_work_time_var(self)

    def pc_work_time_total(self):
        """pc_work_time_total(depuncture_bb_sptr self) -> float"""
        return _fec_swig.depuncture_bb_sptr_pc_work_time_total(self)

    def pc_throughput_avg(self):
        """pc_throughput_avg(depuncture_bb_sptr self) -> float"""
        return _fec_swig.depuncture_bb_sptr_pc_throughput_avg(self)

    def set_processor_affinity(self, *args, **kwargs):
        """set_processor_affinity(depuncture_bb_sptr self, std::vector< int,std::allocator< int > > const & mask)"""
        return _fec_swig.depuncture_bb_sptr_set_processor_affinity(self, *args, **kwargs)

    def unset_processor_affinity(self):
        """unset_processor_affinity(depuncture_bb_sptr self)"""
        return _fec_swig.depuncture_bb_sptr_unset_processor_affinity(self)

    def processor_affinity(self):
        """processor_affinity(depuncture_bb_sptr self) -> std::vector< int,std::allocator< int > >"""
        return _fec_swig.depuncture_bb_sptr_processor_affinity(self)

    def active_thread_priority(self):
        """active_thread_priority(depuncture_bb_sptr self) -> int"""
        return _fec_swig.depuncture_bb_sptr_active_thread_priority(self)

    def thread_priority(self):
        """thread_priority(depuncture_bb_sptr self) -> int"""
        return _fec_swig.depuncture_bb_sptr_thread_priority(self)

    def set_thread_priority(self, *args, **kwargs):
        """set_thread_priority(depuncture_bb_sptr self, int priority) -> int"""
        return _fec_swig.depuncture_bb_sptr_set_thread_priority(self, *args, **kwargs)

    def name(self):
        """name(depuncture_bb_sptr self) -> std::string"""
        return _fec_swig.depuncture_bb_sptr_name(self)

    def symbol_name(self):
        """symbol_name(depuncture_bb_sptr self) -> std::string"""
        return _fec_swig.depuncture_bb_sptr_symbol_name(self)

    def input_signature(self):
        """input_signature(depuncture_bb_sptr self) -> io_signature_sptr"""
        return _fec_swig.depuncture_bb_sptr_input_signature(self)

    def output_signature(self):
        """output_signature(depuncture_bb_sptr self) -> io_signature_sptr"""
        return _fec_swig.depuncture_bb_sptr_output_signature(self)

    def unique_id(self):
        """unique_id(depuncture_bb_sptr self) -> long"""
        return _fec_swig.depuncture_bb_sptr_unique_id(self)

    def to_basic_block(self):
        """to_basic_block(depuncture_bb_sptr self) -> basic_block_sptr"""
        return _fec_swig.depuncture_bb_sptr_to_basic_block(self)

    def check_topology(self, *args, **kwargs):
        """check_topology(depuncture_bb_sptr self, int ninputs, int noutputs) -> bool"""
        return _fec_swig.depuncture_bb_sptr_check_topology(self, *args, **kwargs)

    def alias(self):
        """alias(depuncture_bb_sptr self) -> std::string"""
        return _fec_swig.depuncture_bb_sptr_alias(self)

    def set_block_alias(self, *args, **kwargs):
        """set_block_alias(depuncture_bb_sptr self, std::string name)"""
        return _fec_swig.depuncture_bb_sptr_set_block_alias(self, *args, **kwargs)

    def _post(self, *args, **kwargs):
        """_post(depuncture_bb_sptr self, swig_int_ptr which_port, swig_int_ptr msg)"""
        return _fec_swig.depuncture_bb_sptr__post(self, *args, **kwargs)

    def message_ports_in(self):
        """message_ports_in(depuncture_bb_sptr self) -> swig_int_ptr"""
        return _fec_swig.depuncture_bb_sptr_message_ports_in(self)

    def message_ports_out(self):
        """message_ports_out(depuncture_bb_sptr self) -> swig_int_ptr"""
        return _fec_swig.depuncture_bb_sptr_message_ports_out(self)

    def message_subscribers(self, *args, **kwargs):
        """message_subscribers(depuncture_bb_sptr self, swig_int_ptr which_port) -> swig_int_ptr"""
        return _fec_swig.depuncture_bb_sptr_message_subscribers(self, *args, **kwargs)

depuncture_bb_sptr_swigregister = _fec_swig.depuncture_bb_sptr_swigregister
depuncture_bb_sptr_swigregister(depuncture_bb_sptr)

depuncture_bb_sptr.__repr__ = lambda self: "<gr_block %s (%d)>" % (self.name(), self.unique_id())
depuncture_bb = depuncture_bb.make;



